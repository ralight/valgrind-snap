diff --git a/Makefile.am b/Makefile.am
index f8c3fc58d..49a68472c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -15,7 +15,8 @@ TOOLS = \
 		none
 
 EXP_TOOLS = \
-		exp-bbv
+		exp-bbv \
+		exp-failgrind
 
 # Put docs last because building the HTML is slow and we want to get
 # everything else working before we try it.
diff --git a/callgrind/main.c b/callgrind/main.c
index 904eb42a9..c359efc4b 100644
--- a/callgrind/main.c
+++ b/callgrind/main.c
@@ -1740,7 +1740,7 @@ void collect_time (struct vki_timespec *systime, struct vki_timespec *syscputime
 }
 
 static
-void CLG_(pre_syscalltime)(ThreadId tid, UInt syscallno,
+void CLG_(pre_syscalltime)(ThreadId tid, SyscallStatus *status, UInt syscallno,
                            UWord* args, UInt nArgs)
 {
   collect_time(&syscalltime[tid],
diff --git a/configure.ac b/configure.ac
index 319401047..239f5c563 100755
--- a/configure.ac
+++ b/configure.ac
@@ -4990,6 +4990,8 @@ AC_CONFIG_FILES([
    exp-bbv/tests/amd64-linux/Makefile
    exp-bbv/tests/ppc32-linux/Makefile
    exp-bbv/tests/arm-linux/Makefile
+   exp-failgrind/Makefile
+   exp-failgrind/tests/Makefile
    shared/Makefile
    solaris/Makefile
 ])
diff --git a/coregrind/m_syswrap/syswrap-main.c b/coregrind/m_syswrap/syswrap-main.c
index cdb2663a2..3d2b0caf7 100644
--- a/coregrind/m_syswrap/syswrap-main.c
+++ b/coregrind/m_syswrap/syswrap-main.c
@@ -1714,6 +1714,12 @@ static void ensure_initialised ( void )
    }
 }
 
+void VG_(force_syscall_error) (SyscallStatus *status, UWord err)
+{
+   status->what = SsComplete;
+   status->sres = VG_(mk_SysRes_Error)(err);
+}
+
 /* --- This is the main function of this file. --- */
 
 void VG_(client_syscall) ( ThreadId tid, UInt trc )
@@ -1723,6 +1729,7 @@ void VG_(client_syscall) ( ThreadId tid, UInt trc )
    const SyscallTableEntry* ent;
    SyscallArgLayout         layout;
    SyscallInfo*             sci;
+   SyscallStatus            pre_status;
 
    ensure_initialised();
 
@@ -1894,6 +1901,8 @@ void VG_(client_syscall) ( ThreadId tid, UInt trc )
    PRINT("SYSCALL[%d,%u](%s) ",
       VG_(getpid)(), tid, VG_SYSNUM_STRING(sysno));
 
+   pre_status.what = SsHandToKernel;
+   pre_status.sres = VG_(mk_SysRes_Error)(0);
    /* Do any pre-syscall actions */
    if (VG_(needs).syscall_wrapper) {
       UWord tmpv[8];
@@ -1905,7 +1914,7 @@ void VG_(client_syscall) ( ThreadId tid, UInt trc )
       tmpv[5] = sci->orig_args.arg6;
       tmpv[6] = sci->orig_args.arg7;
       tmpv[7] = sci->orig_args.arg8;
-      VG_TDICT_CALL(tool_pre_syscall, tid, sysno,
+      VG_TDICT_CALL(tool_pre_syscall, tid, &pre_status, sysno,
                     &tmpv[0], sizeof(tmpv)/sizeof(tmpv[0]));
    }
 
@@ -1915,6 +1924,13 @@ void VG_(client_syscall) ( ThreadId tid, UInt trc )
                   &layout, 
                   &sci->args, &sci->status, &sci->flags );
    
+   if (sci->status.what == SsHandToKernel) {
+      if (pre_status.what == SsComplete) {
+         /* Only override status if ent->before didn't modify status.what */
+         //sci->status.what = SsComplete;
+         //sci->status.sres = pre_status.sres;
+      }
+   }
    /* If needed, gdbserver will report syscall entry to GDB */
    VG_(gdbserver_report_syscall)(True, sysno, tid);
 
diff --git a/coregrind/m_tooliface.c b/coregrind/m_tooliface.c
index 0c33498db..2262976cd 100644
--- a/coregrind/m_tooliface.c
+++ b/coregrind/m_tooliface.c
@@ -298,7 +298,7 @@ void VG_(needs_client_requests)(
 }
 
 void VG_(needs_syscall_wrapper)(
-   void(*pre) (ThreadId, UInt, UWord*, UInt),
+   void(*pre) (ThreadId, SyscallStatus*, UInt, UWord*, UInt),
    void(*post)(ThreadId, UInt, UWord*, UInt, SysRes res)
 )
 {
diff --git a/coregrind/pub_core_tooliface.h b/coregrind/pub_core_tooliface.h
index 6b42cc07e..4e52784d0 100644
--- a/coregrind/pub_core_tooliface.h
+++ b/coregrind/pub_core_tooliface.h
@@ -143,7 +143,7 @@ typedef struct {
    Bool (*tool_handle_client_request)(ThreadId, UWord*, UWord*);
 
    // VG_(needs).syscall_wrapper
-   void (*tool_pre_syscall) (ThreadId, UInt, UWord*, UInt);
+   void (*tool_pre_syscall) (ThreadId, SyscallStatus*, UInt, UWord*, UInt);
    void (*tool_post_syscall)(ThreadId, UInt, UWord*, UInt, SysRes);
 
    // VG_(needs).sanity_checks
diff --git a/docs/xml/manual.xml b/docs/xml/manual.xml
index 518be2964..912259300 100644
--- a/docs/xml/manual.xml
+++ b/docs/xml/manual.xml
@@ -44,5 +44,7 @@
       xmlns:xi="http://www.w3.org/2001/XInclude" />
   <xi:include href="../../exp-bbv/docs/bbv-manual.xml" parse="xml"  
       xmlns:xi="http://www.w3.org/2001/XInclude" />      
+  <xi:include href="../../exp-failgrind/docs/fg-manual.xml" parse="xml"
+      xmlns:xi="http://www.w3.org/2001/XInclude" />
 
 </book>
diff --git a/docs/xml/valgrind-manpage.xml b/docs/xml/valgrind-manpage.xml
index 5c16c6eb3..a79500956 100644
--- a/docs/xml/valgrind-manpage.xml
+++ b/docs/xml/valgrind-manpage.xml
@@ -212,6 +212,16 @@ system: <filename>&vg-docs-path;</filename>, or online:
 </refsect1>
 
 
+<refsect1 id="failgrind-options">
+<title>Failgrind Options</title>
+
+<xi:include href="../../exp-failgrind/docs/fg-manual.xml"
+            xpointer="fg.opts.list"
+            xmlns:xi="http://www.w3.org/2001/XInclude" />
+
+</refsect1>
+
+
 <refsect1 id="lackey-options">
 <title>Lackey Options</title>
 
diff --git a/exp-failgrind/Makefile.am b/exp-failgrind/Makefile.am
new file mode 100644
index 000000000..b573458b1
--- /dev/null
+++ b/exp-failgrind/Makefile.am
@@ -0,0 +1,97 @@
+include $(top_srcdir)/Makefile.tool.am
+
+EXTRA_DIST = docs/fg-manual.xml
+
+#----------------------------------------------------------------------------
+# Headers, etc
+#----------------------------------------------------------------------------
+
+pkginclude_HEADERS = failgrind.h
+noinst_HEADERS = fg_global.h clg_global.h
+#----------------------------------------------------------------------------
+# exp_failgrind-<platform>
+#----------------------------------------------------------------------------
+
+noinst_PROGRAMS  = exp-failgrind-@VGCONF_ARCH_PRI@-@VGCONF_OS@
+if VGCONF_HAVE_PLATFORM_SEC
+noinst_PROGRAMS += exp-failgrind-@VGCONF_ARCH_SEC@-@VGCONF_OS@
+endif
+
+EXP_FAILGRIND_SOURCES_COMMON = fg_main.c fg_alloc.c fg_callstack.c fg_syscall.c clg_bb.c clg_bbcc.c clg_callstack.c clg_context.c clg_fn.c clg_jumps.c clg_main.c clg_threads.c
+
+exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_SOURCES      = \
+	$(EXP_FAILGRIND_SOURCES_COMMON)
+exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_CPPFLAGS     = \
+	$(AM_CPPFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_CFLAGS       = $(LTO_CFLAGS) \
+	$(AM_CFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_DEPENDENCIES = \
+	$(TOOL_DEPENDENCIES_@VGCONF_PLATFORM_PRI_CAPS@)
+exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_LDADD        = \
+	$(TOOL_LDADD_@VGCONF_PLATFORM_PRI_CAPS@)
+exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_LDFLAGS      = \
+	$(TOOL_LDFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_LINK = \
+	$(top_builddir)/coregrind/link_tool_exe_@VGCONF_OS@ \
+	@VALT_LOAD_ADDRESS_PRI@ \
+	$(LINK) \
+	$(exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_CFLAGS) \
+	$(exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_LDFLAGS)
+
+if VGCONF_HAVE_PLATFORM_SEC
+exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_SOURCES      = \
+	$(EXP_FAILGRIND_SOURCES_COMMON)
+exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_CPPFLAGS     = \
+	$(AM_CPPFLAGS_@VGCONF_PLATFORM_SEC_CAPS@)
+exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_CFLAGS       = $(LTO_CFLAGS) \
+	$(AM_CFLAGS_@VGCONF_PLATFORM_SEC_CAPS@)
+exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_DEPENDENCIES = \
+	$(TOOL_DEPENDENCIES_@VGCONF_PLATFORM_SEC_CAPS@)
+exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_LDADD        = \
+	$(TOOL_LDADD_@VGCONF_PLATFORM_SEC_CAPS@)
+exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_LDFLAGS      = \
+	$(TOOL_LDFLAGS_@VGCONF_PLATFORM_SEC_CAPS@)
+exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_LINK = \
+	$(top_builddir)/coregrind/link_tool_exe_@VGCONF_OS@ \
+	@VALT_LOAD_ADDRESS_SEC@ \
+	$(LINK) \
+	$(exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_CFLAGS) \
+	$(exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_LDFLAGS)
+endif
+
+#----------------------------------------------------------------------------
+# vgpreload_exp_failgrind-<platform>.so
+#----------------------------------------------------------------------------
+
+noinst_PROGRAMS += vgpreload_exp-failgrind-@VGCONF_ARCH_PRI@-@VGCONF_OS@.so
+if VGCONF_HAVE_PLATFORM_SEC
+noinst_PROGRAMS += vgpreload_exp-failgrind-@VGCONF_ARCH_SEC@-@VGCONF_OS@.so
+endif
+
+if VGCONF_OS_IS_DARWIN
+noinst_DSYMS = $(noinst_PROGRAMS)
+endif
+
+vgpreload_exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_so_SOURCES      =
+vgpreload_exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_so_CPPFLAGS     = \
+	$(AM_CPPFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+vgpreload_exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_so_CFLAGS       = \
+	$(AM_CFLAGS_PSO_@VGCONF_PLATFORM_PRI_CAPS@)
+vgpreload_exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_so_DEPENDENCIES = \
+	$(LIBREPLACEMALLOC_@VGCONF_PLATFORM_PRI_CAPS@)
+vgpreload_exp_failgrind_@VGCONF_ARCH_PRI@_@VGCONF_OS@_so_LDFLAGS      = \
+	$(PRELOAD_LDFLAGS_@VGCONF_PLATFORM_PRI_CAPS@) \
+	$(LIBREPLACEMALLOC_LDFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+
+if VGCONF_HAVE_PLATFORM_SEC
+vgpreload_exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_so_SOURCES      =
+vgpreload_exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_so_CPPFLAGS     = \
+	$(AM_CPPFLAGS_@VGCONF_PLATFORM_SEC_CAPS@)
+vgpreload_exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_so_CFLAGS       = \
+	$(AM_CFLAGS_PSO_@VGCONF_PLATFORM_SEC_CAPS@)
+vgpreload_exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_so_DEPENDENCIES = \
+	$(LIBREPLACEMALLOC_@VGCONF_PLATFORM_SEC_CAPS@)
+vgpreload_exp_failgrind_@VGCONF_ARCH_SEC@_@VGCONF_OS@_so_LDFLAGS      = \
+	$(PRELOAD_LDFLAGS_@VGCONF_PLATFORM_SEC_CAPS@) \
+	$(LIBREPLACEMALLOC_LDFLAGS_@VGCONF_PLATFORM_SEC_CAPS@)
+endif
diff --git a/exp-failgrind/clg_bb.c b/exp-failgrind/clg_bb.c
new file mode 100644
index 000000000..abdf95245
--- /dev/null
+++ b/exp-failgrind/clg_bb.c
@@ -0,0 +1,310 @@
+/*--------------------------------------------------------------------*/
+/*--- Callgrind                                                    ---*/
+/*---                                                         bb.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Callgrind, a Valgrind tool for call tracing.
+
+   Copyright (C) 2002-2017, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "clg_global.h"
+
+/*------------------------------------------------------------*/
+/*--- Basic block (BB) operations                          ---*/
+/*------------------------------------------------------------*/
+
+/* BB hash, resizable */
+bb_hash bbs;
+
+void CLG_(init_bb_hash)()
+{
+   Int i;
+
+   bbs.size    = 8437;
+   bbs.entries = 0;
+   bbs.table = (BB**) CLG_MALLOC("cl.bb.ibh.1",
+                                 bbs.size * sizeof(BB*));
+
+   for (i = 0; i < bbs.size; i++) bbs.table[i] = NULL;
+}
+
+bb_hash* CLG_(get_bb_hash)()
+{
+   return &bbs;
+}
+
+/* The hash stores BBs according to
+ * - ELF object (is 0 for code in anonymous mapping)
+ * - BB base as object file offset
+ */
+static __inline__
+UInt bb_hash_idx(obj_node* obj, PtrdiffT offset, UInt size)
+{
+   return (((Addr)obj) + offset) % size;
+}
+
+/* double size of bb table  */
+static
+void resize_bb_table(void)
+{
+   Int i, new_size, conflicts1 = 0, conflicts2 = 0;
+   BB **new_table, *curr, *next;
+   UInt new_idx;
+
+   new_size  = 2* bbs.size +3;
+   new_table = (BB**) CLG_MALLOC("cl.bb.rbt.1",
+                                 new_size * sizeof(BB*));
+
+   for (i = 0; i < new_size; i++) {
+      new_table[i] = NULL;
+   }
+
+   for (i = 0; i < bbs.size; i++) {
+      if (bbs.table[i] == NULL) continue;
+
+      curr = bbs.table[i];
+      while (NULL != curr) {
+         next = curr->next;
+
+         new_idx = bb_hash_idx(curr->obj, curr->offset, new_size);
+
+         curr->next = new_table[new_idx];
+         new_table[new_idx] = curr;
+         if (curr->next) {
+            conflicts1++;
+            if (curr->next->next) {
+               conflicts2++;
+            }
+         }
+
+         curr = next;
+      }
+   }
+
+   VG_(free)(bbs.table);
+
+   bbs.size  = new_size;
+   bbs.table = new_table;
+}
+
+
+/**
+ * Allocate new BB structure (including space for event type list)
+ * Not initialized:
+ * - instr_len, cost_count, instr[]
+ */
+static BB* new_bb(obj_node* obj, PtrdiffT offset,
+      UInt instr_count, UInt cjmp_count, Bool cjmp_inverted)
+{
+   BB* bb;
+   UInt idx, size;
+
+   /* check fill degree of bb hash table and resize if needed (>80%) */
+   bbs.entries++;
+   if (10 * bbs.entries / bbs.size > 8) {
+      resize_bb_table();
+   }
+
+   size = sizeof(BB) + instr_count * sizeof(InstrInfo)
+                     + (cjmp_count+1) * sizeof(CJmpInfo);
+   bb = (BB*) CLG_MALLOC("cl.bb.nb.1", size);
+   VG_(memset)(bb, 0, size);
+
+   bb->obj        = obj;
+   bb->offset     = offset;
+
+   bb->instr_count = instr_count;
+   bb->cjmp_count  = cjmp_count;
+   bb->cjmp_inverted = cjmp_inverted;
+   bb->jmp         = (CJmpInfo*) &(bb->instr[instr_count]);
+   bb->instr_len   = 0;
+   bb->sect_kind   = VG_(DebugInfo_sect_kind)(NULL, offset + obj->offset);
+   bb->fn          = 0;
+   bb->line        = 0;
+   bb->is_entry    = 0;
+   bb->bbcc_list   = 0;
+   bb->last_bbcc   = 0;
+
+   /* insert into BB hash table */
+   idx = bb_hash_idx(obj, offset, bbs.size);
+   bb->next = bbs.table[idx];
+   bbs.table[idx] = bb;
+
+   CLG_(get_fn_node)(bb);
+
+   return bb;
+}
+
+
+/* get the BB structure for a BB start address */
+static __inline__
+BB* lookup_bb(obj_node* obj, PtrdiffT offset)
+{
+   BB* bb;
+   Int idx;
+
+   idx = bb_hash_idx(obj, offset, bbs.size);
+   bb = bbs.table[idx];
+
+   while(bb) {
+      if ((bb->obj == obj) && (bb->offset == offset)) break;
+      bb = bb->next;
+   }
+
+   return bb;
+}
+
+static __inline__
+obj_node* obj_of_address(Addr addr)
+{
+   obj_node* obj;
+   DebugInfo* di;
+   PtrdiffT offset;
+
+   DiEpoch ep = VG_(current_DiEpoch)();
+   di = VG_(find_DebugInfo)(ep, addr);
+   obj = CLG_(get_obj_node)( di );
+
+   /* Update symbol offset in object if remapped */
+   /* FIXME (or at least check this) 2008 Feb 19: 'offset' is
+      only correct for text symbols, not for data symbols */
+   offset = di ? VG_(DebugInfo_get_text_bias)(di):0;
+   if (obj->offset != offset) {
+      Addr start = di ? VG_(DebugInfo_get_text_avma)(di) : 0;
+
+      /* Size should be the same, and offset diff == start diff */
+      CLG_ASSERT( obj->size == (di ? VG_(DebugInfo_get_text_size)(di) : 0) );
+      CLG_ASSERT( obj->start - start == obj->offset - offset );
+      obj->offset = offset;
+      obj->start = start;
+   }
+
+   return obj;
+}
+
+/* Get the BB structure for a BB start address.
+ * If the BB has to be created, the IRBB is needed to
+ * compute the event type list for costs, and seen_before is
+ * set to False. Otherwise, seen_before is set to True.
+ *
+ * BBs are never discarded. There are 2 cases where this function
+ * is called from CLG_(instrument)() and a BB already exists:
+ * - The instrumented version was removed from Valgrinds TT cache
+ * - The ELF object of the BB was unmapped and mapped again.
+ *   This involves a possibly different address, but is handled by
+ *   looking up a BB keyed by (obj_node, file offset).
+ *
+ * bbIn==0 is possible for artificial BB without real code.
+ * Such a BB is created when returning to an unknown function.
+ */
+BB* CLG_(get_bb)(Addr addr, IRSB* bbIn, /*OUT*/ Bool *seen_before)
+{
+   BB*   bb;
+   obj_node* obj;
+   UInt n_instrs, n_jmps;
+   Bool cjmp_inverted = False;
+
+   obj = obj_of_address(addr);
+   bb = lookup_bb(obj, addr - obj->offset);
+
+   n_instrs = 0;
+   n_jmps = 0;
+   CLG_(collectBlockInfo)(bbIn, &n_instrs, &n_jmps, &cjmp_inverted);
+
+   *seen_before = bb ? True : False;
+   if (*seen_before) {
+      if (bb->instr_count != n_instrs) {
+         VG_(message)(Vg_DebugMsg,
+               "ERROR: BB Retranslation Mismatch at BB %#lx\n", addr);
+         VG_(message)(Vg_DebugMsg,
+               "  new: Obj %s, Off %#lx, BBOff %#lx, Instrs %u\n",
+               obj->name, (UWord)obj->offset,
+               addr - obj->offset, n_instrs);
+         VG_(message)(Vg_DebugMsg,
+               "  old: Obj %s, Off %#lx, BBOff %#lx, Instrs %u\n",
+               bb->obj->name, (UWord)bb->obj->offset,
+               (UWord)bb->offset, bb->instr_count);
+         CLG_ASSERT(bb->instr_count == n_instrs );
+      }
+      CLG_ASSERT(bb->cjmp_count == n_jmps );
+      return bb;
+   }
+
+   bb = new_bb(obj, addr - obj->offset, n_instrs, n_jmps, cjmp_inverted);
+
+   return bb;
+}
+
+/* Delete the BB info for the bb with unredirected entry-point
+   address 'addr'. */
+void CLG_(delete_bb)(Addr addr)
+{
+   BB  *bb, *bp;
+   Int idx, size;
+
+   obj_node* obj = obj_of_address(addr);
+   PtrdiffT offset = addr - obj->offset;
+
+   idx = bb_hash_idx(obj, offset, bbs.size);
+   bb = bbs.table[idx];
+
+   /* bb points at the current bb under consideration, and bp is the
+      one before. */
+   bp = NULL;
+   while(bb) {
+      if ((bb->obj == obj) && (bb->offset == offset)) break;
+      bp = bb;
+      bb = bb->next;
+   }
+
+   if (bb == NULL) {
+      /* we didn't find it.
+       * this happens when callgrinds instrumentation mode
+       * was off at BB translation time, ie. no BB was created.
+       */
+      return;
+   }
+
+   /* unlink it from hash table */
+
+   if (bp == NULL) {
+      /* we found the first one in the list. */
+      tl_assert(bb == bbs.table[idx]);
+      bbs.table[idx] = bb->next;
+   } else {
+      tl_assert(bb != bbs.table[idx]);
+      bp->next = bb->next;
+   }
+
+   if (bb->bbcc_list == 0) {
+      /* can be safely deleted */
+
+      /* Fill the block up with junk and then free it, so we will
+         hopefully get a segfault if it is used again by mistake. */
+      size = sizeof(BB)
+            + bb->instr_count * sizeof(InstrInfo)
+            + (bb->cjmp_count+1) * sizeof(CJmpInfo);
+      VG_(memset)( bb, 0xAA, size );
+      CLG_FREE(bb);
+      return;
+   }
+}
diff --git a/exp-failgrind/clg_bbcc.c b/exp-failgrind/clg_bbcc.c
new file mode 100644
index 000000000..a5bf01454
--- /dev/null
+++ b/exp-failgrind/clg_bbcc.c
@@ -0,0 +1,537 @@
+/*--------------------------------------------------------------------*/
+/*--- Callgrind                                                    ---*/
+/*---                                                       bbcc.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Callgrind, a Valgrind tool for call tracing.
+
+   Copyright (C) 2002-2017, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "clg_global.h"
+
+#include "pub_tool_threadstate.h"
+
+/*------------------------------------------------------------*/
+/*--- BBCC operations                                      ---*/
+/*------------------------------------------------------------*/
+
+#define N_BBCC_INITIAL_ENTRIES  10437
+
+/* BBCC table (key is BB/Context), per thread, resizable */
+bbcc_hash current_bbccs;
+
+void CLG_(init_bbcc_hash)(bbcc_hash* bbccs)
+{
+   Int i;
+
+   CLG_ASSERT(bbccs != 0);
+
+   bbccs->size    = N_BBCC_INITIAL_ENTRIES;
+   bbccs->entries = 0;
+   bbccs->table = (BBCC**) CLG_MALLOC("cl.bbcc.ibh.1",
+                                      bbccs->size * sizeof(BBCC*));
+
+   for (i = 0; i < bbccs->size; i++) bbccs->table[i] = NULL;
+}
+
+void CLG_(copy_current_bbcc_hash)(bbcc_hash* dst)
+{
+   CLG_ASSERT(dst != 0);
+
+   dst->size    = current_bbccs.size;
+   dst->entries = current_bbccs.entries;
+   dst->table   = current_bbccs.table;
+}
+
+bbcc_hash* CLG_(get_current_bbcc_hash)()
+{
+   return &current_bbccs;
+}
+
+void CLG_(set_current_bbcc_hash)(bbcc_hash* h)
+{
+   CLG_ASSERT(h != 0);
+
+   current_bbccs.size    = h->size;
+   current_bbccs.entries = h->entries;
+   current_bbccs.table   = h->table;
+}
+
+
+/* All BBCCs for recursion level 0 are inserted into a
+ * thread specific hash table with key
+ * - address of BB structure (unique, as never freed)
+ * - current context (includes caller chain)
+ * BBCCs for other recursion levels are in bbcc->rec_array.
+ *
+ * The hash is used in setup_bb(), i.e. to find the cost
+ * counters to be changed in the execution of a BB.
+ */
+
+static __inline__
+UInt bbcc_hash_idx(BB* bb, Context* cxt, UInt size)
+{
+   CLG_ASSERT(bb != 0);
+   CLG_ASSERT(cxt != 0);
+
+   return ((Addr)bb + (Addr)cxt) % size;
+}
+
+
+/* Lookup for a BBCC in hash. */
+static
+BBCC* lookup_bbcc(BB* bb, Context* cxt)
+{
+   BBCC* bbcc = bb->last_bbcc;
+   UInt  idx;
+
+   /* check LRU */
+   if (bbcc->cxt == cxt) {
+      if (bbcc->tid == CLG_(current_tid)) return bbcc;
+   }
+
+   idx = bbcc_hash_idx(bb, cxt, current_bbccs.size);
+   bbcc = current_bbccs.table[idx];
+   while (bbcc &&
+         (bb      != bbcc->bb ||
+         cxt     != bbcc->cxt)) {
+
+      bbcc = bbcc->next;
+   }
+
+   return bbcc;
+}
+
+
+/* double size of hash table 1 (addr->BBCC) */
+static void resize_bbcc_hash(void)
+{
+   Int i, new_size, conflicts1 = 0, conflicts2 = 0;
+   BBCC** new_table;
+   UInt new_idx;
+   BBCC *curr_BBCC, *next_BBCC;
+
+   new_size = 2*current_bbccs.size+3;
+   new_table = (BBCC**) CLG_MALLOC("cl.bbcc.rbh.1",
+                                   new_size * sizeof(BBCC*));
+
+   for (i = 0; i < new_size; i++) {
+      new_table[i] = NULL;
+   }
+
+   for (i = 0; i < current_bbccs.size; i++) {
+      if (current_bbccs.table[i] == NULL) continue;
+
+      curr_BBCC = current_bbccs.table[i];
+      while (NULL != curr_BBCC) {
+         next_BBCC = curr_BBCC->next;
+
+         new_idx = bbcc_hash_idx(curr_BBCC->bb,
+               curr_BBCC->cxt,
+               new_size);
+
+         curr_BBCC->next = new_table[new_idx];
+         new_table[new_idx] = curr_BBCC;
+         if (curr_BBCC->next) {
+            conflicts1++;
+            if (curr_BBCC->next->next) {
+               conflicts2++;
+            }
+         }
+
+         curr_BBCC = next_BBCC;
+      }
+   }
+
+   VG_(free)(current_bbccs.table);
+
+   current_bbccs.size = new_size;
+   current_bbccs.table = new_table;
+}
+
+
+static __inline
+BBCC** new_recursion(int size)
+{
+   BBCC** bbccs;
+   int i;
+
+   bbccs = (BBCC**) CLG_MALLOC("cl.bbcc.nr.1", sizeof(BBCC*) * size);
+   for (i=0; i<size; i++) {
+      bbccs[i] = 0;
+   }
+
+   return bbccs;
+}
+
+
+/*
+ * Allocate a new BBCC
+ *
+ * Uninitialized:
+ * cxt, next_bbcc, next1, next2
+ */
+static __inline__
+BBCC* new_bbcc(BB* bb)
+{
+   BBCC* bbcc;
+   Int i;
+
+   /* We need cjmp_count+1 JmpData structs:
+    * the last is for the unconditional jump/call/ret at end of BB
+    */
+   bbcc = (BBCC*)CLG_MALLOC("cl.bbcc.nb.1",
+         sizeof(BBCC) + (bb->cjmp_count+1) * sizeof(JmpData));
+
+   bbcc->bb  = bb;
+   bbcc->tid = CLG_(current_tid);
+
+   for (i=0; i<=bb->cjmp_count; i++) {
+      bbcc->jmp[i].jcc_list = 0;
+   }
+
+   /* Init pointer caches (LRU) */
+   bbcc->lru_next_bbcc = 0;
+   bbcc->lru_from_jcc  = 0;
+   bbcc->lru_to_jcc  = 0;
+
+   return bbcc;
+}
+
+
+/**
+ * Inserts a new BBCC into hashes.
+ * BBCC specific items must be set as this is used for the hash
+ * keys:
+ *  fn     : current function
+ *  tid    : current thread ID
+ *  from   : position where current function is called from
+ *
+ * Recursion level doesn't need to be set as this is not included
+ * in the hash key: Only BBCCs with rec level 0 are in hashes.
+ */
+static
+void insert_bbcc_into_hash(BBCC* bbcc)
+{
+   UInt idx;
+
+   CLG_ASSERT(bbcc->cxt != 0);
+
+   /* check fill degree of hash and resize if needed (>90%) */
+   current_bbccs.entries++;
+   if (100 * current_bbccs.entries / current_bbccs.size > 90) {
+      resize_bbcc_hash();
+   }
+
+   idx = bbcc_hash_idx(bbcc->bb, bbcc->cxt, current_bbccs.size);
+   bbcc->next = current_bbccs.table[idx];
+   current_bbccs.table[idx] = bbcc;
+}
+
+/* String is returned in a dynamically allocated buffer. Caller is
+   responsible for free'ing it. */
+static HChar* mangled_cxt(const Context* cxt)
+{
+   Int i, p;
+
+   if (!cxt) return VG_(strdup)("cl.bbcc.mcxt", "(no context)");
+
+   /* Overestimate the number of bytes we need to hold the string. */
+   SizeT need = 20;   // rec_index + nul-terminator
+   for (i = 0; i < cxt->size; ++i) {
+      need += VG_(strlen)(cxt->fn[i]->name) + 1;   // 1 for leading '
+   }
+
+   HChar *mangled = CLG_MALLOC("cl.bbcc.mcxt", need);
+   p = VG_(sprintf)(mangled, "%s", cxt->fn[0]->name);
+   for (i=1; i<cxt->size; i++) {
+      p += VG_(sprintf)(mangled+p, "'%s", cxt->fn[i]->name);
+   }
+
+   return mangled;
+}
+
+
+/* Create a new BBCC as a copy of an existing one,
+ * but with costs set to 0 and jcc chains empty.
+ *
+ * This is needed when a BB is executed in another context than
+ * the one at instrumentation time of the BB.
+ *
+ * Use cases:
+ *  clone from a BBCC with differing tid/cxt
+ *  and insert into hashes
+ */
+static BBCC* clone_bbcc(BBCC* orig, Context* cxt)
+{
+   BBCC* bbcc;
+
+   bbcc = new_bbcc(orig->bb);
+
+   /* hash insertion is only allowed if tid or cxt is different */
+   CLG_ASSERT((orig->tid != CLG_(current_tid)) || (orig->cxt != cxt));
+
+   bbcc->cxt = cxt;
+
+   insert_bbcc_into_hash(bbcc);
+
+   /* update list of BBCCs for same BB */
+   bbcc->next_bbcc = orig->bb->bbcc_list;
+   orig->bb->bbcc_list = bbcc;
+
+   HChar *mangled_orig = mangled_cxt(orig->cxt);
+   HChar *mangled_bbcc = mangled_cxt(bbcc->cxt);
+   CLG_FREE(mangled_orig);
+   CLG_FREE(mangled_bbcc);
+
+   return bbcc;
+}
+
+
+/* Get a pointer to the cost centre structure for given basic block
+ * address. If created, the BBCC is inserted into the BBCC hash.
+ * Also sets BB_seen_before by reference.
+ *
+ */
+BBCC* CLG_(get_bbcc)(BB* bb)
+{
+   BBCC* bbcc;
+
+   bbcc = bb->bbcc_list;
+
+   if (!bbcc) {
+      bbcc = new_bbcc(bb);
+
+      /* initialize BBCC */
+      bbcc->cxt       = 0;
+
+      bbcc->next_bbcc = bb->bbcc_list;
+      bb->bbcc_list = bbcc;
+      bb->last_bbcc = bbcc;
+   }
+
+   return bbcc;
+}
+
+
+/*
+ * Helper function called at start of each instrumented BB to setup
+ * pointer to costs for current thread/context/recursion level
+ */
+
+VG_REGPARM(1)
+void CLG_(setup_bbcc)(BB* bb)
+{
+   BBCC *bbcc, *last_bbcc;
+   Bool  call_emulation = False, delayed_push = False, skip = False;
+   Addr sp;
+   BB* last_bb;
+   ThreadId tid;
+   ClgJumpKind jmpkind;
+   Int passed = 0, csp;
+   Bool ret_without_call = False;
+   Int popcount_on_return = 1;
+
+   /* This is needed because thread switches can not reliable be tracked
+    * with callback CLG_(run_thread) only: we have otherwise no way to get
+    * the thread ID after a signal handler returns.
+    * This could be removed again if that bug is fixed in Valgrind.
+    * This is in the hot path but hopefully not to costly.
+    */
+   tid = VG_(get_running_tid)();
+
+   /* CLG_(switch_thread) is a no-op when tid is equal to CLG_(current_tid).
+    * As this is on the hot path, we only call CLG_(switch_thread)(tid)
+    * if tid differs from the CLG_(current_tid).
+    */
+   if (UNLIKELY(tid != CLG_(current_tid))) {
+      CLG_(switch_thread)(tid);
+   }
+
+   sp = VG_(get_SP)(tid);
+   last_bbcc = CLG_(current_state).bbcc;
+   last_bb = last_bbcc ? last_bbcc->bb : 0;
+
+   if (last_bb) {
+      passed = CLG_(current_state).jmps_passed;
+      CLG_ASSERT(passed <= last_bb->cjmp_count);
+      jmpkind = last_bb->jmp[passed].jmpkind;
+   } else {
+      jmpkind = jk_None;
+   }
+
+   /* Manipulate JmpKind if needed, only using BB specific info */
+
+   csp = CLG_(current_call_stack).sp;
+
+   /* A return not matching the top call in our callstack is a jump */
+   if ( (jmpkind == jk_Return) && (csp >0)) {
+      Int csp_up = csp-1;
+      call_entry* top_ce = &(CLG_(current_call_stack).entry[csp_up]);
+
+      /* We have a real return if
+       * - the stack pointer (SP) left the current stack frame, or
+       * - SP has the same value as when reaching the current function
+       *   and the address of this BB is the return address of last call
+       *   (we even allow to leave multiple frames if the SP stays the
+       *    same and we find a matching return address)
+       * The latter condition is needed because on PPC, SP can stay
+       * the same over CALL=b(c)l / RET=b(c)lr boundaries
+       */
+      if (sp < top_ce->sp) {
+         popcount_on_return = 0;
+      } else if (top_ce->sp == sp) {
+         while(1) {
+            if (top_ce->ret_addr == bb_addr(bb)) break;
+            if (csp_up>0) {
+               csp_up--;
+               top_ce = &(CLG_(current_call_stack).entry[csp_up]);
+               if (top_ce->sp == sp) {
+                  popcount_on_return++;
+                  continue;
+               }
+            }
+            popcount_on_return = 0;
+            break;
+         }
+      }
+      if (popcount_on_return == 0) {
+         jmpkind = jk_Jump;
+         ret_without_call = True;
+      }
+   }
+
+   /* Should this jump be converted to call or pop/call ? */
+   if ((jmpkind != jk_Return) && (jmpkind != jk_Call) && last_bb) {
+
+      /* We simulate a JMP/Cont to be a CALL if
+       * - jump is in another ELF object or section kind
+       * - jump is to first instruction of a function (tail recursion)
+       */
+      if (ret_without_call ||
+         /* This is for detection of optimized tail recursion.
+          * On PPC, this is only detected as call when going to another
+          * function. The problem is that on PPC it can go wrong
+          * more easily (no stack frame setup needed)
+          */
+#if defined(VGA_ppc32)
+            (bb->is_entry && (last_bb->fn != bb->fn)) ||
+#else
+            bb->is_entry ||
+#endif
+            (last_bb->sect_kind != bb->sect_kind) ||
+            (last_bb->obj->number != bb->obj->number)) {
+
+         jmpkind = jk_Call;
+         call_emulation = True;
+      }
+   }
+
+   /* Handle CALL/RET and update context to get correct BBCC */
+
+   if (jmpkind == jk_Return) {
+      if ((csp == 0) ||
+            ((CLG_(current_fn_stack).top > CLG_(current_fn_stack).bottom) &&
+            (*(CLG_(current_fn_stack).top-1)==0))) {
+
+         /* Should never get here because instrumentation is always on or
+          * always off. */
+         CLG_ASSERT(0);
+      } else {
+         CLG_ASSERT(popcount_on_return >0);
+         CLG_(unwind_call_stack)(sp, popcount_on_return);
+      }
+   } else {
+      Int unwind_count = CLG_(unwind_call_stack)(sp, 0);
+      if (unwind_count > 0) {
+         /* if unwinding was done, this actually is a return */
+         jmpkind = jk_Return;
+      }
+
+      if (jmpkind == jk_Call) {
+         delayed_push = True;
+
+         csp = CLG_(current_call_stack).sp;
+         if (call_emulation && csp>0) {
+            sp = CLG_(current_call_stack).entry[csp-1].sp;
+         }
+      }
+   }
+
+   /* Change new context if needed, taking delayed_push into account */
+   if (delayed_push || (CLG_(current_state).cxt == 0)) {
+      CLG_(push_cxt)(CLG_(get_fn_node)(bb));
+   }
+   CLG_ASSERT(CLG_(current_fn_stack).top > CLG_(current_fn_stack).bottom);
+
+   /* If there is a fresh instrumented BBCC, assign current context */
+   bbcc = CLG_(get_bbcc)(bb);
+   if (bbcc->cxt == 0) {
+      bbcc->cxt = CLG_(current_state).cxt;
+      insert_bbcc_into_hash(bbcc);
+   } else {
+      /* get BBCC with current context */
+
+      /* first check LRU of last bbcc executed */
+
+      if (last_bbcc) {
+         bbcc = last_bbcc->lru_next_bbcc;
+         if (bbcc && ((bbcc->bb != bb) ||
+               (bbcc->cxt != CLG_(current_state).cxt))) {
+
+            bbcc = 0;
+         }
+      } else {
+         bbcc = 0;
+      }
+
+      if (!bbcc) {
+         bbcc = lookup_bbcc(bb, CLG_(current_state).cxt);
+      }
+      if (!bbcc) {
+         bbcc = clone_bbcc(bb->bbcc_list, CLG_(current_state).cxt);
+      }
+
+      bb->last_bbcc = bbcc;
+   }
+
+   /* save for fast lookup */
+   if (last_bbcc) {
+      last_bbcc->lru_next_bbcc = bbcc;
+   }
+
+   if (delayed_push) {
+      if (CLG_(current_state).nonskipped) {
+         /* a call from skipped to nonskipped */
+         CLG_(current_state).bbcc = CLG_(current_state).nonskipped;
+         /* FIXME: take the real passed count from shadow stack */
+         passed = CLG_(current_state).bbcc->bb->cjmp_count;
+      }
+      CLG_(push_call_stack)(CLG_(current_state).bbcc, passed, bbcc, sp, skip);
+   }
+
+   CLG_(current_state).bbcc = bbcc;
+   /* Even though this will be set in instrumented code directly before
+    * side exits, it needs to be set to 0 here in case an exception
+    * happens in first instructions of the BB */
+   CLG_(current_state).jmps_passed = 0;
+}
diff --git a/exp-failgrind/clg_callstack.c b/exp-failgrind/clg_callstack.c
new file mode 100644
index 000000000..a96142d8b
--- /dev/null
+++ b/exp-failgrind/clg_callstack.c
@@ -0,0 +1,284 @@
+/*--------------------------------------------------------------------*/
+/*--- Callgrind                                                    ---*/
+/*---                                               ct_callstack.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Callgrind, a Valgrind tool for call tracing.
+
+   Copyright (C) 2002-2017, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "clg_global.h"
+#include "fg_global.h"
+
+/*------------------------------------------------------------*/
+/*--- Call stack, operations                               ---*/
+/*------------------------------------------------------------*/
+
+/* Stack of current thread. Gets initialized when switching to 1st thread.
+ *
+ * The artificial call stack is an array of call_entry's, representing
+ * stack frames of the executing program.
+ * Array call_stack and call_stack_esp have same size and grow on demand.
+ * Array call_stack_esp holds SPs of corresponding stack frames.
+ *
+ */
+
+#define N_CALL_STACK_INITIAL_ENTRIES 500
+
+call_stack CLG_(current_call_stack);
+
+void CLG_(init_call_stack)(call_stack* s)
+{
+   CLG_ASSERT(s != 0);
+
+   s->size = N_CALL_STACK_INITIAL_ENTRIES;
+   s->entry = (call_entry*) CLG_MALLOC("cl.callstack.ics.1",
+         s->size * sizeof(call_entry));
+
+   s->sp = 0;
+   s->entry[0].cxt = 0; /* for assertion in push_cxt() */
+}
+
+call_entry* CLG_(get_call_entry)(Int sp)
+{
+   CLG_ASSERT(sp <= CLG_(current_call_stack).sp);
+   return &(CLG_(current_call_stack).entry[sp]);
+}
+
+void CLG_(copy_current_call_stack)(call_stack* dst)
+{
+   CLG_ASSERT(dst != 0);
+
+   dst->size  = CLG_(current_call_stack).size;
+   dst->entry = CLG_(current_call_stack).entry;
+   dst->sp    = CLG_(current_call_stack).sp;
+}
+
+void CLG_(set_current_call_stack)(call_stack* s)
+{
+   CLG_ASSERT(s != 0);
+
+   CLG_(current_call_stack).size  = s->size;
+   CLG_(current_call_stack).entry = s->entry;
+   CLG_(current_call_stack).sp    = s->sp;
+}
+
+
+static __inline__
+void ensure_stack_size(Int i)
+{
+   call_stack *cs = &CLG_(current_call_stack);
+
+   if (i < cs->size) return;
+
+   cs->size *= 2;
+   while (i > cs->size) cs->size *= 2;
+
+   cs->entry = (call_entry*) VG_(realloc)("cl.callstack.ess.1",
+         cs->entry, cs->size * sizeof(call_entry));
+}
+
+
+
+/* Called when function entered nonrecursive */
+static void function_entered(fn_node* fn)
+{
+   CLG_ASSERT(fn != 0);
+
+   if (!VG_(strcmp)(fn->name, "main")) {
+      FG_(in_main) = True;
+   }
+
+   if (fn->toggle_alloc_fail) {
+      FG_(alloc_fail) = !FG_(alloc_fail);
+   }
+   if (fn->toggle_syscall_fail) {
+      FG_(syscall_fail) = !FG_(syscall_fail);
+   }
+}
+
+/* Called when function left (no recursive level active) */
+static void function_left(fn_node* fn)
+{
+   CLG_ASSERT(fn != 0);
+
+   if (fn->toggle_alloc_fail) {
+      FG_(alloc_fail) = !FG_(alloc_fail);
+   }
+   if (fn->toggle_syscall_fail) {
+      FG_(syscall_fail) = !FG_(syscall_fail);
+   }
+}
+
+
+/* Push call on call stack.
+ *
+ * Increment the usage count for the function called.
+ * A jump from <from> to <to>, with <sp>.
+ * If <skip> is true, this is a call to a function to be skipped;
+ * for this, we set jcc = 0.
+ */
+void CLG_(push_call_stack)(BBCC* from, UInt jmp, BBCC* to, Addr sp, Bool skip)
+{
+   jCC* jcc;
+   UInt* pdepth;
+   call_entry* current_entry;
+   Addr ret_addr;
+
+   /* Ensure a call stack of size <current_sp>+1.
+    * The +1 is needed as push_cxt will store the
+    * context at [current_sp]
+    */
+   ensure_stack_size(CLG_(current_call_stack).sp +1);
+   current_entry = &(CLG_(current_call_stack).entry[CLG_(current_call_stack).sp]);
+
+   if (skip) {
+      jcc = 0;
+   } else {
+      fn_node* to_fn = to->cxt->fn[0];
+
+      if (CLG_(current_state).nonskipped) {
+         /* this is a jmp from skipped to nonskipped */
+         CLG_ASSERT(CLG_(current_state).nonskipped == from);
+      }
+
+      /* As push_cxt() has to be called before push_call_stack if not
+       * skipping, the old context should already be saved on the stack */
+      CLG_ASSERT(current_entry->cxt != 0);
+
+      jcc = CLG_(get_jcc)(from, jmp, to);
+      CLG_ASSERT(jcc != 0);
+
+      pdepth = CLG_(get_fn_entry)(to_fn->number);
+      (*pdepth)++;
+
+      if (*pdepth == 1) function_entered(to_fn);
+   }
+
+   /* return address is only is useful with a real call;
+    * used to detect RET w/o CALL */
+   if (from->bb->jmp[jmp].jmpkind == jk_Call) {
+      UInt instr = from->bb->jmp[jmp].instr;
+      ret_addr = bb_addr(from->bb) +
+            from->bb->instr[instr].instr_offset +
+            from->bb->instr[instr].instr_size;
+   } else {
+      ret_addr = 0;
+   }
+
+   /* put jcc on call stack */
+   current_entry->jcc = jcc;
+   current_entry->sp = sp;
+   current_entry->ret_addr = ret_addr;
+   current_entry->nonskipped = CLG_(current_state).nonskipped;
+
+   CLG_(current_call_stack).sp++;
+
+   /* To allow for above assertion we set context of next frame to 0 */
+   CLG_ASSERT(CLG_(current_call_stack).sp < CLG_(current_call_stack).size);
+   current_entry++;
+   current_entry->cxt = 0;
+
+   if (!skip) {
+      CLG_(current_state).nonskipped = 0;
+   } else if (!CLG_(current_state).nonskipped) {
+      /* a call from nonskipped to skipped */
+      CLG_(current_state).nonskipped = from;
+   }
+}
+
+
+/* Pop call stack and update inclusive sums.
+ * Returns modified fcc.
+ *
+ * If the JCC becomes inactive, call entries are freed if possible
+ */
+void CLG_(pop_call_stack)()
+{
+   jCC* jcc;
+   Int depth = 0;
+   call_entry* lower_entry;
+
+   if (CLG_(current_state).sig >0) {
+      /* Check if we leave a signal handler; this can happen when
+       * calling longjmp() in the handler */
+      CLG_(run_post_signal_on_call_stack_bottom)();
+   }
+
+   lower_entry = &(CLG_(current_call_stack).entry[CLG_(current_call_stack).sp-1]);
+
+   /* jCC item not any more on real stack: pop */
+   jcc = lower_entry->jcc;
+   CLG_(current_state).nonskipped = lower_entry->nonskipped;
+
+   if (jcc) {
+      fn_node* to_fn  = jcc->to->cxt->fn[0];
+      UInt* pdepth =  CLG_(get_fn_entry)(to_fn->number);
+      /* only decrement depth if another function was called */
+      if (jcc->from->cxt->fn[0] != to_fn) (*pdepth)--;
+      depth = *pdepth;
+
+      /* restore context */
+      CLG_(current_state).cxt  = lower_entry->cxt;
+      CLG_(current_fn_stack).top =
+            CLG_(current_fn_stack).bottom + lower_entry->fn_sp;
+      CLG_ASSERT(CLG_(current_state).cxt != 0);
+
+      if (depth == 0) function_left(to_fn);
+   }
+
+   /* To allow for an assertion in push_call_stack() */
+   lower_entry->cxt = 0;
+
+   CLG_(current_call_stack).sp--;
+}
+
+
+/* Unwind enough CallStack items to sync with current stack pointer.
+ * Returns the number of stack frames unwinded.
+ */
+Int CLG_(unwind_call_stack)(Addr sp, Int minpops)
+{
+   Int csp;
+   Int unwind_count = 0;
+
+   /* We pop old stack frames.
+    * For a call, be p the stack address with return address.
+    *  - call_stack_esp[] has SP after the CALL: p-4
+    *  - current sp is after a RET: >= p
+    */
+
+   while( (csp=CLG_(current_call_stack).sp) >0) {
+      call_entry* top_ce = &(CLG_(current_call_stack).entry[csp-1]);
+
+      if ((top_ce->sp < sp) || ((top_ce->sp == sp) && minpops>0)) {
+         minpops--;
+         unwind_count++;
+         CLG_(pop_call_stack)();
+         csp=CLG_(current_call_stack).sp;
+         continue;
+      }
+      break;
+   }
+
+   return unwind_count;
+}
diff --git a/exp-failgrind/clg_context.c b/exp-failgrind/clg_context.c
new file mode 100644
index 000000000..19018f0ff
--- /dev/null
+++ b/exp-failgrind/clg_context.c
@@ -0,0 +1,292 @@
+/*--------------------------------------------------------------------*/
+/*--- Callgrind                                                    ---*/
+/*---                                                 ct_context.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Callgrind, a Valgrind tool for call tracing.
+
+   Copyright (C) 2002-2017, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "clg_global.h"
+
+
+/*------------------------------------------------------------*/
+/*--- Context operations                                   ---*/
+/*------------------------------------------------------------*/
+
+#define N_FNSTACK_INITIAL_ENTRIES 500
+#define N_CXT_INITIAL_ENTRIES 2537
+
+fn_stack CLG_(current_fn_stack);
+
+void CLG_(init_fn_stack)(fn_stack* s)
+{
+   CLG_ASSERT(s != 0);
+
+   s->size   = N_FNSTACK_INITIAL_ENTRIES;
+   s->bottom = (fn_node**) CLG_MALLOC("cl.context.ifs.1",
+                                     s->size * sizeof(fn_node*));
+   s->top    = s->bottom;
+   s->bottom[0] = 0;
+}
+
+void CLG_(copy_current_fn_stack)(fn_stack* dst)
+{
+   CLG_ASSERT(dst != 0);
+
+   dst->size   = CLG_(current_fn_stack).size;
+   dst->bottom = CLG_(current_fn_stack).bottom;
+   dst->top    = CLG_(current_fn_stack).top;
+}
+
+void CLG_(set_current_fn_stack)(fn_stack* s)
+{
+   CLG_ASSERT(s != 0);
+
+   CLG_(current_fn_stack).size   = s->size;
+   CLG_(current_fn_stack).bottom = s->bottom;
+   CLG_(current_fn_stack).top    = s->top;
+}
+
+static cxt_hash cxts;
+
+void CLG_(init_cxt_table)()
+{
+   Int i;
+
+   cxts.size    = N_CXT_INITIAL_ENTRIES;
+   cxts.entries = 0;
+   cxts.table   = (Context**) CLG_MALLOC("cl.context.ict.1",
+                                         cxts.size * sizeof(Context*));
+
+   for (i = 0; i < cxts.size; i++) {
+      cxts.table[i] = 0;
+   }
+}
+
+/* double size of cxt table  */
+static void resize_cxt_table(void)
+{
+   UInt i, new_size, conflicts1 = 0, conflicts2 = 0;
+   Context **new_table, *curr, *next;
+   UInt new_idx;
+
+   new_size  = 2* cxts.size +3;
+   new_table = (Context**) CLG_MALLOC("cl.context.rct.1",
+                                      new_size * sizeof(Context*));
+
+   for (i = 0; i < new_size; i++) {
+      new_table[i] = NULL;
+   }
+
+   for (i = 0; i < cxts.size; i++) {
+      if (cxts.table[i] == NULL) continue;
+
+      curr = cxts.table[i];
+      while (NULL != curr) {
+         next = curr->next;
+
+         new_idx = (UInt) (curr->hash % new_size);
+
+         curr->next = new_table[new_idx];
+         new_table[new_idx] = curr;
+         if (curr->next) {
+            conflicts1++;
+            if (curr->next->next) {
+               conflicts2++;
+            }
+         }
+
+         curr = next;
+      }
+   }
+
+   VG_(free)(cxts.table);
+
+   cxts.size  = new_size;
+   cxts.table = new_table;
+}
+
+__inline__
+static UWord cxt_hash_val(fn_node** fn, UInt size)
+{
+   UWord hash = 0;
+   UInt count = size;
+   while(*fn != 0) {
+      hash = (hash<<7) + (hash>>25) + (UWord)(*fn);
+      fn--;
+      count--;
+      if (count==0) break;
+   }
+   return hash;
+}
+
+__inline__
+static Bool is_cxt(UWord hash, fn_node** fn, Context* cxt)
+{
+   Int count;
+   fn_node** cxt_fn;
+
+   if (hash != cxt->hash) return False;
+
+   count = cxt->size;
+   cxt_fn = &(cxt->fn[0]);
+   while((*fn != 0) && (count>0)) {
+      if (*cxt_fn != *fn) return False;
+      fn--;
+      cxt_fn++;
+      count--;
+   }
+   return True;
+}
+
+/**
+ * Allocate new Context structure
+ */
+static Context* new_cxt(fn_node** fn)
+{
+   Context* cxt;
+   UInt idx, offset;
+   UWord hash;
+   Int size;
+   fn_node* top_fn;
+
+   CLG_ASSERT(fn);
+   top_fn = *fn;
+   if (top_fn == 0) return 0;
+
+   /* check fill degree of context hash table and resize if needed (>80%) */
+   cxts.entries++;
+   if (10 * cxts.entries / cxts.size > 8) {
+      resize_cxt_table();
+   }
+
+   cxt = (Context*) CLG_MALLOC("cl.context.nc.1",
+                               sizeof(Context)+sizeof(fn_node*));
+
+   // hash value calculation similar to cxt_hash_val(), but additionally
+   // copying function pointers in one run
+   hash = 0;
+   offset = 0;
+   while(*fn != 0) {
+      hash = (hash<<7) + (hash>>25) + (UWord)(*fn);
+      cxt->fn[offset] = *fn;
+      offset++;
+      fn--;
+      if (offset >= 1) break;
+   }
+   if (offset < 1) size = offset;
+
+   cxt->size        = size;
+   cxt->hash        = hash;
+
+   /* insert into Context hash table */
+   idx = (UInt) (hash % cxts.size);
+   cxt->next = cxts.table[idx];
+   cxts.table[idx] = cxt;
+
+   return cxt;
+}
+
+
+/* get the Context structure for current context */
+Context* CLG_(get_cxt)(fn_node** fn)
+{
+   Context* cxt;
+   UInt idx;
+   UWord hash;
+
+   CLG_ASSERT(fn != 0);
+   if (*fn == 0) return 0;
+
+   hash = cxt_hash_val(fn, 1);
+
+   if (((cxt = (*fn)->last_cxt) != 0) && is_cxt(hash, fn, cxt)) {
+      return cxt;
+   }
+
+   idx = (UInt) (hash % cxts.size);
+   cxt = cxts.table[idx];
+
+   while (cxt) {
+      if (is_cxt(hash,fn,cxt)) break;
+      cxt = cxt->next;
+   }
+
+   if (!cxt) {
+      cxt = new_cxt(fn);
+   }
+
+   (*fn)->last_cxt = cxt;
+
+   return cxt;
+}
+
+
+/**
+ * Change execution context by calling a new function from current context
+ * Pushing 0x0 specifies a marker for a signal handler entry
+ */
+void CLG_(push_cxt)(fn_node* fn)
+{
+   call_stack* cs = &CLG_(current_call_stack);
+   Int fn_entries;
+
+   /* save old context on stack (even if not changed at all!) */
+   CLG_ASSERT(cs->sp < cs->size);
+   CLG_ASSERT(cs->entry[cs->sp].cxt == 0);
+   cs->entry[cs->sp].cxt = CLG_(current_state).cxt;
+   cs->entry[cs->sp].fn_sp = CLG_(current_fn_stack).top - CLG_(current_fn_stack).bottom;
+
+   if (fn && (*(CLG_(current_fn_stack).top) == fn)) return;
+
+   /* resizing needed ? */
+   fn_entries = CLG_(current_fn_stack).top - CLG_(current_fn_stack).bottom;
+   if (fn_entries == CLG_(current_fn_stack).size-1) {
+      UInt new_size = CLG_(current_fn_stack).size *2;
+      fn_node** new_array = (fn_node**) CLG_MALLOC("cl.context.pc.1",
+            new_size * sizeof(fn_node*));
+
+      Int i;
+      for(i=0; i<CLG_(current_fn_stack).size; i++) {
+         new_array[i] = CLG_(current_fn_stack).bottom[i];
+      }
+
+      VG_(free)(CLG_(current_fn_stack).bottom);
+      CLG_(current_fn_stack).top = new_array + fn_entries;
+      CLG_(current_fn_stack).bottom = new_array;
+
+      CLG_(current_fn_stack).size = new_size;
+   }
+
+   if (fn && (*(CLG_(current_fn_stack).top) == 0)) {
+      UInt *pactive;
+
+      /* this is first function: increment its active count */
+      pactive = CLG_(get_fn_entry)(fn->number);
+      (*pactive)++;
+   }
+
+   CLG_(current_fn_stack).top++;
+   *(CLG_(current_fn_stack).top) = fn;
+   CLG_(current_state).cxt = CLG_(get_cxt)(CLG_(current_fn_stack).top);
+}
diff --git a/exp-failgrind/clg_fn.c b/exp-failgrind/clg_fn.c
new file mode 100644
index 000000000..b5f64b721
--- /dev/null
+++ b/exp-failgrind/clg_fn.c
@@ -0,0 +1,634 @@
+/*--------------------------------------------------------------------*/
+/*--- Callgrind                                                    ---*/
+/*---                                                      ct_fn.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Callgrind, a Valgrind tool for call tracing.
+
+   Copyright (C) 2002-2017, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "clg_global.h"
+#include "fg_global.h"
+
+#define N_INITIAL_FN_ARRAY_SIZE 10071
+
+static fn_array current_fn_active;
+
+static Addr runtime_resolve_addr = 0;
+static int  runtime_resolve_length = 0;
+
+// a code pattern is a list of tuples (start offset, length)
+struct chunk_t { int start, len; };
+struct pattern
+{
+   const HChar* name;
+   int len;
+   struct chunk_t chunk[];
+};
+
+/* Scan for a pattern in the code of an ELF object.
+ * If found, return true and set runtime_resolve_{addr,length}
+ */
+__attribute__((unused))    // Possibly;  depends on the platform.
+static Bool check_code(obj_node* obj,
+                       UChar code[], struct pattern* pat)
+{
+   Bool found;
+   Addr addr, end;
+   int chunk, start, len;
+
+   /* first chunk of pattern should always start at offset 0 and
+    * have at least 3 bytes */
+   CLG_ASSERT((pat->chunk[0].start == 0) && (pat->chunk[0].len >2));
+
+   end = obj->start + obj->size - pat->len;
+   addr = obj->start;
+   while(addr < end) {
+      found = (VG_(memcmp)( (void*)addr, code, pat->chunk[0].len) == 0);
+
+      if (found) {
+         chunk = 1;
+         while(1) {
+            start = pat->chunk[chunk].start;
+            len   = pat->chunk[chunk].len;
+            if (len == 0) break;
+
+            CLG_ASSERT(len >2);
+
+            if (VG_(memcmp)( (void*)(addr+start), code+start, len) != 0) {
+               found = False;
+               break;
+            }
+            chunk++;
+         }
+
+         if (found) {
+            runtime_resolve_addr   = addr;
+            runtime_resolve_length = pat->len;
+            return True;
+         }
+      }
+      addr++;
+   }
+   return False;
+}
+
+
+/* _ld_runtime_resolve, located in ld.so, needs special handling:
+ * The jump at end into the resolved function should not be
+ * represented as a call (as usually done in callgrind with jumps),
+ * but as a return + call. Otherwise, the repeated existence of
+ * _ld_runtime_resolve in call chains will lead to huge cycles,
+ * making the profile almost worthless.
+ *
+ * If ld.so is stripped, the symbol will not appear. But as this
+ * function is handcrafted assembler, we search for it.
+ *
+ * We stop if the ELF object name does not seem to be the runtime linker
+ */
+static Bool search_runtime_resolve(obj_node* obj)
+{
+#if defined(VGP_x86_linux)
+   static UChar code[] = {
+      /* 0*/ 0x50, 0x51, 0x52, 0x8b, 0x54, 0x24, 0x10, 0x8b,
+      /* 8*/ 0x44, 0x24, 0x0c, 0xe8, 0x70, 0x01, 0x00, 0x00,
+      /*16*/ 0x5a, 0x59, 0x87, 0x04, 0x24, 0xc2, 0x08, 0x00 };
+      /* Check ranges [0-11] and [16-23] ([12-15] is an absolute address) */
+   static struct pattern pat = {
+      "x86-def", 24, {{ 0,12 }, { 16,8 }, { 24,0}} };
+
+   /* Pattern for glibc-2.8 on OpenSuse11.0 */
+   static UChar code_28[] = {
+      /* 0*/ 0x50, 0x51, 0x52, 0x8b, 0x54, 0x24, 0x10, 0x8b,
+      /* 8*/ 0x44, 0x24, 0x0c, 0xe8, 0x70, 0x01, 0x00, 0x00,
+      /*16*/ 0x5a, 0x8b, 0x0c, 0x24, 0x89, 0x04, 0x24, 0x8b,
+      /*24*/ 0x44, 0x24, 0x04, 0xc2, 0x0c, 0x00 };
+   static struct pattern pat_28 = {
+      "x86-glibc2.8", 30, {{ 0,12 }, { 16,14 }, { 30,0}} };
+
+   if (VG_(strncmp)(obj->name, "/lib/ld", 7) != 0) return False;
+   if (check_code(obj, code, &pat)) return True;
+   if (check_code(obj, code_28, &pat_28)) return True;
+   return False;
+#endif
+
+#if defined(VGP_ppc32_linux)
+   static UChar code[] = {
+      /* 0*/ 0x94, 0x21, 0xff, 0xc0, 0x90, 0x01, 0x00, 0x0c,
+      /* 8*/ 0x90, 0x61, 0x00, 0x10, 0x90, 0x81, 0x00, 0x14,
+      /*16*/ 0x7d, 0x83, 0x63, 0x78, 0x90, 0xa1, 0x00, 0x18,
+      /*24*/ 0x7d, 0x64, 0x5b, 0x78, 0x90, 0xc1, 0x00, 0x1c,
+      /*32*/ 0x7c, 0x08, 0x02, 0xa6, 0x90, 0xe1, 0x00, 0x20,
+      /*40*/ 0x90, 0x01, 0x00, 0x30, 0x91, 0x01, 0x00, 0x24,
+      /*48*/ 0x7c, 0x00, 0x00, 0x26, 0x91, 0x21, 0x00, 0x28,
+      /*56*/ 0x91, 0x41, 0x00, 0x2c, 0x90, 0x01, 0x00, 0x08,
+      /*64*/ 0x48, 0x00, 0x02, 0x91, 0x7c, 0x69, 0x03, 0xa6, /* at 64: bl aff0 <fixup> */
+      /*72*/ 0x80, 0x01, 0x00, 0x30, 0x81, 0x41, 0x00, 0x2c,
+      /*80*/ 0x81, 0x21, 0x00, 0x28, 0x7c, 0x08, 0x03, 0xa6,
+      /*88*/ 0x81, 0x01, 0x00, 0x24, 0x80, 0x01, 0x00, 0x08,
+      /*96*/ 0x80, 0xe1, 0x00, 0x20, 0x80, 0xc1, 0x00, 0x1c,
+      /*104*/0x7c, 0x0f, 0xf1, 0x20, 0x80, 0xa1, 0x00, 0x18,
+      /*112*/0x80, 0x81, 0x00, 0x14, 0x80, 0x61, 0x00, 0x10,
+      /*120*/0x80, 0x01, 0x00, 0x0c, 0x38, 0x21, 0x00, 0x40,
+      /*128*/0x4e, 0x80, 0x04, 0x20 };
+   static struct pattern pat = {
+      "ppc32-def", 132, {{ 0,65 }, { 68,64 }, { 132,0 }} };
+
+   if (VG_(strncmp)(obj->name, "/lib/ld", 7) != 0) return False;
+   return check_code(obj, code, &pat);
+#endif
+
+#if defined(VGP_amd64_linux)
+   static UChar code[] = {
+      /* 0*/ 0x48, 0x83, 0xec, 0x38, 0x48, 0x89, 0x04, 0x24,
+      /* 8*/ 0x48, 0x89, 0x4c, 0x24, 0x08, 0x48, 0x89, 0x54, 0x24, 0x10,
+      /*18*/ 0x48, 0x89, 0x74, 0x24, 0x18, 0x48, 0x89, 0x7c, 0x24, 0x20,
+      /*28*/ 0x4c, 0x89, 0x44, 0x24, 0x28, 0x4c, 0x89, 0x4c, 0x24, 0x30,
+      /*38*/ 0x48, 0x8b, 0x74, 0x24, 0x40, 0x49, 0x89, 0xf3,
+      /*46*/ 0x4c, 0x01, 0xde, 0x4c, 0x01, 0xde, 0x48, 0xc1, 0xe6, 0x03,
+      /*56*/ 0x48, 0x8b, 0x7c, 0x24, 0x38, 0xe8, 0xee, 0x01, 0x00, 0x00,
+      /*66*/ 0x49, 0x89, 0xc3, 0x4c, 0x8b, 0x4c, 0x24, 0x30,
+      /*74*/ 0x4c, 0x8b, 0x44, 0x24, 0x28, 0x48, 0x8b, 0x7c, 0x24, 0x20,
+      /*84*/ 0x48, 0x8b, 0x74, 0x24, 0x18, 0x48, 0x8b, 0x54, 0x24, 0x10,
+      /*94*/ 0x48, 0x8b, 0x4c, 0x24, 0x08, 0x48, 0x8b, 0x04, 0x24,
+      /*103*/0x48, 0x83, 0xc4, 0x48, 0x41, 0xff, 0xe3 };
+   static struct pattern pat = {
+      "amd64-def", 110, {{ 0,62 }, { 66,44 }, { 110,0 }} };
+
+   if ((VG_(strncmp)(obj->name, "/lib/ld", 7) != 0) &&
+         (VG_(strncmp)(obj->name, "/lib64/ld", 9) != 0)) {
+
+      return False;
+   }
+   return check_code(obj, code, &pat);
+#endif
+
+   /* For other platforms, no patterns known */
+   return False;
+}
+
+
+/*------------------------------------------------------------*/
+/*--- Object/File/Function hash entry operations           ---*/
+/*------------------------------------------------------------*/
+
+/* Object hash table, fixed */
+static obj_node* obj_table[N_OBJ_ENTRIES];
+
+void CLG_(init_obj_table)()
+{
+   Int i;
+   for (i = 0; i < N_OBJ_ENTRIES; i++) {
+      obj_table[i] = 0;
+   }
+}
+
+#define HASH_CONSTANT   256
+
+static UInt str_hash(const HChar *s, UInt table_size)
+{
+   int hash_value = 0;
+   for ( ; *s; s++) {
+      hash_value = (HASH_CONSTANT * hash_value + *s) % table_size;
+   }
+   return hash_value;
+}
+
+
+static const HChar* anonymous_obj = "???";
+
+static __inline__
+obj_node* new_obj_node(DebugInfo* di, obj_node* next)
+{
+   Int i;
+   obj_node* obj;
+
+   obj = (obj_node*) CLG_MALLOC("cl.fn.non.1", sizeof(obj_node));
+   obj->name  = di ? VG_(strdup)("cl.fn.non.2",
+         VG_(DebugInfo_get_filename)(di)) : anonymous_obj;
+
+   for (i = 0; i < N_FILE_ENTRIES; i++) {
+      obj->files[i] = NULL;
+   }
+   CLG_(stat).distinct_objs ++;
+   obj->number  = CLG_(stat).distinct_objs;
+   /* JRS 2008 Feb 19: maybe rename .start/.size/.offset to
+      .text_avma/.text_size/.test_bias to make it clearer what these
+      fields really mean */
+   obj->start   = di ? VG_(DebugInfo_get_text_avma)(di) : 0;
+   obj->size    = di ? VG_(DebugInfo_get_text_size)(di) : 0;
+   obj->offset  = di ? VG_(DebugInfo_get_text_bias)(di) : 0;
+   obj->next    = next;
+
+   // not only used for debug output (see static.c)
+   obj->last_slash_pos = 0;
+   i = 0;
+   while(obj->name[i]) {
+      if (obj->name[i]=='/') obj->last_slash_pos = i+1;
+      i++;
+   }
+
+   if (runtime_resolve_addr == 0) search_runtime_resolve(obj);
+
+   return obj;
+}
+
+obj_node* CLG_(get_obj_node)(DebugInfo* di)
+{
+   obj_node*    curr_obj_node;
+   UInt         objname_hash;
+   const HChar* obj_name;
+
+   obj_name = di ? VG_(DebugInfo_get_filename)(di) : anonymous_obj;
+
+   /* lookup in obj hash */
+   objname_hash = str_hash(obj_name, N_OBJ_ENTRIES);
+   curr_obj_node = obj_table[objname_hash];
+   while (NULL != curr_obj_node &&
+         VG_(strcmp)(obj_name, curr_obj_node->name) != 0) {
+
+      curr_obj_node = curr_obj_node->next;
+   }
+   if (NULL == curr_obj_node) {
+      obj_table[objname_hash] = curr_obj_node =
+            new_obj_node(di, obj_table[objname_hash]);
+    }
+
+    return curr_obj_node;
+}
+
+
+static __inline__
+file_node* new_file_node(const HChar *filename,
+      obj_node* obj, file_node* next)
+{
+   Int i;
+   file_node* file = (file_node*) CLG_MALLOC("cl.fn.nfn.1",
+                                             sizeof(file_node));
+   file->name  = VG_(strdup)("cl.fn.nfn.2", filename);
+   for (i = 0; i < N_FN_ENTRIES; i++) {
+      file->fns[i] = NULL;
+   }
+   CLG_(stat).distinct_files++;
+   file->number  = CLG_(stat).distinct_files;
+   file->obj     = obj;
+   file->next      = next;
+   return file;
+}
+
+
+file_node* CLG_(get_file_node)(obj_node* curr_obj_node,
+                               const HChar *dir, const HChar *file)
+{
+   file_node* curr_file_node;
+   UInt       filename_hash;
+
+   /* Build up an absolute pathname, if there is a directory available */
+   HChar filename[VG_(strlen)(dir) + 1 + VG_(strlen)(file) + 1];
+   VG_(strcpy)(filename, dir);
+   if (filename[0] != '\0') {
+      VG_(strcat)(filename, "/");
+   }
+   VG_(strcat)(filename, file);
+
+   /* lookup in file hash */
+   filename_hash = str_hash(filename, N_FILE_ENTRIES);
+   curr_file_node = curr_obj_node->files[filename_hash];
+   while (NULL != curr_file_node &&
+         VG_(strcmp)(filename, curr_file_node->name) != 0) {
+
+      curr_file_node = curr_file_node->next;
+   }
+   if (NULL == curr_file_node) {
+      curr_obj_node->files[filename_hash] = curr_file_node =
+            new_file_node(filename, curr_obj_node,
+
+      curr_obj_node->files[filename_hash]);
+   }
+
+   return curr_file_node;
+}
+
+/* forward decl. */
+static void resize_fn_array(void);
+
+static __inline__
+fn_node* new_fn_node(const HChar *fnname,
+      file_node* file, fn_node* next)
+{
+   fn_node* fn = (fn_node*) CLG_MALLOC("cl.fn.nfnnd.1",
+                                         sizeof(fn_node));
+   fn->name = VG_(strdup)("cl.fn.nfnnd.2", fnname);
+
+   CLG_(stat).distinct_fns++;
+   fn->number   = CLG_(stat).distinct_fns;
+   fn->last_cxt = 0;
+   fn->pure_cxt = 0;
+   fn->file     = file;
+   fn->next     = next;
+
+   fn->toggle_alloc_fail = False;
+
+   if (CLG_(stat).distinct_fns >= current_fn_active.size) {
+      resize_fn_array();
+   }
+
+   return fn;
+}
+
+
+/* Get a function node in hash2 with known file node.
+ * hash nodes are created if needed
+ */
+static
+fn_node* get_fn_node_infile(file_node* curr_file_node,
+      const HChar *fnname)
+{
+   fn_node* curr_fn_node;
+   UInt     fnname_hash;
+
+   CLG_ASSERT(curr_file_node != 0);
+
+   /* lookup in function hash */
+   fnname_hash = str_hash(fnname, N_FN_ENTRIES);
+   curr_fn_node = curr_file_node->fns[fnname_hash];
+   while (NULL != curr_fn_node &&
+         VG_(strcmp)(fnname, curr_fn_node->name) != 0) {
+
+      curr_fn_node = curr_fn_node->next;
+   }
+   if (NULL == curr_fn_node) {
+      curr_file_node->fns[fnname_hash] = curr_fn_node =
+            new_fn_node(fnname, curr_file_node,
+
+      curr_file_node->fns[fnname_hash]);
+   }
+
+   return curr_fn_node;
+}
+
+
+/* Get a function node in a Segment.
+ * Hash nodes are created if needed.
+ */
+static __inline__
+fn_node* get_fn_node_inseg(DebugInfo* di,
+      const HChar *dirname,
+      const HChar *filename,
+      const HChar *fnname)
+{
+   obj_node  *obj  = CLG_(get_obj_node)(di);
+   file_node *file = CLG_(get_file_node)(obj, dirname, filename);
+   fn_node   *fn   = get_fn_node_infile(file, fnname);
+
+   return fn;
+}
+
+
+Bool CLG_(get_debug_info)(Addr instr_addr,
+      const HChar **dir,
+      const HChar **file,
+      const HChar **fn_name, UInt* line_num,
+      DebugInfo** pDebugInfo)
+{
+   Bool found_file_line, found_fn, result = True;
+   UInt line;
+
+   CLG_DEBUG(6, "  + get_debug_info(%#lx)\n", instr_addr);
+
+   DiEpoch ep = VG_(current_DiEpoch)();
+   if (pDebugInfo) {
+      *pDebugInfo = VG_(find_DebugInfo)(ep, instr_addr);
+   }
+
+   found_file_line = VG_(get_filename_linenum)(ep, instr_addr,
+         file,
+         dir,
+         &line);
+   found_fn = VG_(get_fnname)(ep, instr_addr, fn_name);
+
+   if (!found_file_line && !found_fn) {
+      *file = "???";
+      *fn_name = "???";
+      if (line_num) *line_num=0;
+      result = False;
+
+   } else if ( found_file_line &&  found_fn) {
+      if (line_num) *line_num=line;
+
+   } else if ( found_file_line && !found_fn) {
+      *fn_name = "???";
+      if (line_num) *line_num=line;
+
+   } else  /*(!found_file_line &&  found_fn)*/ {
+      *file = "???";
+      if (line_num) *line_num=0;
+   }
+
+  return result;
+}
+
+/* for _libc_freeres_wrapper => _exit renaming */
+static BB* exit_bb = 0;
+
+
+/*
+ * Attach function struct to a BB from debug info.
+ */
+fn_node* CLG_(get_fn_node)(BB* bb)
+{
+   const HChar *fnname, *filename, *dirname;
+   DebugInfo* di;
+   UInt       line_num;
+   fn_node*   fn;
+
+   /* fn from debug info is idempotent for a BB */
+   if (bb->fn) return bb->fn;
+
+   CLG_DEBUG(3,"+ get_fn_node(BB %#lx)\n", bb_addr(bb));
+
+   /* get function/file name, line number and object of
+    * the BB according to debug information
+    */
+   CLG_(get_debug_info)(bb_addr(bb),
+                        &dirname, &filename, &fnname, &line_num, &di);
+
+   DiEpoch ep = VG_(current_DiEpoch)();
+   if (0 == VG_(strcmp)(fnname, "???")) {
+      int p;
+      static HChar buf[32];  // for sure large enough
+      /* Use address as found in library */
+      if (sizeof(Addr) == 4) {
+         p = VG_(sprintf)(buf, "%#08lx", (UWord)bb->offset);
+      } else {
+         // 64bit address
+         p = VG_(sprintf)(buf, "%#016lx", (UWord)bb->offset);
+      }
+
+      VG_(sprintf)(buf + p, "%s",
+            (bb->sect_kind == Vg_SectData) ? " [Data]" :
+            (bb->sect_kind == Vg_SectBSS)  ? " [BSS]"  :
+            (bb->sect_kind == Vg_SectGOT)  ? " [GOT]"  :
+            (bb->sect_kind == Vg_SectPLT)  ? " [PLT]"  : "");
+      fnname = buf;
+   } else {
+      if (VG_(get_fnname_if_entry)(ep, bb_addr(bb), &fnname)) {
+         bb->is_entry = 1;
+      }
+   }
+
+   /* HACK for correct _exit:
+    * _exit is redirected to VG_(__libc_freeres_wrapper) by valgrind,
+    * so we rename it back again :-)
+    */
+   if (0 == VG_(strcmp)(fnname, "vgPlain___libc_freeres_wrapper") && exit_bb) {
+      CLG_(get_debug_info)(bb_addr(exit_bb),
+            &dirname, &filename, &fnname, &line_num, &di);
+   }
+   if (0 == VG_(strcmp)(fnname, "_exit") && !exit_bb) {
+      exit_bb = bb;
+   }
+
+   if (runtime_resolve_addr &&
+         (bb_addr(bb) >= runtime_resolve_addr) &&
+         (bb_addr(bb) < runtime_resolve_addr + runtime_resolve_length)) {
+
+      /* BB in runtime_resolve found by code check; use this name */
+      fnname = "_dl_runtime_resolve";
+   }
+
+   /* get fn_node struct for this function */
+   fn = get_fn_node_inseg( di, dirname, filename, fnname);
+
+   /* if this is the 1st time the function is seen,
+    * some attributes are set */
+   if (fn->pure_cxt == 0) {
+
+      /* Every function gets a "pure" context, i.e. a context with stack
+       * depth 1 only with this function. This is for compression of mangled
+       * names
+       */
+      fn_node* pure[2];
+      pure[0] = 0;
+      pure[1] = fn;
+      fn->pure_cxt = CLG_(get_cxt)(pure+1);
+
+      if (FG_(alloc_toggle_funcs) != NULL && VG_(strIsMemberXA)(FG_(alloc_toggle_funcs), fnname)) {
+         fn->toggle_alloc_fail = True;
+      }
+      if (FG_(syscall_toggle_funcs) != NULL && VG_(strIsMemberXA)(FG_(syscall_toggle_funcs), fnname)) {
+         fn->toggle_syscall_fail = True;
+      }
+   }
+
+
+   bb->fn   = fn;
+   bb->line = line_num;
+
+   return fn;
+}
+
+
+/*------------------------------------------------------------*/
+/*--- Active function array operations                     ---*/
+/*------------------------------------------------------------*/
+
+/* The active function array is a thread-specific array
+ * of UInts, mapping function numbers to the active count of
+ * functions.
+ * The active count is the number of times a function appears
+ * in the current call stack, and is used when costs for recursion
+ * levels should be separated.
+ */
+
+UInt* CLG_(get_fn_entry)(Int n)
+{
+   CLG_ASSERT(n < current_fn_active.size);
+   return current_fn_active.array + n;
+}
+
+void CLG_(init_fn_array)(fn_array* a)
+{
+   Int i;
+
+   CLG_ASSERT(a != 0);
+
+   a->size = N_INITIAL_FN_ARRAY_SIZE;
+   if (a->size <= CLG_(stat).distinct_fns) {
+      a->size = CLG_(stat).distinct_fns+1;
+   }
+
+   a->array = (UInt*) CLG_MALLOC("cl.fn.gfe.1",
+                                a->size * sizeof(UInt));
+   for(i=0;i<a->size;i++) {
+      a->array[i] = 0;
+   }
+}
+
+void CLG_(copy_current_fn_array)(fn_array* dst)
+{
+   CLG_ASSERT(dst != 0);
+
+   dst->size  = current_fn_active.size;
+   dst->array = current_fn_active.array;
+}
+
+fn_array* CLG_(get_current_fn_array)()
+{
+   return &current_fn_active;
+}
+
+void CLG_(set_current_fn_array)(fn_array* a)
+{
+   CLG_ASSERT(a != 0);
+
+   current_fn_active.size  = a->size;
+   current_fn_active.array = a->array;
+   if (current_fn_active.size <= CLG_(stat).distinct_fns) {
+      resize_fn_array();
+   }
+}
+
+/* ensure that active_array is big enough:
+ *  <distinct_fns> is the highest index, so <fn_active_array_size>
+ *  has to be bigger than that.
+ */
+static void resize_fn_array(void)
+{
+   UInt* new_array;
+   Int i;
+
+   UInt newsize = current_fn_active.size;
+   while (newsize <= CLG_(stat).distinct_fns) newsize *=2;
+
+   new_array = (UInt*) CLG_MALLOC("cl.fn.rfa.1", newsize * sizeof(UInt));
+   for (i=0; i<current_fn_active.size; i++) {
+      new_array[i] = current_fn_active.array[i];
+   }
+   while(i<newsize) {
+      new_array[i++] = 0;
+   }
+
+   VG_(free)(current_fn_active.array);
+   current_fn_active.size = newsize;
+   current_fn_active.array = new_array;
+}
diff --git a/exp-failgrind/clg_global.h b/exp-failgrind/clg_global.h
new file mode 100644
index 000000000..871648b89
--- /dev/null
+++ b/exp-failgrind/clg_global.h
@@ -0,0 +1,578 @@
+/*--------------------------------------------------------------------*/
+/*--- Callgrind data structures, functions.               global.h ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2004-2017 Josef Weidendorfer
+      josef.weidendorfer@gmx.de
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#ifndef CLG_GLOBAL
+#define CLG_GLOBAL
+
+#include "pub_tool_basics.h"
+#include "pub_tool_vki.h"
+#include "pub_tool_debuginfo.h"
+#include "pub_tool_debuginfo.h"
+#include "pub_tool_libcbase.h"
+#include "pub_tool_libcassert.h"
+#include "pub_tool_libcfile.h"
+#include "pub_tool_libcprint.h"
+#include "pub_tool_libcproc.h"
+#include "pub_tool_machine.h"
+#include "pub_tool_mallocfree.h"
+#include "pub_tool_options.h"
+#include "pub_tool_tooliface.h"
+#include "pub_tool_xarray.h"
+#include "pub_tool_clientstate.h"
+#include "pub_tool_machine.h"      // VG_(fnptr_to_fnentry)
+
+#define CLG_(str) VGAPPEND(vgCallgrind_,str)
+
+
+/*------------------------------------------------------------*/
+/*--- Statistics                                           ---*/
+/*------------------------------------------------------------*/
+
+typedef struct _Statistics Statistics;
+struct _Statistics {
+   Int  distinct_objs;
+   Int  distinct_files;
+   Int  distinct_fns;
+};
+
+
+/*------------------------------------------------------------*/
+/*--- Structure declarations                               ---*/
+/*------------------------------------------------------------*/
+
+typedef struct _Context     Context;
+typedef struct _CC          CC;
+typedef struct _BB          BB;
+typedef struct _BBCC        BBCC;
+typedef struct _jCC         jCC;
+typedef struct _fn_node     fn_node;
+typedef struct _file_node   file_node;
+typedef struct _obj_node    obj_node;
+typedef struct _fn_config   fn_config;
+typedef struct _call_entry  call_entry;
+typedef struct _thread_info thread_info;
+
+/* The types of control flow changes that can happen between
+ * execution of two BBs in a thread.
+ */
+typedef enum {
+   jk_None = 0,   /* no explicit change by a guest instruction */
+   jk_Jump,       /* regular jump */
+   jk_Call,
+   jk_Return,
+   jk_CondJump    /* conditional jump taken (only used as jCC type) */
+} ClgJumpKind;
+
+
+/* JmpCall cost center
+ * for subroutine call (from->bb->jmp_addr => to->bb->addr)
+ *
+ * Each BB has at most one CALL instruction. The list of JCC from
+ * this call is a pointer to the list head (stored in BBCC), and
+ * <next_from> in the JCC struct.
+ *
+ * For fast lookup, JCCs are reachable with a hash table, keyed by
+ * the (from_bbcc,to) pair. <next_hash> is used for the JCC chain
+ * of one hash table entry.
+ */
+
+struct _jCC {
+   ClgJumpKind jmpkind; /* jk_Call, jk_Jump, jk_CondJump */
+   jCC* next_hash;   /* for hash entry chain */
+   jCC* next_from;   /* next JCC from a BBCC */
+   BBCC *from, *to;  /* call arc from/to this BBCC */
+   UInt jmp;         /* jump no. in source */
+};
+
+
+/*
+ * Info for one instruction of a basic block.
+ */
+typedef struct _InstrInfo InstrInfo;
+struct _InstrInfo {
+   UInt instr_offset;
+   UInt instr_size;
+   UInt cost_offset;
+};
+
+
+
+/*
+ * Info for a side exit in a BB
+ */
+typedef struct _CJmpInfo CJmpInfo;
+struct _CJmpInfo {
+   UInt instr;          /* instruction index for BB.instr array */
+   ClgJumpKind jmpkind; /* jump kind when leaving BB at this side exit */
+};
+
+
+/**
+ * An instrumented basic block (BB).
+ *
+ * BBs are put into a resizable hash to allow for fast detection if a
+ * BB is to be retranslated but cost info is already available.
+ * The key for a BB is a (object, offset) tupel making it independent
+ * from possibly multiple mappings of the same ELF object.
+ *
+ * At the beginning of each instrumented BB,
+ * a call to setup_bbcc(), specifying a pointer to the
+ * according BB structure, is added.
+ *
+ * As cost of a BB has to be distinguished depending on the context,
+ * multiple cost centers for one BB (struct BBCC) exist and the according
+ * BBCC is set by setup_bbcc.
+ */
+struct _BB {
+   obj_node*  obj;         /* ELF object of BB */
+   PtrdiffT   offset;      /* offset of BB in ELF object file */
+   BB*        next;       /* chaining for a hash entry */
+
+   VgSectKind sect_kind;  /* section of this BB, e.g. PLT */
+   UInt       instr_count;
+
+   /* filled by CLG_(get_fn_node) if debug info is available */
+   fn_node*   fn;          /* debug info for this BB */
+   UInt       line;
+   Bool       is_entry;    /* True if this BB is a function entry */
+
+   BBCC*      bbcc_list;  /* BBCCs for same BB (see next_bbcc in BBCC) */
+   BBCC*      last_bbcc;  /* Temporary: Cached for faster access (LRU) */
+
+   /* filled by CLG_(instrument) if not seen before */
+   UInt       cjmp_count;  /* number of side exits */
+   CJmpInfo*  jmp;         /* array of info for condition jumps,
+                            * allocated directly after this struct */
+   Bool       cjmp_inverted; /* is last side exit actually fall through? */
+
+   UInt       instr_len;
+   InstrInfo  instr[0];   /* info on instruction sizes and costs */
+};
+
+
+
+/**
+ * Function context
+ *
+ * Basic blocks are always executed in the scope of a context.
+ * A function context is a list of function nodes representing
+ * the call chain to the current context: I.e. fn[0] is the
+ * function we are currently in, fn[1] has called fn[0], and so on.
+ * Recursion levels are used for fn[0].
+ *
+ * To get a unique number for a full execution context, use
+ *  rec_index = min(<fn->rec_separation>,<active>) - 1;
+ *  unique_no = <number> + rec_index
+ *
+ * For each Context, recursion index and BB, there can be a BBCC.
+ */
+struct _Context {
+   UInt size;        // number of function dependencies
+   UInt base_number; // for context compression & dump array
+   Context* next;    // entry chaining for hash
+   UWord hash;       // for faster lookup...
+   fn_node* fn[0];
+};
+
+
+/*
+ * Cost info for a side exits from a BB
+ */
+typedef struct _JmpData JmpData;
+struct _JmpData {
+   jCC*  jcc_list; /* JCCs used for this exit */
+};
+
+
+/*
+ * Basic Block Cost Center
+ *
+ * On demand, multiple BBCCs will be created for the same BB
+ * dependent on command line options and:
+ * - current function (it's possible that a BB is executed in the
+ *   context of different functions, e.g. in manual assembler/PLT)
+ * - current thread ID
+ * - position where current function is called from
+ * - recursion level of current function
+ *
+ * The cost centres for the instructions of a basic block are
+ * stored in a contiguous array.
+ * They are distinguishable by their tag field.
+ */
+struct _BBCC {
+   BB*      bb;           /* BB for this cost center */
+
+   Context* cxt;          /* execution context of this BBCC */
+   ThreadId tid;          /* only for assertion check purpose */
+
+   BBCC*    next_bbcc;    /* Chain of BBCCs for same BB */
+   BBCC*    lru_next_bbcc; /* BBCC executed next the last time */
+
+   jCC*     lru_from_jcc; /* Temporary: Cached for faster access (LRU) */
+   jCC*     lru_to_jcc;   /* Temporary: Cached for faster access (LRU) */
+
+   BBCC*    next;         /* entry chain in hash */
+   JmpData  jmp[0];
+};
+
+
+/* the <number> of fn_node, file_node and obj_node are for compressed dumping
+ * and a index into the dump boolean table and fn_info_table
+ */
+
+struct _fn_node {
+   HChar*     name;
+   UInt       number;
+   Context*   last_cxt; /* LRU info */
+   Context*   pure_cxt; /* the context with only the function itself */
+   file_node* file;     /* reverse mapping for 2nd hash */
+   fn_node* next;
+
+   Bool toggle_alloc_fail :1;
+   Bool toggle_syscall_fail :1;
+};
+
+/* Quite arbitrary fixed hash sizes */
+
+#define   N_OBJ_ENTRIES         47
+#define  N_FILE_ENTRIES         53
+#define    N_FN_ENTRIES         87
+
+struct _file_node {
+   HChar*     name;
+   fn_node*   fns[N_FN_ENTRIES];
+   UInt       number;
+   obj_node*  obj;
+   file_node* next;
+};
+
+/* If an object is dlopened multiple times, we hope that <name> is unique;
+ * <start> and <offset> can change with each dlopen, and <start> is
+ * zero when object is unmapped (possible at dump time).
+ */
+struct _obj_node {
+   const HChar* name;
+   UInt       last_slash_pos;
+
+   Addr       start;  /* Start address of text segment mapping */
+   SizeT      size;   /* Length of mapping */
+   PtrdiffT   offset; /* Offset between symbol address and file offset */
+
+   file_node* files[N_FILE_ENTRIES];
+   UInt       number;
+   obj_node*  next;
+};
+
+/* an entry in the callstack
+ *
+ * <nonskipped> is 0 if the function called is not skipped (usual case).
+ * Otherwise, it is the last non-skipped BBCC. This one gets all
+ * the calls to non-skipped functions and all costs in skipped
+ * instructions.
+ */
+struct _call_entry {
+   jCC* jcc;           /* jCC for this call */
+   Addr sp;            /* stack pointer directly after call */
+   Addr ret_addr;      /* address to which to return to
+                        * is 0 on a simulated call */
+   BBCC* nonskipped;   /* see above */
+   Context* cxt;       /* context before call */
+   Int fn_sp;          /* function stack index before call */
+};
+
+
+/*
+ * Execution state of main thread or a running signal handler in
+ * a thread while interrupted by another signal handler.
+ * As there's no scheduling among running signal handlers of one thread,
+ * we only need a subset of a full thread state:
+ * - event counter
+ * - collect state
+ * - last BB, last jump kind, last nonskipped BB
+ * - callstack pointer for sanity checking and correct unwinding
+ *   after exit
+ */
+typedef struct _exec_state exec_state;
+struct _exec_state {
+
+   /* the signum of the handler, 0 for main thread context
+    */
+   Int sig;
+
+   /* the old call stack pointer at entering the signal handler */
+   Int orig_sp;
+
+   Context* cxt;
+
+   /* number of conditional jumps passed in last BB */
+   Int   jmps_passed;
+   BBCC* bbcc;      /* last BB executed */
+   BBCC* nonskipped;
+
+   Int call_stack_bottom; /* Index into fn_stack */
+};
+
+/* Global state structures */
+typedef struct _bb_hash bb_hash;
+struct _bb_hash {
+   UInt size, entries;
+   BB** table;
+};
+
+typedef struct _cxt_hash cxt_hash;
+struct _cxt_hash {
+   UInt size, entries;
+   Context** table;
+};
+
+/* Thread specific state structures, i.e. parts of a thread state.
+ * There are variables for the current state of each part,
+ * on which a thread state is copied at thread switch.
+ */
+typedef struct _bbcc_hash bbcc_hash;
+struct _bbcc_hash {
+   UInt size, entries;
+   BBCC** table;
+};
+
+typedef struct _jcc_hash jcc_hash;
+struct _jcc_hash {
+   UInt size, entries;
+   jCC** table;
+   jCC* spontaneous;
+};
+
+typedef struct _fn_array fn_array;
+struct _fn_array {
+   UInt size;
+   UInt* array;
+};
+
+typedef struct _call_stack call_stack;
+struct _call_stack {
+   UInt size;
+   Int sp;
+   call_entry* entry;
+};
+
+typedef struct _fn_stack fn_stack;
+struct _fn_stack {
+   UInt size;
+   fn_node **bottom, **top;
+};
+
+/* The maximum number of simultaneous running signal handlers per thread.
+ * This is the number of execution states storable in a thread.
+ */
+#define MAX_SIGHANDLERS 10
+
+typedef struct _exec_stack exec_stack;
+struct _exec_stack {
+   Int sp; /* > 0 if a handler is running */
+   exec_state* entry[MAX_SIGHANDLERS];
+};
+
+/* Thread State
+ *
+ * This structure stores thread specific info while a thread is *not*
+ * running. See function switch_thread() for save/restore on thread switch.
+ *
+ * If --separate-threads=no, BBCCs and JCCs can be shared by all threads, i.e.
+ * only structures of thread 1 are used.
+ * This involves variables fn_info_table, bbcc_table and jcc_table.
+ */
+struct _thread_info {
+   /* state */
+   fn_stack fns;       /* function stack */
+   call_stack calls;   /* context call arc stack */
+   exec_stack states;  /* execution states interrupted by signals */
+
+   /* thread specific data structure containers */
+   fn_array fn_active;
+   jcc_hash jccs;
+   bbcc_hash bbccs;
+};
+
+/*------------------------------------------------------------*/
+/*--- Functions                                            ---*/
+/*------------------------------------------------------------*/
+
+/* from clo.c */
+
+void CLG_(set_clo_defaults)(void);
+void CLG_(update_fn_config)(fn_node*);
+Bool CLG_(process_cmd_line_option)(const HChar*);
+
+/* from main.c */
+IRSB* CLG_(instrument)( VgCallbackClosure* closure,
+                        IRSB* sbIn,
+                        const VexGuestLayout* layout,
+                        const VexGuestExtents* vge,
+                        const VexArchInfo* archinfo_host,
+                        IRType gWordTy, IRType hWordTy );
+Bool CLG_(get_debug_info)(Addr, const HChar **dirname,
+                          const HChar **filename,
+                          const HChar **fn_name, UInt*, DebugInfo**);
+void CLG_(collectBlockInfo)(IRSB* bbIn, UInt*, UInt*, Bool*);
+void CLG_(set_instrument_state)(const HChar*,Bool);
+void CLG_(dump_profile)(const HChar* trigger,Bool only_current_thread);
+void CLG_(zero_all_cost)(Bool only_current_thread);
+Int CLG_(get_dump_counter)(void);
+void CLG_(fini)(Int exitcode);
+void CLG_(post_clo_init)(void);
+
+/* from bb.c */
+void CLG_(init_bb_hash)(void);
+bb_hash* CLG_(get_bb_hash)(void);
+BB*  CLG_(get_bb)(Addr addr, IRSB* bb_in, Bool *seen_before);
+void CLG_(delete_bb)(Addr addr);
+
+static __inline__ Addr bb_addr(BB* bb)
+ { return bb->offset + bb->obj->offset; }
+static __inline__ Addr bb_jmpaddr(BB* bb)
+ { UInt off = (bb->instr_count > 0) ? bb->instr[bb->instr_count-1].instr_offset : 0;
+   return off + bb->offset + bb->obj->offset; }
+
+/* from fn.c */
+void CLG_(init_fn_array)(fn_array*);
+void CLG_(copy_current_fn_array)(fn_array* dst);
+fn_array* CLG_(get_current_fn_array)(void);
+void CLG_(set_current_fn_array)(fn_array*);
+UInt* CLG_(get_fn_entry)(Int n);
+
+void      CLG_(init_obj_table)(void);
+obj_node* CLG_(get_obj_node)(DebugInfo* si);
+file_node* CLG_(get_file_node)(obj_node*, const HChar *dirname,
+                               const HChar* filename);
+fn_node*  CLG_(get_fn_node)(BB* bb);
+
+/* from bbcc.c */
+void CLG_(init_bbcc_hash)(bbcc_hash* bbccs);
+void CLG_(copy_current_bbcc_hash)(bbcc_hash* dst);
+bbcc_hash* CLG_(get_current_bbcc_hash)(void);
+void CLG_(set_current_bbcc_hash)(bbcc_hash*);
+BBCC* CLG_(get_bbcc)(BB* bb);
+BBCC* CLG_(clone_bbcc)(BBCC* orig, Context* cxt, Int rec_index);
+void CLG_(setup_bbcc)(BB* bb) VG_REGPARM(1);
+
+
+/* from jumps.c */
+void CLG_(init_jcc_hash)(jcc_hash*);
+void CLG_(copy_current_jcc_hash)(jcc_hash* dst);
+void CLG_(set_current_jcc_hash)(jcc_hash*);
+jCC* CLG_(get_jcc)(BBCC* from, UInt, BBCC* to);
+
+/* from callstack.c */
+void CLG_(init_call_stack)(call_stack*);
+void CLG_(copy_current_call_stack)(call_stack* dst);
+void CLG_(set_current_call_stack)(call_stack*);
+call_entry* CLG_(get_call_entry)(Int n);
+
+void CLG_(push_call_stack)(BBCC* from, UInt jmp, BBCC* to, Addr sp, Bool skip);
+void CLG_(pop_call_stack)(void);
+Int CLG_(unwind_call_stack)(Addr sp, Int);
+
+/* from context.c */
+void CLG_(init_fn_stack)(fn_stack*);
+void CLG_(copy_current_fn_stack)(fn_stack*);
+void CLG_(set_current_fn_stack)(fn_stack*);
+
+void CLG_(init_cxt_table)(void);
+Context* CLG_(get_cxt)(fn_node** fn);
+void CLG_(push_cxt)(fn_node* fn);
+
+/* from threads.c */
+void CLG_(init_threads)(void);
+thread_info** CLG_(get_threads)(void);
+thread_info* CLG_(get_current_thread)(void);
+void CLG_(switch_thread)(ThreadId tid);
+void CLG_(forall_threads)(void (*func)(thread_info*));
+void CLG_(run_thread)(ThreadId tid);
+
+void CLG_(init_exec_state)(exec_state* es);
+void CLG_(init_exec_stack)(exec_stack*);
+void CLG_(copy_current_exec_stack)(exec_stack*);
+void CLG_(set_current_exec_stack)(exec_stack*);
+void CLG_(pre_signal)(ThreadId tid, Int sigNum, Bool alt_stack);
+void CLG_(post_signal)(ThreadId tid, Int sigNum);
+void CLG_(run_post_signal_on_call_stack_bottom)(void);
+
+/*------------------------------------------------------------*/
+/*--- Exported global variables                            ---*/
+/*------------------------------------------------------------*/
+
+extern Statistics CLG_(stat);
+
+/* Function active counter array, indexed by function number */
+extern UInt* CLG_(fn_active_array);
+extern Bool CLG_(instrument_state);
+ /* min of L1 and LL cache line sizes */
+extern Int CLG_(min_line_size);
+extern call_stack CLG_(current_call_stack);
+extern fn_stack   CLG_(current_fn_stack);
+extern exec_state CLG_(current_state);
+extern ThreadId   CLG_(current_tid);
+
+/*------------------------------------------------------------*/
+/*--- Debug output                                         ---*/
+/*------------------------------------------------------------*/
+
+#if CLG_ENABLE_DEBUG
+
+#define CLG_DEBUGIF(x) \
+  if (UNLIKELY( (CLG_(clo).verbose >x) && \
+                (CLG_(stat).bb_executions >= CLG_(clo).verbose_start)))
+
+#define CLG_DEBUG(x,format,args...)   \
+    CLG_DEBUGIF(x) {                  \
+      VG_(printf)(format,##args);     \
+    }
+
+#define CLG_ASSERT(cond)              \
+    if (UNLIKELY(!(cond))) {          \
+      tl_assert(cond);                \
+     }
+
+#else
+#define CLG_DEBUGIF(x) if (0)
+#define CLG_DEBUG(x...) {}
+#define CLG_ASSERT(cond) tl_assert(cond);
+#endif
+
+void* CLG_(malloc)(const HChar* cc, UWord s, const HChar* f);
+void* CLG_(free)(void* p, const HChar* f);
+#if 0
+#define CLG_MALLOC(_cc,x) CLG_(malloc)((_cc),x,__FUNCTION__)
+#define CLG_FREE(p)       CLG_(free)(p,__FUNCTION__)
+#else
+#define CLG_MALLOC(_cc,x) VG_(malloc)((_cc),x)
+#define CLG_FREE(p)       VG_(free)(p)
+#endif
+
+#endif /* CLG_GLOBAL */
diff --git a/exp-failgrind/clg_jumps.c b/exp-failgrind/clg_jumps.c
new file mode 100644
index 000000000..ab57070d4
--- /dev/null
+++ b/exp-failgrind/clg_jumps.c
@@ -0,0 +1,214 @@
+/*--------------------------------------------------------------------*/
+/*--- Callgrind                                                    ---*/
+/*---                                                   ct_jumps.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Callgrind, a Valgrind tool for call tracing.
+
+   Copyright (C) 2002-2017, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "clg_global.h"
+
+/*------------------------------------------------------------*/
+/*--- Jump Cost Center (JCC) operations, including Calls   ---*/
+/*------------------------------------------------------------*/
+
+#define N_JCC_INITIAL_ENTRIES  4437
+
+static jcc_hash current_jccs;
+
+void CLG_(init_jcc_hash)(jcc_hash* jccs)
+{
+   Int i;
+
+   CLG_ASSERT(jccs != 0);
+
+   jccs->size    = N_JCC_INITIAL_ENTRIES;
+   jccs->entries = 0;
+   jccs->table = (jCC**) CLG_MALLOC("cl.jumps.ijh.1",
+                                    jccs->size * sizeof(jCC*));
+   jccs->spontaneous = 0;
+
+   for (i = 0; i < jccs->size; i++) {
+      jccs->table[i] = 0;
+   }
+}
+
+
+void CLG_(copy_current_jcc_hash)(jcc_hash* dst)
+{
+   CLG_ASSERT(dst != 0);
+
+   dst->size        = current_jccs.size;
+   dst->entries     = current_jccs.entries;
+   dst->table       = current_jccs.table;
+   dst->spontaneous = current_jccs.spontaneous;
+}
+
+void CLG_(set_current_jcc_hash)(jcc_hash* h)
+{
+   CLG_ASSERT(h != 0);
+
+   current_jccs.size        = h->size;
+   current_jccs.entries     = h->entries;
+   current_jccs.table       = h->table;
+   current_jccs.spontaneous = h->spontaneous;
+}
+
+__inline__
+static UInt jcc_hash_idx(BBCC* from, UInt jmp, BBCC* to, UInt size)
+{
+   return (UInt) ( (UWord)from + 7* (UWord)to + 13*jmp) % size;
+}
+
+/* double size of jcc table  */
+static void resize_jcc_table(void)
+{
+   Int i, new_size, conflicts1 = 0, conflicts2 = 0;
+   jCC** new_table;
+   UInt new_idx;
+   jCC *curr_jcc, *next_jcc;
+
+   new_size  = 2* current_jccs.size +3;
+   new_table = (jCC**) CLG_MALLOC("cl.jumps.rjt.1",
+                                  new_size * sizeof(jCC*));
+
+   for (i = 0; i < new_size; i++) {
+      new_table[i] = NULL;
+   }
+
+   for (i = 0; i < current_jccs.size; i++) {
+      if (current_jccs.table[i] == NULL) continue;
+
+      curr_jcc = current_jccs.table[i];
+      while (NULL != curr_jcc) {
+         next_jcc = curr_jcc->next_hash;
+
+         new_idx = jcc_hash_idx(curr_jcc->from, curr_jcc->jmp,
+               curr_jcc->to, new_size);
+
+         curr_jcc->next_hash = new_table[new_idx];
+         new_table[new_idx] = curr_jcc;
+         if (curr_jcc->next_hash) {
+            conflicts1++;
+            if (curr_jcc->next_hash->next_hash) {
+               conflicts2++;
+            }
+         }
+
+         curr_jcc = next_jcc;
+      }
+   }
+
+   VG_(free)(current_jccs.table);
+
+   current_jccs.size  = new_size;
+   current_jccs.table = new_table;
+}
+
+
+
+/* new jCC structure: a call was done to a BB of a BBCC
+ * for a spontaneous call, from is 0 (i.e. caller unknown)
+ */
+static jCC* new_jcc(BBCC* from, UInt jmp, BBCC* to)
+{
+   jCC* jcc;
+   UInt new_idx;
+
+   /* check fill degree of jcc hash table and resize if needed (>80%) */
+   current_jccs.entries++;
+   if (10 * current_jccs.entries / current_jccs.size > 8) {
+      resize_jcc_table();
+   }
+
+   jcc = (jCC*) CLG_MALLOC("cl.jumps.nj.1", sizeof(jCC));
+
+   jcc->from      = from;
+   jcc->jmp       = jmp;
+   jcc->to        = to;
+   jcc->jmpkind   = jk_Call;
+
+   /* insert into JCC chain of calling BBCC.
+    * This list is only used at dumping time */
+
+   if (from) {
+      /* Prohibit corruption by array overrun */
+      CLG_ASSERT((0 <= jmp) && (jmp <= from->bb->cjmp_count));
+      jcc->next_from = from->jmp[jmp].jcc_list;
+      from->jmp[jmp].jcc_list = jcc;
+   } else {
+      jcc->next_from = current_jccs.spontaneous;
+      current_jccs.spontaneous = jcc;
+   }
+
+   /* insert into JCC hash table */
+   new_idx = jcc_hash_idx(from, jmp, to, current_jccs.size);
+   jcc->next_hash = current_jccs.table[new_idx];
+   current_jccs.table[new_idx] = jcc;
+
+   return jcc;
+}
+
+
+/* get the jCC for a call arc (BBCC->BBCC) */
+jCC* CLG_(get_jcc)(BBCC* from, UInt jmp, BBCC* to)
+{
+   jCC* jcc;
+   UInt idx;
+
+   /* first check last recently used JCC */
+   jcc = to->lru_to_jcc;
+   if (jcc && (jcc->from == from) && (jcc->jmp == jmp)) {
+      CLG_ASSERT(to == jcc->to);
+      return jcc;
+   }
+
+   jcc = from->lru_from_jcc;
+   if (jcc && (jcc->to == to) && (jcc->jmp == jmp)) {
+      CLG_ASSERT(from == jcc->from);
+      return jcc;
+   }
+
+   idx = jcc_hash_idx(from, jmp, to, current_jccs.size);
+   jcc = current_jccs.table[idx];
+
+   while(jcc) {
+      if ((jcc->from == from) &&
+            (jcc->jmp == jmp) &&
+            (jcc->to == to)) {
+
+         break;
+      }
+      jcc = jcc->next_hash;
+   }
+
+   if (!jcc) {
+      jcc = new_jcc(from, jmp, to);
+   }
+
+   /* set LRU */
+   from->lru_from_jcc = jcc;
+   to->lru_to_jcc = jcc;
+
+   return jcc;
+}
diff --git a/exp-failgrind/clg_main.c b/exp-failgrind/clg_main.c
new file mode 100644
index 000000000..6ac899c26
--- /dev/null
+++ b/exp-failgrind/clg_main.c
@@ -0,0 +1,586 @@
+
+/*--------------------------------------------------------------------*/
+/*--- Callgrind                                                    ---*/
+/*---                                                       main.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Callgrind, a Valgrind tool for call graph
+   profiling programs.
+
+   Copyright (C) 2002-2017, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
+
+   This tool is derived from and contains code from Cachegrind
+   Copyright (C) 2002-2017 Nicholas Nethercote (njn@valgrind.org)
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "config.h"
+#include "clg_global.h"
+
+#include "pub_tool_threadstate.h"
+#include "pub_tool_gdbserver.h"
+#include "pub_tool_transtab.h"       // VG_(discard_translations_safely)
+
+/*------------------------------------------------------------*/
+/*--- Global variables                                     ---*/
+/*------------------------------------------------------------*/
+
+/* for all threads */
+Statistics CLG_(stat);
+
+/* thread and signal handler specific */
+exec_state CLG_(current_state);
+
+/*------------------------------------------------------------*/
+/*--- Statistics                                           ---*/
+/*------------------------------------------------------------*/
+
+static void CLG_(init_statistics)(Statistics* s)
+{
+   s->distinct_objs       = 0;
+   s->distinct_files      = 0;
+   s->distinct_fns        = 0;
+}
+
+
+/*------------------------------------------------------------*/
+/*--- Instrumentation structures and event queue handling  ---*/
+/*------------------------------------------------------------*/
+
+/* A struct which holds all the running state during instrumentation.
+   Mostly to avoid passing loads of parameters everywhere. */
+typedef struct {
+   /* The array of InstrInfo's is part of BB struct. */
+   BB* bb;
+
+   /* BB seen before (ie. re-instrumentation) */
+   Bool seen_before;
+
+   /* Number InstrInfo bins 'used' so far. */
+   UInt ii_index;
+
+   // current offset of guest instructions from BB start
+   UInt instr_offset;
+
+   /* The output SB being constructed. */
+   IRSB* sbOut;
+} ClgState;
+
+
+/* Initialise or check (if already seen before) an InstrInfo for next insn.
+   We only can set instr_offset/instr_size here. The required event set and
+   resulting cost offset depend on events (Ir/Dr/Dw/Dm) in guest
+   instructions. The event set is extended as required on flush of the event
+   queue (when Dm events were determined), cost offsets are determined at
+   end of BB instrumentation. */
+static
+InstrInfo* next_InstrInfo ( ClgState* clgs, UInt instr_size )
+{
+   InstrInfo* ii;
+   tl_assert(clgs->ii_index >= 0);
+   tl_assert(clgs->ii_index < clgs->bb->instr_count);
+   ii = &clgs->bb->instr[ clgs->ii_index ];
+
+   if (clgs->seen_before) {
+      CLG_ASSERT(ii->instr_offset == clgs->instr_offset);
+      CLG_ASSERT(ii->instr_size == instr_size);
+   } else {
+      ii->instr_offset = clgs->instr_offset;
+      ii->instr_size = instr_size;
+      ii->cost_offset = 0;
+   }
+
+   clgs->ii_index++;
+   clgs->instr_offset += instr_size;
+
+   return ii;
+}
+
+/*------------------------------------------------------------*/
+/*--- Instrumentation                                      ---*/
+/*------------------------------------------------------------*/
+
+#if defined(VG_BIGENDIAN)
+# define CLGEndness Iend_BE
+#elif defined(VG_LITTLEENDIAN)
+# define CLGEndness Iend_LE
+#else
+# error "Unknown endianness"
+#endif
+
+static
+Addr IRConst2Addr(IRConst* con)
+{
+   Addr addr;
+
+   if (sizeof(RegWord) == 4) {
+      CLG_ASSERT( con->tag == Ico_U32 );
+      addr = con->Ico.U32;
+   } else if (sizeof(RegWord) == 8) {
+      CLG_ASSERT( con->tag == Ico_U64 );
+      addr = con->Ico.U64;
+   } else {
+      VG_(tool_panic)("Callgrind: invalid Addr type");
+   }
+
+   return addr;
+}
+
+/* First pass over a BB to instrument, counting instructions and jumps
+ * This is needed for the size of the BB struct to allocate
+ *
+ * Called from CLG_(get_bb)
+ */
+void CLG_(collectBlockInfo)(IRSB* sbIn,
+      /*INOUT*/ UInt* instrs,
+      /*INOUT*/ UInt* cjmps,
+      /*INOUT*/ Bool* cjmp_inverted)
+{
+   Int i;
+   IRStmt* st;
+   Addr instrAddr =0, jumpDst;
+   UInt instrLen = 0;
+   Bool toNextInstr = False;
+
+   // Ist_Exit has to be ignored in preamble code, before first IMark:
+   // preamble code is added by VEX for self modifying code, and has
+   // nothing to do with client code
+   Bool inPreamble = True;
+
+   if (!sbIn) return;
+
+   for (i = 0; i < sbIn->stmts_used; i++) {
+      st = sbIn->stmts[i];
+      if (Ist_IMark == st->tag) {
+         inPreamble = False;
+
+         instrAddr = st->Ist.IMark.addr;
+         instrLen  = st->Ist.IMark.len;
+
+         (*instrs)++;
+         toNextInstr = False;
+      }
+      if (inPreamble) continue;
+      if (Ist_Exit == st->tag) {
+         jumpDst = IRConst2Addr(st->Ist.Exit.dst);
+         toNextInstr =  (jumpDst == instrAddr + instrLen);
+
+         (*cjmps)++;
+      }
+   }
+
+   /* if the last instructions of BB conditionally jumps to next instruction
+    * (= first instruction of next BB in memory), this is a inverted by VEX.
+    */
+   *cjmp_inverted = toNextInstr;
+}
+
+static
+void addConstMemStoreStmt( IRSB* bbOut, UWord addr, UInt val, IRType hWordTy)
+{
+   addStmtToIRSB( bbOut,
+                  IRStmt_Store(CLGEndness,
+                               IRExpr_Const(hWordTy == Ity_I32 ?
+                                            IRConst_U32( addr ) :
+                                            IRConst_U64( addr )),
+                               IRExpr_Const(IRConst_U32(val)) ));
+}
+
+
+/* add helper call to setup_bbcc, with pointer to BB struct as argument
+ *
+ * precondition for setup_bbcc:
+ * - jmps_passed has number of cond.jumps passed in last executed BB
+ * - current_bbcc has a pointer to the BBCC of the last executed BB
+ *   Thus, if bbcc_jmpkind is != -1 (JmpNone),
+ *     current_bbcc->bb->jmp_addr
+ *   gives the address of the jump source.
+ *
+ * the setup does 2 things:
+ * - trace call:
+ *   * Unwind own call stack, i.e sync our ESP with real ESP
+ *     This is for ESP manipulation (longjmps, C++ exec handling) and RET
+ *   * For CALLs or JMPs crossing objects, record call arg +
+ *     push are on own call stack
+ *
+ * - prepare for cache log functions:
+ *   set current_bbcc to BBCC that gets the costs for this BB execution
+ *   attached
+ */
+static
+void addBBSetupCall(ClgState* clgs)
+{
+   IRDirty* di;
+   IRExpr *arg1, **argv;
+
+   arg1 = mkIRExpr_HWord((HWord)clgs->bb);
+   argv = mkIRExprVec_1(arg1);
+   di = unsafeIRDirty_0_N(1, "setup_bbcc",
+                          VG_(fnptr_to_fnentry)(&CLG_(setup_bbcc)),
+                          argv);
+   addStmtToIRSB(clgs->sbOut, IRStmt_Dirty(di));
+}
+
+
+IRSB* CLG_(instrument)( VgCallbackClosure* closure,
+                        IRSB* sbIn,
+                        const VexGuestLayout* layout,
+                        const VexGuestExtents* vge,
+                        const VexArchInfo* archinfo_host,
+                        IRType gWordTy, IRType hWordTy )
+{
+   Int i;
+   IRStmt* st;
+   Addr origAddr;
+   InstrInfo* curr_inode = NULL;
+   ClgState clgs;
+   UInt cJumps = 0;
+
+   if (gWordTy != hWordTy) {
+      /* We don't currently support this case. */
+      VG_(tool_panic)("host/guest word size mismatch");
+   }
+
+   /* Set up SB for instrumented IR */
+   clgs.sbOut = deepCopyIRSBExceptStmts(sbIn);
+
+   // Copy verbatim any IR preamble preceding the first IMark
+   i = 0;
+   while (i < sbIn->stmts_used && sbIn->stmts[i]->tag != Ist_IMark) {
+      addStmtToIRSB( clgs.sbOut, sbIn->stmts[i] );
+      i++;
+   }
+
+   // Get the first statement, and origAddr from it
+   CLG_ASSERT(sbIn->stmts_used >0);
+   CLG_ASSERT(i < sbIn->stmts_used);
+   st = sbIn->stmts[i];
+   CLG_ASSERT(Ist_IMark == st->tag);
+
+   origAddr = st->Ist.IMark.addr + st->Ist.IMark.delta;
+   CLG_ASSERT(origAddr == st->Ist.IMark.addr
+                          + st->Ist.IMark.delta);  // XXX: check no overflow
+
+   /* Get BB struct (creating if necessary).
+    * JS: The hash table is keyed with orig_addr_noredir -- important!
+    * JW: Why? If it is because of different chasing of the redirection,
+    *     this is not needed, as chasing is switched off in callgrind
+    */
+   clgs.bb = CLG_(get_bb)(origAddr, sbIn, &(clgs.seen_before));
+
+   addBBSetupCall(&clgs);
+
+   // Set up running state
+   clgs.ii_index = 0;
+   clgs.instr_offset = 0;
+
+   for (/*use current i*/; i < sbIn->stmts_used; i++) {
+
+      st = sbIn->stmts[i];
+      CLG_ASSERT(isFlatIRStmt(st));
+
+      switch (st->tag) {
+         case Ist_NoOp:
+         case Ist_AbiHint:
+         case Ist_Put:
+         case Ist_PutI:
+         case Ist_MBE:
+         case Ist_WrTmp:
+         case Ist_Store:
+         case Ist_StoreG:
+         case Ist_LoadG:
+         case Ist_Dirty:
+         case Ist_LLSC:
+         case Ist_CAS:
+            break;
+
+         case Ist_IMark: {
+            Addr   cia   = st->Ist.IMark.addr + st->Ist.IMark.delta;
+            UInt   isize = st->Ist.IMark.len;
+            CLG_ASSERT(clgs.instr_offset == cia - origAddr);
+            // If Vex fails to decode an instruction, the size will be zero.
+            // Pretend otherwise.
+            if (isize == 0) isize = VG_MIN_INSTR_SZB;
+
+            // Sanity-check size.
+            tl_assert( (VG_MIN_INSTR_SZB <= isize && isize <= VG_MAX_INSTR_SZB)
+                  || VG_CLREQ_SZB == isize );
+
+            // Init the inode, record it as the current one.
+            // Subsequent Dr/Dw/Dm events from the same instruction will
+            // also use it.
+            curr_inode = next_InstrInfo (&clgs, isize);
+            break;
+         }
+
+         case Ist_Exit: {
+            Bool guest_exit, inverted;
+
+            /* VEX code generation sometimes inverts conditional branches.
+             * As Callgrind counts (conditional) jumps, it has to correct
+             * inversions. The heuristic is the following:
+             * (1) Callgrind switches off SB chasing and unrolling, and
+             *     therefore it assumes that a candidate for inversion only is
+             *     the last conditional branch in an SB.
+             * (2) inversion is assumed if the branch jumps to the address of
+             *     the next guest instruction in memory.
+             * This heuristic is precalculated in CLG_(collectBlockInfo)().
+             *
+             * Branching behavior is also used for branch prediction. Note that
+             * above heuristic is different from what Cachegrind does.
+             * Cachegrind uses (2) for all branches.
+             */
+            if (cJumps+1 == clgs.bb->cjmp_count) {
+                inverted = clgs.bb->cjmp_inverted;
+            } else {
+                inverted = False;
+            }
+
+            // call branch predictor only if this is a branch in guest code
+            guest_exit = (st->Ist.Exit.jk == Ijk_Boring) ||
+                         (st->Ist.Exit.jk == Ijk_Call) ||
+                         (st->Ist.Exit.jk == Ijk_Ret);
+
+            if (guest_exit) {
+               /* Stuff to widen the guard expression to a host word, so
+                  we can pass it to the branch predictor simulation
+                  functions easily. */
+               IRType   tyW    = hWordTy;
+               IROp     widen  = tyW==Ity_I32  ? Iop_1Uto32  : Iop_1Uto64;
+               IROp     opXOR  = tyW==Ity_I32  ? Iop_Xor32   : Iop_Xor64;
+               IRTemp   guard1 = newIRTemp(clgs.sbOut->tyenv, Ity_I1);
+               IRTemp   guardW = newIRTemp(clgs.sbOut->tyenv, tyW);
+               IRTemp   guard  = newIRTemp(clgs.sbOut->tyenv, tyW);
+               IRExpr*  one    = tyW==Ity_I32 ? IRExpr_Const(IRConst_U32(1))
+                                              : IRExpr_Const(IRConst_U64(1));
+
+               /* Widen the guard expression. */
+               addStmtToIRSB( clgs.sbOut,
+                              IRStmt_WrTmp( guard1, st->Ist.Exit.guard ));
+               addStmtToIRSB( clgs.sbOut,
+                              IRStmt_WrTmp( guardW,
+                                            IRExpr_Unop(widen,
+                                                        IRExpr_RdTmp(guard1))) );
+               /* If the exit is inverted, invert the sense of the guard. */
+               addStmtToIRSB(
+                       clgs.sbOut,
+                       IRStmt_WrTmp(
+                               guard,
+                               inverted ? IRExpr_Binop(opXOR, IRExpr_RdTmp(guardW), one)
+                                   : IRExpr_RdTmp(guardW)
+                                   ));
+            }
+
+            CLG_ASSERT(clgs.ii_index>0);
+            if (!clgs.seen_before) {
+               ClgJumpKind jk;
+
+               if      (st->Ist.Exit.jk == Ijk_Call) jk = jk_Call;
+               else if (st->Ist.Exit.jk == Ijk_Ret)  jk = jk_Return;
+               else {
+                  if (IRConst2Addr(st->Ist.Exit.dst) ==
+                        origAddr + curr_inode->instr_offset + curr_inode->instr_size) {
+
+                     jk = jk_None;
+                  } else {
+                     jk = jk_Jump;
+                  }
+               }
+
+               clgs.bb->jmp[cJumps].instr = clgs.ii_index-1;
+               clgs.bb->jmp[cJumps].jmpkind = jk;
+            }
+
+            /* Update global variable jmps_passed before the jump
+             * A correction is needed if VEX inverted the last jump condition
+             */
+            UInt val = inverted ? cJumps+1 : cJumps;
+            addConstMemStoreStmt( clgs.sbOut,
+                  (UWord) &CLG_(current_state).jmps_passed,
+                  val, hWordTy);
+            cJumps++;
+
+            break;
+         }
+
+         default:
+            tl_assert(0);
+            break;
+      }
+
+      /* Copy the original statement */
+      addStmtToIRSB( clgs.sbOut, st );
+   }
+
+   /* Update global variable jmps_passed at end of SB.
+    * As CLG_(current_state).jmps_passed is reset to 0 in setup_bbcc,
+    * this can be omitted if there is no conditional jump in this SB.
+    * A correction is needed if VEX inverted the last jump condition
+    */
+   if (cJumps>0) {
+      UInt jmps_passed = cJumps;
+      if (clgs.bb->cjmp_inverted) jmps_passed--;
+      addConstMemStoreStmt(clgs.sbOut,
+            (UWord) &CLG_(current_state).jmps_passed,
+            jmps_passed, hWordTy);
+   }
+   CLG_ASSERT(clgs.bb->cjmp_count == cJumps);
+   CLG_ASSERT(clgs.bb->instr_count == clgs.ii_index);
+
+   /* Info for final exit from BB */
+   {
+      ClgJumpKind jk;
+
+      if      (sbIn->jumpkind == Ijk_Call) jk = jk_Call;
+      else if (sbIn->jumpkind == Ijk_Ret)  jk = jk_Return;
+      else {
+         jk = jk_Jump;
+         if ((sbIn->next->tag == Iex_Const) &&
+               (IRConst2Addr(sbIn->next->Iex.Const.con) ==
+               origAddr + clgs.instr_offset)) {
+
+            jk = jk_None;
+         }
+      }
+      clgs.bb->jmp[cJumps].jmpkind = jk;
+      /* Instruction index of the call/ret at BB end
+       * (it is wrong for fall-through, but does not matter) */
+      clgs.bb->jmp[cJumps].instr = clgs.ii_index-1;
+   }
+
+   /* swap information of last exit with final exit if inverted */
+   if (clgs.bb->cjmp_inverted) {
+      ClgJumpKind jk;
+      UInt instr;
+
+      jk = clgs.bb->jmp[cJumps].jmpkind;
+      clgs.bb->jmp[cJumps].jmpkind = clgs.bb->jmp[cJumps-1].jmpkind;
+      clgs.bb->jmp[cJumps-1].jmpkind = jk;
+      instr = clgs.bb->jmp[cJumps].instr;
+      clgs.bb->jmp[cJumps].instr = clgs.bb->jmp[cJumps-1].instr;
+      clgs.bb->jmp[cJumps-1].instr = instr;
+   }
+
+   if (clgs.seen_before) {
+      CLG_ASSERT(clgs.bb->instr_len == clgs.instr_offset);
+   } else {
+      clgs.bb->instr_len = clgs.instr_offset;
+   }
+
+   return clgs.sbOut;
+}
+
+/*--------------------------------------------------------------------*/
+/*--- Discarding BB info                                           ---*/
+/*--------------------------------------------------------------------*/
+
+// Called when a translation is removed from the translation cache for
+// any reason at all: to free up space, because the guest code was
+// unmapped or modified, or for any arbitrary reason.
+static
+void clg_discard_superblock_info ( Addr orig_addr, VexGuestExtents vge )
+{
+   tl_assert(vge.n_used > 0);
+
+   // Get BB info, remove from table, free BB info.  Simple!
+   // When created, the BB is keyed by the first instruction address,
+   // (not orig_addr, but eventually redirected address). Thus, we
+   // use the first instruction address in vge.
+   CLG_(delete_bb)(vge.base[0]);
+}
+
+
+/*------------------------------------------------------------*/
+/*--- CLG_(fini)() and related function                     ---*/
+/*------------------------------------------------------------*/
+
+static
+void unwind_thread(thread_info* t)
+{
+   /* unwind signal handlers */
+   while (CLG_(current_state).sig != 0) {
+      CLG_(post_signal)(CLG_(current_tid),CLG_(current_state).sig);
+   }
+
+   /* unwind regular call stack */
+   while(CLG_(current_call_stack).sp>0) {
+      CLG_(pop_call_stack)();
+   }
+
+   /* reset context and function stack for context generation */
+   CLG_(init_exec_state)( &CLG_(current_state) );
+   CLG_(current_fn_stack).top = CLG_(current_fn_stack).bottom;
+}
+
+static
+void finish(void)
+{
+  /* pop all remaining items from CallStack for correct sum
+   */
+  CLG_(forall_threads)(unwind_thread);
+}
+
+
+void CLG_(fini)(Int exitcode)
+{
+   finish();
+}
+
+
+/*--------------------------------------------------------------------*/
+/*--- Setup                                                        ---*/
+/*--------------------------------------------------------------------*/
+
+static void clg_start_client_code_callback ( ThreadId tid, ULong blocks_done )
+{
+   static ULong last_blocks_done = 0;
+
+   /* throttle calls to CLG_(run_thread) by number of BBs executed */
+   if (blocks_done - last_blocks_done < 5000) return;
+   last_blocks_done = blocks_done;
+
+   CLG_(run_thread)( tid );
+}
+
+void CLG_(post_clo_init)(void)
+{
+   VG_(needs_superblock_discards)(clg_discard_superblock_info);
+
+   VG_(track_start_client_code)  ( & clg_start_client_code_callback );
+   VG_(track_pre_deliver_signal) ( & CLG_(pre_signal) );
+   VG_(track_post_deliver_signal)( & CLG_(post_signal) );
+
+   VG_(clo_vex_control).iropt_unroll_thresh = 0;   // cannot be overridden.
+   VG_(clo_vex_control).guest_chase = False; // cannot be overridden.
+
+   CLG_(init_statistics)(& CLG_(stat));
+
+   /* initialize hash tables */
+   CLG_(init_obj_table)();
+   CLG_(init_cxt_table)();
+   CLG_(init_bb_hash)();
+
+   CLG_(init_threads)();
+   CLG_(run_thread)(1);
+}
+
+/*--------------------------------------------------------------------*/
+/*--- end                                                   main.c ---*/
+/*--------------------------------------------------------------------*/
diff --git a/exp-failgrind/clg_threads.c b/exp-failgrind/clg_threads.c
new file mode 100644
index 000000000..29ce36e92
--- /dev/null
+++ b/exp-failgrind/clg_threads.c
@@ -0,0 +1,403 @@
+/*--------------------------------------------------------------------*/
+/*--- Callgrind                                                    ---*/
+/*---                                                 ct_threads.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Callgrind, a Valgrind tool for call tracing.
+
+   Copyright (C) 2002-2017, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "clg_global.h"
+
+#include "pub_tool_threadstate.h"
+
+/* forward decls */
+static exec_state* exec_state_save(void);
+static exec_state* exec_state_restore(void);
+static exec_state* push_exec_state(int);
+static exec_state* top_exec_state(void);
+
+static exec_stack current_states;
+
+
+/*------------------------------------------------------------*/
+/*--- Support for multi-threading                          ---*/
+/*------------------------------------------------------------*/
+
+
+/*
+ * For Valgrind, MT is cooperative (no preemting in our code),
+ * so we don't need locks...
+ *
+ * Per-thread data:
+ *  - BBCCs
+ *  - call stack
+ *  - call hash
+ *  - event counters: last, current
+ *
+ * Even when ignoring MT, we need this functions to set up some
+ * datastructures for the process (= Thread 1).
+ */
+
+/* current running thread */
+ThreadId CLG_(current_tid);
+
+static thread_info** thread;
+
+thread_info** CLG_(get_threads)()
+{
+   return thread;
+}
+
+thread_info* CLG_(get_current_thread)()
+{
+   return thread[CLG_(current_tid)];
+}
+
+void CLG_(init_threads)()
+{
+   UInt i;
+
+   thread = CLG_MALLOC("cl.threads.it.1", VG_N_THREADS * sizeof thread[0]);
+
+   for(i=0;i<VG_N_THREADS;i++) {
+      thread[i] = 0;
+   }
+   CLG_(current_tid) = VG_INVALID_THREADID;
+}
+
+/* switches through all threads and calls func */
+void CLG_(forall_threads)(void (*func)(thread_info*))
+{
+   Int t, orig_tid = CLG_(current_tid);
+
+   for(t=1;t<VG_N_THREADS;t++) {
+      if (!thread[t]) continue;
+      CLG_(switch_thread)(t);
+      (*func)(thread[t]);
+   }
+   CLG_(switch_thread)(orig_tid);
+}
+
+
+static
+thread_info* new_thread(void)
+{
+   thread_info* t;
+
+   t = (thread_info*) CLG_MALLOC("cl.threads.nt.1",
+                                 sizeof(thread_info));
+
+   /* init state */
+   CLG_(init_exec_stack)( &(t->states) );
+   CLG_(init_call_stack)( &(t->calls) );
+   CLG_(init_fn_stack)  ( &(t->fns) );
+   /* t->states.entry[0]->cxt = CLG_(get_cxt)(t->fns.bottom); */
+
+   /* init data containers */
+   CLG_(init_fn_array)( &(t->fn_active) );
+   CLG_(init_bbcc_hash)( &(t->bbccs) );
+   CLG_(init_jcc_hash)( &(t->jccs) );
+
+   return t;
+}
+
+
+void CLG_(switch_thread)(ThreadId tid)
+{
+   if (tid == CLG_(current_tid)) return;
+
+   if (CLG_(current_tid) != VG_INVALID_THREADID) {
+      /* save thread state */
+      thread_info* t = thread[CLG_(current_tid)];
+
+      CLG_ASSERT(t != 0);
+
+      /* current context (including signal handler contexts) */
+      exec_state_save();
+      CLG_(copy_current_exec_stack)( &(t->states) );
+      CLG_(copy_current_call_stack)( &(t->calls) );
+      CLG_(copy_current_fn_stack)  ( &(t->fns) );
+
+      CLG_(copy_current_fn_array) ( &(t->fn_active) );
+      CLG_(copy_current_bbcc_hash)( &(t->bbccs) );
+      CLG_(copy_current_jcc_hash) ( &(t->jccs) );
+   }
+
+   CLG_(current_tid) = tid;
+   CLG_ASSERT(tid < VG_N_THREADS);
+
+   if (tid != VG_INVALID_THREADID) {
+      thread_info* t;
+
+      /* load thread state */
+
+      if (thread[tid] == 0) thread[tid] = new_thread();
+      t = thread[tid];
+
+      /* current context (including signal handler contexts) */
+      CLG_(set_current_exec_stack)( &(t->states) );
+      exec_state_restore();
+      CLG_(set_current_call_stack)( &(t->calls) );
+      CLG_(set_current_fn_stack)  ( &(t->fns) );
+
+      CLG_(set_current_fn_array)  ( &(t->fn_active) );
+      CLG_(set_current_bbcc_hash) ( &(t->bbccs) );
+      CLG_(set_current_jcc_hash)  ( &(t->jccs) );
+   }
+}
+
+
+void CLG_(run_thread)(ThreadId tid)
+{
+   /* now check for thread switch */
+   CLG_(switch_thread)(tid);
+}
+
+void CLG_(pre_signal)(ThreadId tid, Int sigNum, Bool alt_stack)
+{
+   exec_state *es;
+
+   /* switch to the thread the handler runs in */
+   CLG_(switch_thread)(tid);
+
+   /* save current execution state */
+   exec_state_save();
+
+   /* setup new cxtinfo struct for this signal handler */
+   es = push_exec_state(sigNum);
+   es->call_stack_bottom = CLG_(current_call_stack).sp;
+
+   /* setup current state for a spontaneous call */
+   CLG_(init_exec_state)( &CLG_(current_state) );
+   CLG_(current_state).sig = sigNum;
+   CLG_(push_cxt)(0);
+}
+
+/* Run post-signal if the stackpointer for call stack is at
+ * the bottom in current exec state (e.g. a signal handler)
+ *
+ * Called from CLG_(pop_call_stack)
+ */
+void CLG_(run_post_signal_on_call_stack_bottom)()
+{
+   exec_state* es = top_exec_state();
+   CLG_ASSERT(es != 0);
+   CLG_ASSERT(CLG_(current_state).sig >0);
+
+   if (CLG_(current_call_stack).sp == es->call_stack_bottom) {
+      CLG_(post_signal)( CLG_(current_tid), CLG_(current_state).sig );
+   }
+}
+
+void CLG_(post_signal)(ThreadId tid, Int sigNum)
+{
+   exec_state* es;
+   UInt fn_number, *pactive;
+
+   /* thread switching potentially needed, eg. with instrumentation off */
+   CLG_(switch_thread)(tid);
+   CLG_ASSERT(sigNum == CLG_(current_state).sig);
+
+   /* Unwind call stack of this signal handler.
+    * This should only be needed at finalisation time
+    */
+   es = top_exec_state();
+   CLG_ASSERT(es != 0);
+   while(CLG_(current_call_stack).sp > es->call_stack_bottom) {
+      CLG_(pop_call_stack)();
+   }
+
+   if (CLG_(current_state).cxt) {
+      /* correct active counts */
+      fn_number = CLG_(current_state).cxt->fn[0]->number;
+      pactive = CLG_(get_fn_entry)(fn_number);
+      (*pactive)--;
+   }
+
+   if (CLG_(current_fn_stack).top > CLG_(current_fn_stack).bottom) {
+      /* set fn_stack_top back.
+       * top can point to 0 if nothing was executed in the signal handler;
+       * this is possible at end on unwinding handlers.
+       */
+      if (*(CLG_(current_fn_stack).top) != 0) {
+         CLG_(current_fn_stack).top--;
+         CLG_ASSERT(*(CLG_(current_fn_stack).top) == 0);
+      }
+      if (CLG_(current_fn_stack).top > CLG_(current_fn_stack).bottom) {
+         CLG_(current_fn_stack).top--;
+      }
+   }
+
+   /* restore previous context */
+   es->sig = -1;
+   current_states.sp--;
+   es = top_exec_state();
+   CLG_(current_state).sig = es->sig;
+   exec_state_restore();
+
+   /* There is no way to reliable get the thread ID we are switching to
+    * after this handler returns. So we sync with actual TID at start of
+    * CLG_(setup_bb)(), which should be the next for callgrind.
+    */
+}
+
+
+
+/*------------------------------------------------------------*/
+/*--- Execution states in a thread & signal handlers       ---*/
+/*------------------------------------------------------------*/
+
+/* Each thread can be interrupted by a signal handler, and they
+ * themselves again. But as there's no scheduling among handlers
+ * of the same thread, we don't need additional stacks.
+ * So storing execution contexts and
+ * adding separators in the callstack(needed to not intermix normal/handler
+ * functions in contexts) should be enough.
+ */
+
+/* not initialized: call_stack_bottom, sig */
+void CLG_(init_exec_state)(exec_state* es)
+{
+   es->cxt  = 0;
+   es->jmps_passed = 0;
+   es->bbcc = 0;
+   es->nonskipped = 0;
+}
+
+
+static exec_state* new_exec_state(Int sigNum)
+{
+   exec_state* es;
+   es = (exec_state*) CLG_MALLOC("cl.threads.nes.1",
+                                 sizeof(exec_state));
+
+   /* allocate real cost space: needed as incremented by
+    * simulation functions */
+   CLG_(init_exec_state)(es);
+   es->sig        = sigNum;
+   es->call_stack_bottom  = 0;
+
+   return es;
+}
+
+void CLG_(init_exec_stack)(exec_stack* es)
+{
+   Int i;
+
+   /* The first element is for the main thread */
+   es->entry[0] = new_exec_state(0);
+   for(i=1; i<MAX_SIGHANDLERS; i++) {
+      es->entry[i] = 0;
+   }
+   es->sp = 0;
+}
+
+void CLG_(copy_current_exec_stack)(exec_stack* dst)
+{
+   Int i;
+
+   dst->sp = current_states.sp;
+   for(i=0; i<MAX_SIGHANDLERS; i++) {
+      dst->entry[i] = current_states.entry[i];
+   }
+}
+
+void CLG_(set_current_exec_stack)(exec_stack* dst)
+{
+   Int i;
+
+   current_states.sp = dst->sp;
+   for(i=0; i<MAX_SIGHANDLERS; i++) {
+      current_states.entry[i] = dst->entry[i];
+   }
+}
+
+
+/* Get top context info struct of current thread */
+static
+exec_state* top_exec_state(void)
+{
+   Int sp = current_states.sp;
+   exec_state* es;
+
+   CLG_ASSERT((sp >= 0) && (sp < MAX_SIGHANDLERS));
+   es = current_states.entry[sp];
+   CLG_ASSERT(es != 0);
+   return es;
+}
+
+/* Allocates a free context info structure for a new entered
+ * signal handler, putting it on the context stack.
+ * Returns a pointer to the structure.
+ */
+static exec_state* push_exec_state(int sigNum)
+{
+   Int sp;
+   exec_state* es;
+
+   current_states.sp++;
+   sp = current_states.sp;
+
+   CLG_ASSERT((sigNum > 0) && (sigNum <= _VKI_NSIG));
+   CLG_ASSERT((sp > 0) && (sp < MAX_SIGHANDLERS));
+   es = current_states.entry[sp];
+   if (!es) {
+      es = new_exec_state(sigNum);
+      current_states.entry[sp] = es;
+   } else {
+      es->sig = sigNum;
+   }
+
+   return es;
+}
+
+/* Save current context to top cxtinfo struct */
+static
+exec_state* exec_state_save(void)
+{
+   exec_state* es = top_exec_state();
+
+   es->cxt         = CLG_(current_state).cxt;
+   es->jmps_passed = CLG_(current_state).jmps_passed;
+   es->bbcc        = CLG_(current_state).bbcc;
+   es->nonskipped  = CLG_(current_state).nonskipped;
+
+   /* signal number does not need to be saved */
+   CLG_ASSERT(CLG_(current_state).sig == es->sig);
+
+   return es;
+}
+
+static
+exec_state* exec_state_restore(void)
+{
+   exec_state* es = top_exec_state();
+
+   CLG_(current_state).cxt     = es->cxt;
+   CLG_(current_state).jmps_passed = es->jmps_passed;
+   CLG_(current_state).bbcc    = es->bbcc;
+   CLG_(current_state).nonskipped = es->nonskipped;
+   CLG_(current_state).sig     = es->sig;
+
+   return es;
+}
diff --git a/exp-failgrind/docs/fg-manual.xml b/exp-failgrind/docs/fg-manual.xml
new file mode 100644
index 000000000..8b21c0d0c
--- /dev/null
+++ b/exp-failgrind/docs/fg-manual.xml
@@ -0,0 +1,1422 @@
+<?xml version="1.0"?> <!-- -*- sgml -*- -->
+<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
+          "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
+[ <!ENTITY % vg-entities SYSTEM "../../docs/xml/vg-entities.xml"> %vg-entities; ]>
+
+
+<chapter id="fg-manual" xreflabel="Failgrind: a memory allocation and syscall failure testing tool">
+<title>Failgrind: a memory allocation and syscall failure testing tool</title>
+
+<para>To use this tool, you must specify
+<option>--tool=exp-failgrind</option> on the Valgrind
+command line.</para>
+
+
+
+<sect1 id="fg-manual.overview" xreflabel="Overview">
+<title>Overview</title>
+
+<para>Failgrind is a tool for simulating heap memory allocation failures and
+system call (syscall) failures to examine how programs respond. It has been
+designed to used for testing full programs, or targetted parts of a program or
+test suite.</para>
+
+<para>Whenever a heap memory allocation request is made by a program, the tool
+examines the call stack to determine if this particular call stack has been
+seen before. If this is the first time this call stack has been seen, then
+the memory request will fail and a NULL returned. If the call stack has
+been seen before, then the memory allocation succeeds. A record of the call
+stacks that have been seen before are stored in a text file.  These records are
+loaded when the tool starts, so it is possible (and desirable) to run your
+program multiple times to inspect different memory failure paths.</para>
+
+<para>The same behaviour applies to syscalls. If the call stack associated with
+the syscall has been seen before, the syscall will return failure and set
+errno to EINVAL. Options exist for customising the error returned either
+globally or on a per-syscall basis. Syscall failures are not enabled by
+default.</para>
+
+<para>Using Failgrind successfully involves running your program many times
+until all different memory allocation or syscall call stacks that you are
+interested in have been tested. For complex programs this may only be feasible
+as part of a dedicated testing program rather than manual testing. Failgrind
+has a good range of options for controlling how the heap allocation failures
+occur, to help with testing a variety of scenarios.</para>
+
+<para>You may be able to get an idea of the scale of the testing required by
+looking at the output of a run through Memcheck - this will tell you how
+many allocations there were. As an example, testing the ssh command
+connecting successfully to a remote server took approximately 400 runs of
+Failgrind, saving nearly 3000 call stacks in the process, and making
+10000 allocations in the final run.</para>
+
+</sect1>
+
+<sect1 id="fg-manual.general-operation" xreflabel="General Operation">
+<title>General Operation</title>
+<para>This section describes the features that are common to both allocation
+and syscall failures.</para>
+
+<sect2>
+<title>Callstack files</title>
+<para>Probably the most important options are around reading and writing the
+file that contains information on what callstacks have been seen before.
+This file is key to the concept of running Failgrind multiple times on your
+program to examine behaviour through the whole program flow. By default
+Failgrind will attempt to read callstack information from the file
+<option>failgrind.callstacks</option>, then as it runs will append new
+callstacks to that file. An example callstack is shown below:</para>
+
+<screen><![CDATA[
+# ./my_program
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x1087E3: f_b (myprog.c:11)
+by 0x10886B: f_c (myprog.c:26)
+by 0x1088BC: f_a (myprog.c:38)
+by 0x108902: main (myprog.c:48)
+]]></screen>
+
+<para>This shows that the program <option>my_program</option> produced the
+callstack, and that the allocation function that failed was malloc, plus
+the callstack of functions that lead to the malloc call. Your callstack
+file will contain many of these entries when you have finished your
+testing. It is safe to remove complete callstacks from the callstack file.
+Doing so means that the next time that Failgrind runs your program, that
+particular callstack will fail again.</para>
+
+<para>It is possible for Failgrind to use separate callstack files
+when reading and writing. This is done with the
+<option>--callstack-input</option> and <option>--callstack-output</option>
+options. Both of these options can be used to specify a file, for example:
+<option>--callstack-input=test1.callstacks</option>. It is safe to have the
+input and output point to the same file, or to have them be different
+files. It is also possible to have reading or writing of callstacks
+disabled by setting either of these examples to no, for example:
+<option>--callstack-input=test1.callstacks --callstack-output=no</option>.
+This would read callstacks from the test1.callstacks file, but not write
+any new callstack output. These techniques allow you to use a reference
+callstack file as an input which is never modified, and an output file
+which is then examined or discarded depending on your needs.</para>
+
+<para>The final callstack file option is
+<option>--write-callstacks-at-end</option>, which can be set to yes or no.
+When at the default value of no, each new callstack will be appended to the
+callstack file immediately. When set to yes, the callstack output file will
+be created as a new file when Failgrind exits. Use of this option can
+produce some different behaviour when combined with gdb or Client
+Requests.</para>
+</sect2>
+
+<sect2>
+<title>Results display</title>
+<para>Failgrind has two options to control its output. The first is
+<option>--show-failed</option>, which defaults to no. If set to yes, then
+each time a new failure occurs the callstack will be printed to the screen
+as well as to the callstack file. The second option is
+<option>--failgrind-stats</option>, which defaults to yes. This shows a
+brief summary of some relevant counters:</para>
+
+<screen><![CDATA[
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            0 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
+]]></screen>
+
+<para>You can use this information to determine whether your testing is
+complete. If "X failed" is 0, and "new X callstacks found" is 0, then there
+are no other paths to be found, assuming the same program behaviour on each
+program run. It is possible to automate this technique using the client
+requests as described in <xref linkend="fg-manual.clientrequests.example"/>.</para>
+</sect2>
+
+<sect2>
+<title>Randomness</title>
+<para>Both of the allocation and syscall failure methods have options which
+allow failures to happen randomly (<option>--alloc-fail-chance</option> and
+<option>--syscall-fail-chance</option>). If you are using either of these
+options, then it is possible to get reproduceable results using the
+<option>--seed</option>, for example: <option>--seed=12345</option>.</para>
+</sect2>
+</sect1>
+
+
+<sect1 id="fg-manual.allocation.failures" xreflabel="Allocation Failures">
+<title>Allocation Failures</title>
+<para>This section describes using Failgrind to test program behaviour in the
+presence of heap memory allocation failures.</para>
+
+<sect2>
+<title>Controlling Allocation Failures</title>
+<para>Failgrind has a range of options for controlling when allocation failures
+can occur. The default behaviour is to fail every allocation attempt the
+first time it is seen. All of the options described below can be combined.</para>
+
+<sect3>
+<title>Toggle Functions and Start Behaviour</title>
+<para>Probably the most useful control option is
+<option>--alloc-toggle</option>. This allows you to specify a function
+where the global allocation failure switch will be toggled on entry and
+exit from the function. This provides a straightforward way of isolating
+Failgrind to only testing the parts of your program that you are interested
+in. If you use a toggle function, then Failgrind will start with allocation
+failures disabled. This means if you specify
+<option>--alloc-toggle=test_suite</option>, then all code prior to
+test_suite() will run as normal, the the code inside test_suite() will run
+with allocation failures enabled, and finally all code after test_suite()
+will run as normal. Global allocation failures can be enabled/disabled at the
+start of Failgrind using <option>--alloc-fail-atstart</option>, which can
+be set to yes or no.</para>
+
+<para>The same functionality can be obtained in a more programmatic manner
+through the use of <xref linkend="fg-manual.monitor-commands"/> or
+<xref linkend="fg-manual.clientrequests"/>).</para>
+</sect3>
+
+<sect3>
+<title>Allocation Size</title>
+<para>Allocations failures can be controlled based on the size of allocation
+being made. This is controlled by the
+<option>--alloc-threshold-high</option> and
+<option>--alloc-threshold-low</option> options, which specify high and low
+thresholds in bytes respectively. For example:</para>
+
+<para>All allocations larger than 100 bytes will always succeed:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-threshold-high=100 ./my_prog
+]]></screen>
+</para>
+
+<para>All allocations smaller than 10 bytes will always succeed:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-threshold-low=10 ./my_prog
+]]></screen>
+</para>
+
+<para>All allocations larger than 100 bytes and smaller than 10 bytes will
+always succeed:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-threshold-high=100 --alloc-threshold-low=10 ./my_prog
+]]></screen>
+</para>
+
+<para>The sense of the thresholds can be inverted with
+<option>--alloc-threshold-invert=yes</option>. Only really makes sense when
+specifying both a high and low threshold. For example:</para>
+
+<para>All allocations smaller than 100 bytes will always succeed:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-threshold-high=100 --alloc-threshold-invert ./my_prog
+]]></screen>
+</para>
+
+<para>All allocations larger than 10 bytes will always succeed:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-threshold-low=10 --alloc-threshold-invert ./my_prog
+]]></screen>
+</para>
+
+<para>All allocations greater than 10 bytes and smaller than 100 bytes will
+always succeed:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-threshold-high=100 --alloc-threshold-low=10 --alloc-threshold-invert ./my_prog
+]]></screen>
+</para>
+
+</sect3>
+
+<sect3>
+<title>Allowing Specific Memory Allocation Functions</title>
+
+<para>If you wish to have a memory allocation function always succeed
+regardless of other options, use the <option>--alloc-allow</option> option.
+This can be specified multiple times. For example if you are not interested in
+failing strdup():</para>
+
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-allow=strdup ./my_prog
+]]></screen>
+</sect3>
+
+<sect3>
+<title>Allocation Count</title>
+<para>The number of allocation failures in a Failgrind run can be limited using
+the <option>--alloc-max-fails</option> option, which is an integer. It can
+sometimes be useful to limit to a single allocation per run, at the cost of
+increasing the number of runs that are needed:</para>
+
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-max-fails=1 ./my_prog
+]]></screen>
+</sect3>
+
+<sect3>
+<title>Randomness</title>
+<para>The <option>--alloc-fail-chance</option> option allows allocation
+failures to happen randomly. Set to an integer value 1-100 that represents
+the percentage chance an allocation that is due to be rejected (that hasn't
+been seen before and meets all other criteria) will actually fail. Use with
+the <option>--seed</option> to get reproduceable but random tests. When you
+use <option>--alloc-fail-chance</option>, the seed being used is displayed
+by Failgrind on start. For example, to fail 50% of the time:</para>
+
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-fail-chance=50 ./my_prog
+
+==15526== Failgrind, a memory allocation and syscall failure testing tool
+==15526== NOTE: This is an Experimental-Class Valgrind Tool
+==15526== Copyright (C) 2018-2021, and GNU GPL'd, by Roger Light.
+==15526== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info
+==15526== Command: ./my_prog
+==15526==
+==15526== Using random seed: 7937841
+...
+]]></screen>
+</sect3>
+
+</sect2>
+
+<sect2 id="fg-manual.debugging.a.complete.program" xreflabel="Debugging a Complete Program">
+<title>Debugging a Complete Program </title>
+
+<para>This method of testing requires no modification to your program and
+provides the opportunity to have full testing coverage.</para>
+
+<para>For this type of debugging, the most important options are
+<option>--callstack-input</option> and <option>--callstack-output</option>,
+which control where the in-memory list of call stacks that have been seen
+are read from or stored to, which is important for running Failgrind over
+multiple runs.</para>
+
+<para>You should also look at the wide variety of options for controlling
+Failgrind at <xref linkend="fg-manual.options"/>.</para>
+
+<sect3>
+<title>Simple Example</title>
+
+<para>A trivial program:</para>
+
+<programlisting><![CDATA[
+ 1      #include <stdio.h>
+ 2      #include <stdlib.h>
+ 3
+ 4      void func_A(void)
+ 5      {
+ 6          int *ptr1;
+ 7
+ 8          ptr1 = malloc(10);
+ 9          if(!ptr1){
+10              return;
+11          }
+12      }
+13
+14      int main(int argc, char *argv[])
+15      {
+16          func_A();
+17      }
+]]></programlisting>
+
+<para>Running through Failgrind for the first time, and using the
+<option>--show-failed=yes</option> option produces the following
+output:</para>
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --show-failed=yes ./test
+==17460== Failgrind, a memory allocation failure testing tool
+==17460== NOTE: This is an Experimental-Class Valgrind Tool
+==17460== Copyright (C) 2018-2021, and GNU GPL'd, by Roger Light.
+==17460== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info
+==17460== Command: ./test
+==17460==
+==17460==    at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+==17460==    by 0x10865B: func_A (test.c:8)
+==17460==    by 0x10867A: main (test.c:16)
+==17460==
+==17460==
+--17460--  Failgrind: 0 call stacks loaded from file
+--17460--             0 allocations succeeded
+--17460--             1 allocations failed
+--17460--             1 new allocation callstacks found
+--17460--             0 syscalls succeeded
+--17460--             0 syscalls failed
+--17460--             0 new syscall callstacks found
+--17460--
+]]></screen>
+
+<para>This is as expected - the single call to malloc has failed, and the stack
+trace tells us where it was. We can see that the callstack file was empty
+because no call stacks were loaded.</para>
+
+<para>Running a second time:</para>
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --show-failed=yes ./test
+==17461== Failgrind, a memory allocation failure testing tool
+==17461== NOTE: This is an Experimental-Class Valgrind Tool
+==17461== Copyright (C) 2018-2021, and GNU GPL'd, by Roger Light.
+==17461== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info
+==17461== Command: ./test
+==17461==
+==17461==
+--17461--  Failgrind: 1 call stacks loaded from file
+--17461--             1 allocations succeeded
+--17461--             0 allocations failed
+--17461--             0 new allocation callstacks found
+--17461--             0 syscalls succeeded
+--17461--             0 syscalls failed
+--17461--             0 new syscall callstacks found
+--17461--
+]]></screen>
+
+<para>This shows a single call stack was loaded from the callstack file, and
+that our allocation matches that call stack because the allocation
+succeeded.</para>
+</sect3>
+
+<sect3>
+<title>Example causing a segfault</title>
+
+<para>A possible outcome of memory failures is that the program being tested
+segfaults. The listing below extends our program to add a second memory
+allocation that isn't checked for success, then attempts to write to that
+memory.</para>
+
+<programlisting><![CDATA[
+ 1      #include <stdlib.h>
+ 2
+ 3      void func_A(void)
+ 4      {
+ 5          int *ptr1;
+ 6          int *ptr2;
+ 7
+ 8          ptr1 = malloc(10);
+ 9          if(!ptr1){
+10              return;
+11          }
+12
+13          ptr2 = malloc(10);
+14          ptr2[5] = 1;
+15      }
+16
+17      int main(int argc, char *argv[])
+18      {
+19          func_A();
+20      }
+]]></programlisting>
+
+<para>Before the testing begins again, the failgrind.callstacks file is removed
+to give a fresh start with no old callstacks.  The first run of the program
+is identical to the previous first run. Running Failgrind a second time,
+this time using the default options (i.e. the failed allocation call stacks
+are not being printed) produces:</para>
+
+<screen><![CDATA[
+==17619== Failgrind, a memory allocation failure testing tool
+==17619== NOTE: This is an Experimental-Class Valgrind Tool
+==17619== Copyright (C) 2018-2021, and GNU GPL'd, by Roger Light.
+==17619== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info
+==17619== Command: ./a.out
+==17619==
+==17619==
+==17619== Process terminating with default action of signal 11 (SIGSEGV)
+==17619==  Access not within mapped region at address 0x14
+==17619==    at 0x10867D: func_A (test.c:14)
+==17619==    by 0x10869B: main (test.c:19)
+==17619==  If you believe this happened as a result of a stack
+==17619==  overflow in your program's main thread (unlikely but
+==17619==  possible), you can try to increase the size of the
+==17619==  main thread stack using the --main-stacksize= flag.
+==17619==  The main thread stack size used in this run was 8388608.
+==17619==
+--17619--  Failgrind: 1 call stacks loaded from file
+--17619--             1 allocations succeeded
+--17619--             1 allocations failed
+--17619--             1 new allocation callstacks found
+--17619--             0 syscalls succeeded
+--17619--             0 syscalls failed
+--17619--             0 new syscall callstacks found
+--17619--
+Segmentation fault (core dumped)
+]]></screen>
+
+<para>As expected, the write to the invalid pointer from the unchecked
+allocation causes a crash. We can see where the crash occurred, but that
+doesn't necessarily tell us where the allocation failure was. In this
+example, only one allocation failed, so we know this must be the allocation
+that caused the crash, and it will be the final entry in the callstack
+file:</para>
+
+<screen><![CDATA[
+# ./test
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x108670: func_A (test.c:13)
+by 0x10869B: main (test.c:19)
+]]></screen>
+
+<para>It is possible to repeat a test by removing call stacks from the
+callstack file. In this case, removing the final call stack effectively
+restores our testing environment to as it was before the current test.</para>
+
+<para>As well as examining the call stack file to see allocation failures, it
+is also possible to have callstacks printed to the screen each time a
+failure occurs, as was seen earlier. This is enabled using
+<option>--show-failed=yes</option>, and produces an output like
+below:</para>
+
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --show-failed=yes ./a.out
+==17674== Failgrind, a memory allocation failure testing tool
+==17674== NOTE: This is an Experimental-Class Valgrind Tool
+==17674== Copyright (C) 2018-2021, and GNU GPL'd, by Roger Light.
+==17674== Using Valgrind-3.16.1 *and LibVEX; rerun with -h for copyright info
+==17674== Command: ./a.out
+==17674==
+==17674==    at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+==17674==    by 0x108670: func_A (test.c:13)
+==17674==    by 0x10869B: main (test.c:19)
+...
+]]></screen>
+
+</sect3>
+</sect2>
+
+
+<sect2>
+<title>Debugging Parts of a Program</title>
+
+<para>Debugging your program in parts allows more targetted testing, such as
+testing parts of the program that are known to have changed or as part of a
+test suite.</para>
+
+<sect3>
+<title>Simple Method</title>
+
+<para>The most straightforward method of controlling which parts of your
+program are tested, is through the <option>--alloc-fail-atstart</option> and
+<option>--alloc-toggle</option> options. By default, as soon as Failgrind
+starts it will begin rejecting heap memory allocations. Using
+<option>--alloc-fail-atstart=no</option>, no memory allocations will be
+rejected until allocation failures are re-enabled. To enable allocation
+failures you can use a gdb monitor command, a client request, as described in
+<xref linkend="fg-manual.monitor-commands"/> and <xref
+	linkend="fg-manual.clientrequests"/>,, or tell Failgrind to enable itself
+automatically using the <option>--alloc-toggle</option> option. This option,
+which can be repeated in order to specify multiple functions, causes Failgrind
+to toggle the enabled/disabled state when a named function is entered and left.
+For example, running a program <option>prog</option> as follows:</para>
+
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-toggle=run_test1 --alloc-toggle=run_test2 prog
+]]></screen>
+
+<para>The program listing:</para>
+<programlisting><![CDATA[
+ 1      #include <failgrind.h>
+ 2      #include <test_funcs.h>
+ 3
+ 4      int main(int argc, char* argv[])
+ 5      {
+ 6         setup_test_suite();
+ 7
+ 8         run_test1();
+ 9
+10         run_test2();
+11
+12         cleanup_test_suite();
+13         return 0;
+14      }
+]]></programlisting>
+
+<para>When <option>--alloc-toggle</option> is in use,
+<option>--alloc-fail-atstart</option> defaults to <option>no</option>, so
+Failgrind starts off disabled. The setup of the test (the setup_test_suite()
+function) is carried out with no memory allocations being rejected. The
+<option>--alloc-toggle=run_test1</option> option means that when run_test1() is
+entered, the enabled/disabled state will be toggled - so during the execution
+of this function memory allocation failures are enabled - then after it is left
+they will be disabled again. The same is true for run_test2().</para>
+</sect3>
+
+<sect3>
+<title>Advanced Methods</title>
+
+<para>If you need more control than is possible with the simple toggle option,
+then you should look into monitor commands or client requests (see
+<xref linkend="fg-manual.monitor-commands"/> or
+<xref linkend="fg-manual.clientrequests"/>) where it is possible to
+enable/disable Failgrind, reset its state and other capabilities.</para>
+</sect3>
+</sect2>
+</sect1>
+
+<sect1 id="fg-manual.syscall.failures" xreflabel="Syscall Failures">
+<title>Syscall Failures</title>
+<para>This section describes using Failgrind to test program behaviour in the
+presence of syscall failures.</para>
+
+<para>Syscall failures are a bit trickier to deal with than allocations,
+so the default Failgrind behaviour is to not fail syscalls.</para>
+
+<para>Note that some syscalls never return an error and have been set to always succeed in Failgrind. This currently includes:
+
+<screen>alarm exit exit_group getegid geteuid getgid getpgrp getpid getppid gettid getuid sched_yield set_tid_address sync umask</screen>
+</para>
+
+<sect2>
+<title>Controlling Syscall Failures</title>
+<para>Failgrind has a range of options for controlling when syscall failures
+can occur. All of the options described below can be combined.</para>
+
+<sect3>
+<title>Toggle Functions and Start Behaviour</title>
+<para>Probably the most useful control option is
+<option>--syscall-toggle</option>. This allows you to specify a function
+where the global syscall failure switch will be toggled on entry and
+exit from the function. This provides a straightforward way of isolating
+Failgrind to only testing the parts of your program that you are interested
+in. If you specify <option>--syscall-toggle=test_suite</option>, then all code prior to
+test_suite() will run as normal, the the code inside test_suite() will run
+with syscall failures enabled, and finally all code after test_suite()
+will run as normal. Global syscall failures can be enabled/disabled at the
+start of Failgrind using <option>--syscall-fail-atstart</option>, which can
+be set to yes or no.</para>
+
+<para>The same functionality can be obtained in a more programmatic manner
+through the use of <xref linkend="fg-manual.monitor-commands"/> or
+<xref linkend="fg-manual.clientrequests"/>).</para>
+</sect3>
+
+<sect3>
+<title>Setting Error Values</title>
+<para>By default, Failgrind will have all syscalls fail with errno EINVAL. This
+can be changed globally or per-syscall. Use
+<option>--syscall-errno=&lt;error&gt;</option> to set the error value to
+use for all syscalls. Use
+<option>--syscall-errno=&lt;function&gt;,&lt;error&gt;</option> to set an
+error to be used for a particular syscall. For example:</para>
+
+<para>All syscalls will fail with EINTR:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --syscall-fail-atstart=yes --syscall-errno=EINTR ./my_prog
+]]></screen>
+</para>
+
+<para>All syscalls will fail with EINVAL, except for open(), which will fail
+with EACCES:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --syscall-fail-atstart=yes --syscall-errno=open,EACCES ./my_prog
+]]></screen>
+</para>
+
+<para>All syscalls will fail with EINTR, except for open(), which will fail
+with EACCES:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --syscall-fail-atstart=yes --syscall-errno=EINTR --syscall-errno=open,EACCES ./my_prog
+]]></screen>
+</para>
+
+<para>A further option <option>--syscall-specified-only</option>, which can be
+set to yes or no and defaults to no. If set to yes, then only functions
+that have been configured with
+<option>--syscall-errno=&lt;function&gt;,&lt;error&gt;</option> will fail.
+This allows targetted testing of particular syscalls. For example:</para>
+
+<para>Calls to open() will fail with EACCES, all other syscalls will succeed:
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --syscall-fail-atstart=yes --syscall-errno=open,EACCES --specified-only=yes ./my_prog
+]]></screen>
+</para>
+</sect3>
+
+<sect3>
+<title>Allowing Specific Syscalls</title>
+
+<para>If you wish to have a syscall always succeed regardless of other options,
+use the <option>--syscall-allow</option> option. This can be specified
+multiple times. This option is particularly useful if you are using
+printf() for debugging and always want it to succeed by allowing the
+<option>write</option> syscall. For example:</para>
+
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --syscall-fail-atstart=yes --syscall-allow=write ./my_prog
+]]></screen>
+</sect3>
+
+
+<sect3>
+<title>Syscall Count</title>
+<para>The number of syscall failures in a Failgrind run can be limited using
+the <option>--syscall-max-fails</option> option, which is an integer. It can
+sometimes be useful to limit to a single syscall per run, at the cost of
+increasing the number of runs that are needed:</para>
+
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --syscall-max-fails=1 ./my_prog
+]]></screen>
+</sect3>
+
+<sect3>
+<title>Randomness</title>
+<para>The <option>--syscall-fail-chance</option> option allows syscall
+failures to happen randomly. Set to an integer value 1-100 that represents
+the percentage chance an syscall that is due to be rejected (that hasn't
+been seen before and meets all other criteria) will actually fail. Use with
+the <option>--seed</option> to get reproduceable but random tests. When you
+use <option>--syscall-fail-chance</option>, the seed being used is displayed
+by Failgrind on start. For example, to fail 50% of the time:</para>
+
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --syscall-fail-chance=50 ./my_prog
+
+==15526== Failgrind, a memory allocation and syscall failure testing tool
+==15526== NOTE: This is an Experimental-Class Valgrind Tool
+==15526== Copyright (C) 2018-2021, and GNU GPL'd, by Roger Light.
+==15526== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info
+==15526== Command: ./my_prog
+==15526==
+==15526== Using random seed: 7937841
+...
+]]></screen>
+</sect3>
+
+</sect2>
+
+</sect1>
+
+<sect1 id="fg-manual.options" xreflabel="Failgrind Command-line Options">
+<title>Failgrind Command-line Options</title>
+
+<para>Failgrind-specific command-line options are:</para>
+
+<!-- start of xi:include in the manpage -->
+<variablelist id="fg.opts.list">
+
+  <varlistentry id="opt.alloc-allow" xreflabel="--alloc-allow">
+    <term>
+      <option><![CDATA[--alloc-allow=<function> ]]></option>
+    </term>
+    <listitem>
+      <para>Use this option to allow the named memory allocation function to
+      succeed regardless of what other settings are being used. Can be
+      specified multiple times.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.alloc-fail-atstart" xreflabel="--alloc-fail-atstart">
+    <term>
+      <option><![CDATA[--alloc-fail-atstart=yes|no [default: yes] ]]></option>
+    </term>
+    <listitem>
+      <para>Control whether memory allocation will start to fail immediately
+      that the program being tested is launched. Defaults to
+      <option>no</option> when <option>--alloc-toggle</option> is in
+      use.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.alloc-fail-chance" xreflabel="--alloc-fail-chance">
+    <term>
+      <option><![CDATA[--alloc-fail-chance=<number> [default: 100] ]]></option>
+    </term>
+    <listitem>
+      <para>The default operation of Failgrind is to reject all memory
+      allocations when a call stack is seen for the first time. Set this
+      option to 1-100 to act as the percentage chance that an allocation
+      that is due to be rejected will actually be rejected. Using this
+      option makes your testing non-deterministic.</para>
+      <para>See also the <option>--seed</option> option.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.alloc-max-fails" xreflabel="--alloc-max-fails">
+    <term>
+      <option><![CDATA[--alloc-max-fails=<number> [default: 0 (unlimited)] ]]></option>
+    </term>
+    <listitem>
+        <para>By default, any number of failures is possible in a single
+        Failgrind run. The <option>--alloc-max-fails</option> option allows you
+        to tweak this behaviour. Setting this to a positive integer n means
+        that only the first n times that Failgrind would reject a memory
+        allocation will actually be rejected. After the number of failures
+        reaches this limit, any further allocations that would otherwise have
+        failed will succeed and they will not be recorded in the callstack file
+        so a subsequent run may trigger them to fail.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.alloc-threshold-high" xreflabel="--alloc-threshold-high">
+    <term>
+      <option><![CDATA[--alloc-threshold-high=<bytes> ]]></option>
+    </term>
+    <listitem>
+      <para>If set, allocations larger than "bytes" will never be failed.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.alloc-threshold-invert" xreflabel="--alloc-threshold-invert">
+    <term>
+      <option><![CDATA[--alloc-threshold-invert=yes|no [default: no] ]]></option>
+    </term>
+    <listitem>
+      <para>Invert the sense of <option>--alloc-threshold-high</option> and
+      <option>--alloc-threshold-low</option>. This means that only
+      allocations smaller than "high" and larger than "low" will be
+      failed.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.alloc-threshold-low" xreflabel="--alloc-threshold-low">
+    <term>
+      <option><![CDATA[--alloc-threshold-low=<bytes> ]]></option>
+    </term>
+    <listitem>
+      <para>If set, allocations smaller than "bytes" will never be failed.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.alloc-toggle" xreflabel="--alloc-toggle">
+    <term>
+      <option><![CDATA[--alloc-toggle=<function>]]></option>
+    </term>
+    <listitem>
+      <para>This option allows you to specify functions where the behaviour of
+      Failgrind will be toggled on entry to and exit from that function. This
+      means you can control which parts of your program are being tested by
+      Failgrind.</para> <para>For example, if you were running a test suite
+      with some setup, you might not want the setup to run under Failgrind.
+      Using <option>--alloc-fail-atstart=no</option> would start Failgrind with
+      heap allocation failures disabled, and using
+      <option>--alloc-toggle=test_suite</option> would enable allocation
+      failures when entering the function test_suite(), then disable them when
+      returning.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.callstack-input" xreflabel="--callstack-input">
+    <term>
+      <option><![CDATA[--callstack-input=no|<filename> [default: failgrind.callstacks] ]]></option>
+    </term>
+    <listitem>
+      <para>This file contains details of call stacks that should always be
+      allowed to succeed, such as those recorded from a previous run of
+      Failgrind. The contents will be loaded when Failgrind starts.</para>
+      <para>Set to "no" to disable loading of callstacks.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.callstack-output" xreflabel="--callstack-output">
+    <term>
+      <option><![CDATA[--callstack-output=no|<filename> [default: failgrind.callstacks] ]]></option>
+    </term>
+    <listitem>
+      <para>When Failgrind causes a memory allocation to fail, it will keep track
+      of the call stack in memory and write it to this file, so that it can be used
+      in a subsequent Failgrind run.</para>
+      <para>Set to "no" to disable loading of callstacks.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.failgrind-stats" xreflabel="--failgrind-stats">
+    <term>
+      <option><![CDATA[--failgrind-stats=yes|no [default: yes] ]]></option>
+    </term>
+    <listitem>
+      <para>At the end of the run, Failgrind presents some simple
+      information on the number of call stacks loaded from the callstack file,
+      the number of allocations that succeeded, and the number of allocations
+      that were made to fail. This can be disabled by setting
+      <varname>--failgrind-stats</varname> to no.</para>
+    </listitem>
+  </varlistentry>
+
+
+  <varlistentry id="opt.seed" xreflabel="--seed">
+    <term>
+      <option><![CDATA[--seed=<number>]]></option>
+    </term>
+    <listitem>
+      <para>If <option>--alloc-fail-chance</option> or
+      <option>--syscall-fail-chance</option> is set to less than 100,
+      then this option allows you to specify the seed for the valgrind
+      random number generator, which allows runs of your program to be
+      repeated exactly the same way multiple times. If not specified,
+      then a seed will be generated based on the valgrind process ID. The
+      seed being used will be printed to screen when Failgrind starts and
+      <option>--alloc-fail-chance</option> or
+      <option>--syscall-fail-chance</option> is less than 100.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.show-failed" xreflabel="--show-failed">
+    <term>
+      <option><![CDATA[--show-failed=yes|no [default: no] ]]></option>
+    </term>
+    <listitem>
+      <para>If this option is set to yes, then each time a memory allocation or
+      syscall is denied, a call stack will be printed to the screen.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.syscall-allow" xreflabel="--syscall-allow">
+    <term>
+      <option><![CDATA[--syscall-allow=<function> ]]></option>
+    </term>
+    <listitem>
+      <para>Use this option to allow the named syscall to succeed regardless
+      of what other settings are being used. This is particularly useful
+      when debugging using printf, for example, to ensure that the
+      "write" syscall always succeeds. Can be specified multiple
+      times.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.syscall-fail-atstart" xreflabel="--syscall-fail-atstart">
+    <term>
+      <option><![CDATA[--syscall-fail-atstart=yes|no [default: no] ]]></option>
+    </term>
+    <listitem>
+      <para>Control whether syscalls will start to fail immediately
+      that the program being tested is launched. Defaults to
+      <option>no</option>.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.syscall-fail-chance" xreflabel="--syscall-fail-chance">
+    <term>
+      <option><![CDATA[--syscall-fail-chance=<number> [default: 100] ]]></option>
+    </term>
+    <listitem>
+      <para>The default operation of Failgrind is to reject all syscalls
+      when a call stack is seen for the first time, if enabled. Set this
+      option to 1-100 to act as the percentage chance that a syscall
+      that is due to be rejected will actually be rejected. Using this
+      option makes your testing non-deterministic.</para>
+      <para>See also the <option>--seed</option> option.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.syscall-errno" xreflabel="--syscall-errno">
+    <term>
+      <option><![CDATA[--syscall-errno=<error> ]]></option>
+      <option><![CDATA[--syscall-errno=<function>,<error> ]]></option>
+    </term>
+    <listitem>
+      <para>This option allows you to control the error returned from
+      syscalls instead of the default value of EINVAL. There are two
+      forms for this argument. The first is
+      <option>--syscall-errno=&lt;errno&gt;</option>. This changes the
+      "global" error value used for all syscalls unless otherwise
+      specified. The second form of this argument is
+      <option>--syscall-errno=&lt;function&gt;,&lt;errno&gt;</option>.
+      This allows the error to be used for a particular syscall. For
+      example, you may wish to check how your use of the open() call
+      copes with a "permission denied" error:
+      <option>--syscall-errno=open,EACCES</option>.</para>
+
+      <para>Use in conjunction with <option>--syscall-specified-only</option>
+      to restrict your syscall failure testing to specific syscalls.</para>
+
+      <para>A platform specific list of errors supported is given in
+      <xref linkend="fg-manual.errnos"/>.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.syscall-max-fails" xreflabel="--syscall-max-fails">
+    <term>
+      <option><![CDATA[--syscall-max-fails=<number> [default: 0 (unlimited)] ]]></option>
+    </term>
+    <listitem>
+      <para>By default, any number of failures is possible in a single Failgrind
+      run. The <option>--syscall-max-fails</option> option allows you to tweak
+      this behaviour. Setting this to a positive integer n means that only the
+      first n times that Failgrind would reject a syscall will actually be
+      rejected. After the number of failures reaches this limit, any further
+      syscalls that would otherwise have failed will succeed and they will not
+      be recorded in the callstack file so a subsequent run may trigger them to
+      fail.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.syscall-specified-only" xreflabel="--syscall-specified-only">
+    <term>
+      <option><![CDATA[--syscall-specified-only=yes|no [default: no] ]]></option>
+    </term>
+    <listitem>
+      <para>Setting this option to yes means that only syscalls that are specified with
+      <option>--syscall-errno=&lt;function&gt;,&lt;errno&gt;</option> will
+      be considered for failure. If this option is set to no, then
+      functions specified with <option>--syscall-errno</option> will be
+      failed with their specific error and all other syscalls will be
+      failed with the "global" error, which defaults to EINVAL, but that
+      can also be changed with <option>--syscall-errno</option>.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.syscall-toggle" xreflabel="--syscall-toggle">
+    <term>
+      <option><![CDATA[--syscall-toggle=<function>]]></option>
+    </term>
+    <listitem>
+      <para>This option allows you to specify functions where the behaviour of
+      Failgrind will be toggled on entry to and exit from that function. This
+      means you can control which parts of your program are being tested by
+      Failgrind.</para> <para>For example, if you were running a test suite with
+      some setup, you might not want the setup to run under Failgrind.  Using
+      <option>--syscall-fail-atstart=no</option> would start Failgrind with
+      syscall failures disabled, and using
+      <option>--syscall-toggle=test_suite</option> would enable syscall failures
+      when entering the function test_suite(), then disable them when
+      returning.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="opt.write-callstacks-at-end" xreflabel="--write-callstacks-at-end">
+    <term>
+      <option><![CDATA[--write-callstacks-at-end=yes|no [default: no]]]></option>
+    </term>
+    <listitem>
+      <para>Set to yes to write the callstack output file when Failgrind
+      exits. This creates a new file and only contains the callstacks
+      that are currently in memory. Set to no to have each new callstack
+      appended to the output file immediately. This produces a file that
+      contains every callstack seen by Failgrind, and may contain
+      duplicates if the <option>alloc_clear</option> monitor option, or
+      <option>FAILGRIND_ALLOC_CLEAR</option> client request is used for
+      example.</para>
+    </listitem>
+  </varlistentry>
+</variablelist>
+<!-- end of xi:include in the manpage -->
+
+</sect1>
+
+<sect1 id="fg-manual.monitor-commands" xreflabel="Failgrind Monitor Commands">
+<title>Failgrind Monitor Commands</title>
+
+<para>The Failgrind tool provides monitor commands handled by the Valgrind
+gdbserver (see <xref linkend="manual-core-adv.gdbserver-commandhandling"/>).
+</para>
+
+<itemizedlist>
+  <listitem>
+    <para><varname>alloc_fail [on|off]</varname> get or set (if on/off given)
+    whether memory allocation failures are enabled.</para>
+  </listitem>
+
+  <listitem>
+    <para><varname>callstack_append &lt;file&gt;</varname> will cause the
+    in-memory list of call stacks to be written to <option>file</option>.
+    Appends to an existing file.</para>
+  </listitem>
+
+  <listitem>
+    <para><varname>callstack_clear</varname> will clear the in-memory list of
+    call stacks that have been seen. This means that if any of these call
+    stacks are seen again, the allocation or syscall will be rejected by
+    Failgrind.</para>
+  </listitem>
+
+  <listitem>
+    <para><varname>callstack_read &lt;file&gt;</varname> will read the
+    file of stored call stacks into memory. Call stacks already
+    in memory will not be affected.</para>
+  </listitem>
+
+  <listitem>
+    <para><varname>callstack_write &lt;file&gt;</varname> will cause the
+    in-memory list of call stacks to be written to <option>file</option>.
+    Creates a new file. This may be useful if you have configured Failgrind
+    to not write an output file for your run.</para>
+  </listitem>
+
+  <listitem>
+    <para><varname>print_stats</varname> requests that the heap allocation
+    success/failure counts are printed to the gdb monitor, then zeros them.
+    These counts are only updated when heap memory allocation failure is
+    enabled, i.e. Failgrind is operating as normal.</para>
+  </listitem>
+
+  <listitem>
+    <para><varname>syscall_fail [on|off]</varname> get or set (if on/off given)
+    whether syscall failures are enabled.</para>
+  </listitem>
+
+  <listitem>
+    <para><varname>zero_stats</varname> sets the heap allocation
+    success/failure counts to 0.</para>
+  </listitem>
+</itemizedlist>
+
+</sect1>
+
+<sect1 id="fg-manual.clientrequests" xreflabel="Client request reference">
+<title>Failgrind specific client requests</title>
+
+<sect2 id="fg-manual.clientrequests.list" xreflabel="Client request list">
+<title>Client request list</title>
+
+<para>Failgrind provides the following specific client requests in
+<filename>failgrind.h</filename>.</para>
+
+<variablelist id="fg.clientrequests.list">
+
+  <varlistentry id="fg.alloc-fail-on" xreflabel="FAILGRIND_ALLOC_FAIL_ON">
+    <term>
+      <computeroutput>FAILGRIND_ALLOC_FAIL_ON</computeroutput>
+    </term>
+    <listitem>
+      <para>Enable heap allocation failures. This is the default mode of
+      operation for Failgrind. Use in conjunction with
+      <option>--alloc-fail-atstart</option> to control which parts of your
+      program are tested by Failgrind.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.alloc-fail-off" xreflabel="FAILGRIND_ALLOC_FAIL_OFF">
+    <term>
+      <computeroutput>FAILGRIND_ALLOC_FAIL_OFF</computeroutput>
+    </term>
+    <listitem>
+      <para>Disable heap allocation failures. When you have used this
+      request, Failgrind will not influence any memory
+      allocations.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.alloc-fail-toggle" xreflabel="FAILGRIND_ALLOC_FAIL_TOGGLE">
+    <term>
+      <computeroutput>FAILGRIND_ALLOC_FAIL_TOGGLE</computeroutput>
+    </term>
+    <listitem>
+      <para>Toggle the enabled/disabled state of heap allocation
+      failures.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.alloc-get-fail-count" xreflabel="FAILGRIND_ALLOC_GET_FAIL_COUNT">
+    <term>
+      <computeroutput>FAILGRIND_ALLOC_GET_FAIL_COUNT</computeroutput>
+    </term>
+    <listitem>
+      <para>Return the count of heap memory allocations that have been failed
+      by Failgrind.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.alloc-get-new-callstack-count" xreflabel="FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT">
+    <term>
+      <computeroutput>FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT</computeroutput>
+    </term>
+    <listitem>
+      <para>Return the count of heap memory allocation callstacks that have
+      not been seen before. In the normal mode of operation this will be
+      the same as
+      <option>FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT</option>. If you use
+      <option>--alloc-fail-chance</option> or <option>--alloc-max-fails</option> then
+      this tells you the number of allocations that could have been
+      failed, but may not have been. For example, if you decide to set
+      <option>--alloc-max-fails</option>, then run a program that makes three
+      different memory allocations, you would expect
+      <option>FAILGRIND_ALLOC_GET_FAIL_COUNT=1</option> and
+      <option>FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT=3</option>. If this
+      client request returns 0, you know that all memory allocations have
+      been seen before for this particular test.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.alloc-get-success-count" xreflabel="FAILGRIND_ALLOC_GET_SUCCESS_COUNT">
+    <term>
+      <computeroutput>FAILGRIND_ALLOC_GET_SUCCESS_COUNT</computeroutput>
+    </term>
+    <listitem>
+      <para>Return the count of heap memory allocations that have succeeded
+      through Failgrind.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.callstack-append" xreflabel="FAILGRIND_CALLSTACK_APPEND">
+    <term>
+      <computeroutput>FAILGRIND_CALLSTACK_APPEND("file")</computeroutput>
+    </term>
+    <listitem>
+      <para>Write the in-memory list of stored call stacks to a file. This
+      appends to an existing file.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.callstack-clear" xreflabel="FAILGRIND_CALLSTACK_CLEAR">
+    <term>
+      <computeroutput>FAILGRIND_CALLSTACK_CLEAR</computeroutput>
+    </term>
+    <listitem>
+      <para>Clear the in-memory list of stored call stacks (i.e. after making
+      this request, if a call stack that had been seen before is seen
+      again, it will fail again). If you use this request and have Failgrind
+      configured to write callstacks to a file, then you will get duplicate
+      entries unless you use the <option>--write-callstacks-at-end=yes</option>
+      command line argument.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.callstack-read" xreflabel="FAILGRIND_CALLSTACK_READ">
+    <term>
+      <computeroutput>FAILGRIND_CALLSTACK_READ("file")</computeroutput>
+    </term>
+    <listitem>
+      <para>Read a file of stored call stacks into memory. This will append the
+      call stacks to those that are currently loaded.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.callstack-write" xreflabel="FAILGRIND_CALLSTACK_WRITE">
+    <term>
+      <computeroutput>FAILGRIND_CALLSTACK_WRITE("file")</computeroutput>
+    </term>
+    <listitem>
+      <para>Write the in-memory list of stored call stacks to a file. This
+      creates a new file.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.syscall-fail-on" xreflabel="FAILGRIND_SYSCALL_FAIL_ON">
+    <term>
+      <computeroutput>FAILGRIND_SYSCALL_FAIL_ON</computeroutput>
+    </term>
+    <listitem>
+      <para>Enable syscall failures. Syscall failures are disabled by default
+      in Failgrind. Use in conjunction with
+      <option>--syscall-fail-atstart</option> to control which parts of
+      your program are tested by Failgrind.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.syscall-fail-off" xreflabel="FAILGRIND_SYSCALL_FAIL_OFF">
+    <term>
+      <computeroutput>FAILGRIND_SYSCALL_FAIL_OFF</computeroutput>
+    </term>
+    <listitem>
+      <para>Disable syscalls failures. When you have used this
+      request, Failgrind will not influence any syscalls.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.syscall-fail-toggle" xreflabel="FAILGRIND_SYSCALL_FAIL_TOGGLE">
+    <term>
+      <computeroutput>FAILGRIND_SYSCALL_FAIL_TOGGLE</computeroutput>
+    </term>
+    <listitem>
+      <para>Toggle the enabled/disabled state of syscall failures.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.syscall-get-fail-count" xreflabel="FAILGRIND_SYSCALL_GET_FAIL_COUNT">
+    <term>
+      <computeroutput>FAILGRIND_SYSCALL_GET_FAIL_COUNT</computeroutput>
+    </term>
+    <listitem>
+      <para>Return the count of syscalls that have been failed by Failgrind.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.syscall-get-new-callstack-count" xreflabel="FAILGRIND_SYSCALL_GET_NEW_CALLSTACK_COUNT">
+    <term>
+      <computeroutput>FAILGRIND_SYSCALL_GET_NEW_CALLSTACK_COUNT</computeroutput>
+    </term>
+    <listitem>
+      <para>Return the count of syscall callstacks that have not been seen
+      before. In the normal mode of operation this will be the same as
+      <option>FAILGRIND_SYSCALL_GET_NEW_CALLSTACK_COUNT</option>. If you use
+      <option>--syscall-fail-chance</option> or
+      <option>--syscall-max-fails</option> then this tells you the number
+      of syscalls that could have been failed, but may not have been. For
+      example, if you decide to set <option>--syscall-max-fails</option>,
+      then run a program that makes three different syscalls, you would
+      expect <option>FAILGRIND_SYSCALL_GET_FAIL_COUNT=1</option> and
+      <option>FAILGRIND_SYSCALL_GET_NEW_CALLSTACK_COUNT=3</option>. If this
+      client request returns 0, you know that all syscalls have been seen
+      before for this particular test.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.syscall-get-success-count" xreflabel="FAILGRIND_SYSCALL_GET_SUCCESS_COUNT">
+    <term>
+      <computeroutput>FAILGRIND_SYSCALL_GET_SUCCESS_COUNT</computeroutput>
+    </term>
+    <listitem>
+      <para>Return the count of syscalls that have succeeded through Failgrind.</para>
+    </listitem>
+  </varlistentry>
+
+  <varlistentry id="fg.zero-counts" xreflabel="FAILGRIND_ZERO_COUNTS">
+    <term>
+      <computeroutput>FAILGRIND_ZERO_COUNTS</computeroutput>
+    </term>
+    <listitem>
+      <para>Set the success/fail counts to zero.</para>
+    </listitem>
+  </varlistentry>
+</variablelist>
+</sect2>
+
+<sect2 id="fg-manual.clientrequests.example" xreflabel="Client request example">
+<title>Example</title>
+
+<para>This example shows how you could use the Failgrind client requests to
+provide complete checking of a test suite compiled in the program
+<computeroutput>prog</computeroutput>.</para>
+
+<para>Run Failgrind as follows to disable memory allocation failures on
+startup, and to not read/write any callstack files:</para>
+<screen><![CDATA[
+valgrind --tool=exp-failgrind --alloc-fail-atstart=no --callstack-input=no --callstack-output=no prog
+]]></screen>
+
+<para>The program listing:</para>
+<programlisting><![CDATA[
+ 1      #include <failgrind.h>
+ 2      #include <test_funcs.h>
+ 3
+ 4      int main(int argc, char* argv[])
+ 5      {
+ 6         setup_test_suite();
+ 7
+ 8         do {
+ 9            FAILGRIND_ALLOC_ZERO_COUNTS;
+10            FAILGRIND_ALLOC_FAIL_ON;
+11            run_test1();
+12            FAILGRIND_ALLOC_FAIL_OFF;
+13         } while(FAILGRIND_ALLOC_GET_FAIL_COUNT > 0);
+14         FAILGRIND_CALLSTACK_CLEAR;
+15
+16         do {
+17            FAILGRIND_ZERO_COUNTS;
+18            FAILGRIND_ALLOC_FAIL_ON;
+19            run_test2();
+20            FAILGRIND_ALLOC_FAIL_OFF;
+21         } while(FAILGRIND_ALLOC_GET_FAIL_COUNT > 0);
+22         FAILGRIND_CALLSTACK_CLEAR;
+23
+24         cleanup_test_suite();
+25         return 0;
+26      }
+]]></programlisting>
+
+<para>Or with a helper function with a callback for the test to avoid code duplication:</para>
+<programlisting><![CDATA[
+ 1      #include <failgrind.h>
+ 2      #include <test_funcs.h>
+ 3
+ 4      void fg_test(void (*test)(void)){
+ 5         FAILGRIND_CALLSTACK_CLEAR;
+ 6         do {
+ 7            FAILGRIND_ZERO_COUNTS;
+ 8            FAILGRIND_ALLOC_FAIL_ON;
+ 9            test();
+10            FAILGRIND_ALLOC_FAIL_OFF;
+11         } while(FAILGRIND_ALLOC_GET_FAIL_COUNT > 0);
+12      }
+13
+14      int main(int argc, char* argv[])
+15      {
+16         setup_test_suite();
+17
+18         fg_test(run_test1);
+19         fg_test(run_test2);
+20
+21         cleanup_test_suite();
+22         return 0;
+23      }
+]]></programlisting>
+
+
+</sect2>
+</sect1>
+
+<sect1 id="fg-manual.errnos">
+<title>Syscall errors</title>
+<para>This section lists the different platform specific error values that can
+be used with the <option>--syscall-errno</option> option.</para>
+<sect2>
+<title>Linux</title>
+<para>
+<screen>
+E2BIG EACCES EAGAIN EBADF EBUSY ECHILD
+EDOM EEXIST EFAULT EFBIG EINTR EINVAL
+EIO EISDIR EMFILE EMLINK ENFILE ENODEV
+ENOENT ENOEXEC ENOMEM ENOSPC ENOSYS
+ENOTBLK ENOTDIR ENOTTY ENXIO EOVERFLOW
+EPERM EPIPE ERANGE EROFS ESPIPE ESRCH
+ETXTBSY EWOULDBLOCK EXDEV
+</screen>
+</para>
+</sect2>
+
+<sect2>
+<title>Mac OS X</title>
+<para>
+<screen>
+E2BIG EACCES EADDRINUSE EADDRNOTAVAIL
+EAFNOSUPPORT EAGAIN EALREADY EAUTH
+EBADARCH EBADEXEC EBADF EBADMACHO
+EBADMSG EBADRPC EBUSY ECANCELED ECHILD
+ECONNABORTED ECONNREFUSED ECONNRESET
+EDEADLK EDESTADDRREQ EDEVERR EDOM
+EDQUOT EEXIST EFAULT EFBIG EFTYPE
+EHOSTDOWN EHOSTUNREACH EIDRM EILSEQ
+EINPROGRESS EINTR EINVAL EIO EISCONN
+EISDIR ELAST ELOOP EMFILE EMLINK
+EMSGSIZE EMULTIHOP ENAMETOOLONG
+ENEEDAUTH ENETDOWN ENETRESET
+ENETUNREACH ENFILE ENOATTR ENOBUFS
+ENODATA ENODEV ENOENT ENOEXEC ENOLCK
+ENOLINK ENOMEM ENOMSG ENOPROTOOPT
+ENOSPC ENOSR ENOSTR ENOSYS ENOTBLK
+ENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK
+ENOTSUP ENOTTY ENXIO EOPNOTSUPP
+EOVERFLOW EPERM EPFNOSUPPORT EPIPE
+EPROCLIM EPROCUNAVAIL EPROGMISMATCH
+EPROGUNAVAIL EPROTO EPROTONOSUPPORT
+EPROTOTYPE EPWROFF ERANGE EREMOTE
+EROFS ERPCMISMATCH ESHLIBVERS
+ESHUTDOWN ESOCKTNOSUPPORT ESPIPE
+ESRCH ESTALE ETIME ETIMEDOUT
+ETOOMANYREFS ETXTBSY EUSERS EXDEV
+</screen>
+
+</para>
+</sect2>
+
+<sect2>
+<title>Solaris</title>
+<para>
+<screen>
+E2BIG EACCES EADDRINUSE EAGAIN EBADF EBUSY
+ECHILD EDOM EEXIST EFAULT EFBIG EINTR
+EINVAL EIO EISDIR EMFILE EMLINK ENFILE
+ENODATA ENODEV ENOENT ENOEXEC ENOMEM
+ENOSPC ENOSYS ENOTBLK ENOTDIR ENOTSUP
+ENOTTY ENXIO EOVERFLOW EPERM EPIPE ERANGE
+ERESTART EROFS ESPIPE ESRCH ETXTBSY EXDEV
+</screen>
+</para>
+</sect2>
+
+</sect1>
+
+<sect1>
+<title>Limitations</title>
+
+<itemizedlist>
+  <listitem><para>Failgrind simply decides whether an allocation should
+  fail or succeed. It does not attempt to determine whether illegal memory
+  accesses occur after a memory allocation failure.</para></listitem>
+
+  <listitem><para>Call stack files are probably unique to the particular build
+  of an executable, so making changes could mean extensive
+  retesting.</para></listitem>
+</itemizedlist>
+</sect1>
+
+
+</chapter>
diff --git a/exp-failgrind/failgrind.h b/exp-failgrind/failgrind.h
new file mode 100644
index 000000000..ffc719af1
--- /dev/null
+++ b/exp-failgrind/failgrind.h
@@ -0,0 +1,185 @@
+/*
+   ----------------------------------------------------------------
+
+   Notice that the following BSD-style license applies to this one
+   file (failgrind.h) only.  The rest of Valgrind is licensed under the
+   terms of the GNU General Public License, version 2, unless
+   otherwise indicated.  See the COPYING file in the source
+   distribution for details.
+
+   ----------------------------------------------------------------
+
+   This file is part of Failgrind, a Valgrind tool for testing program
+   behaviour when heap allocations or syscalls fail.
+
+   Copyright (C) 2018-2021 Roger Light.  All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+   2. The origin of this software must not be misrepresented; you must
+      not claim that you wrote the original software.  If you use this
+      software in a product, an acknowledgment in the product
+      documentation would be appreciated but is not required.
+
+   3. Altered source versions must be plainly marked as such, and must
+      not be misrepresented as being the original software.
+
+   4. The name of the author may not be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+   ----------------------------------------------------------------
+
+   Notice that the above BSD-style license applies to this one file
+   (failgrind.h) only.  The entire rest of Valgrind is licensed under
+   the terms of the GNU General Public License, version 2.  See the
+   COPYING file in the source distribution for details.
+
+   ----------------------------------------------------------------
+*/
+
+#ifndef __FAILGRIND_H
+#define __FAILGRIND_H
+
+#include "valgrind.h"
+
+/* !! ABIWARNING !! ABIWARNING !! ABIWARNING !! ABIWARNING !!
+   This enum comprises an ABI exported by Valgrind to programs
+   which use client requests.  DO NOT CHANGE THE ORDER OF THESE
+   ENTRIES, NOR DELETE ANY -- add new ones at the end.
+ */
+
+typedef
+   enum {
+      VG_USERREQ__FG_ALLOC_FAIL_ON = VG_USERREQ_TOOL_BASE('F','G'),
+      VG_USERREQ__FG_ALLOC_FAIL_OFF,
+      VG_USERREQ__FG_ALLOC_FAIL_TOGGLE,
+      VG_USERREQ__FG_ALLOC_GET_FAIL_COUNT,
+      VG_USERREQ__FG_ALLOC_GET_SUCCESS_COUNT,
+      VG_USERREQ__FG_ALLOC_GET_NEW_CALLSTACK_COUNT,
+      VG_USERREQ__FG_CALLSTACK_APPEND,
+      VG_USERREQ__FG_CALLSTACK_CLEAR,
+      VG_USERREQ__FG_CALLSTACK_READ,
+      VG_USERREQ__FG_CALLSTACK_WRITE,
+      VG_USERREQ__FG_SYSCALL_FAIL_ON,
+      VG_USERREQ__FG_SYSCALL_FAIL_OFF,
+      VG_USERREQ__FG_SYSCALL_FAIL_TOGGLE,
+      VG_USERREQ__FG_SYSCALL_GET_FAIL_COUNT,
+      VG_USERREQ__FG_SYSCALL_GET_SUCCESS_COUNT,
+      VG_USERREQ__FG_SYSCALL_GET_NEW_CALLSTACK_COUNT,
+      VG_USERREQ__FG_ZERO_COUNTS,
+   } Vg_FailgrindClientRequest;
+
+/* Enable heap allocation failures. */
+#define FAILGRIND_ALLOC_FAIL_ON                                 \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_ALLOC_FAIL_ON, \
+                                  0, 0, 0, 0, 0)
+
+/* Disable heap allocation failures. */
+#define FAILGRIND_ALLOC_FAIL_OFF                                \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_ALLOC_FAIL_OFF,\
+                                  0, 0, 0, 0, 0)
+
+/* Toggle heap allocation failures enable/disable state. */
+#define FAILGRIND_ALLOC_FAIL_TOGGLE                             \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_ALLOC_FAIL_TOGGLE,\
+                                  0, 0, 0, 0, 0)
+
+/* Return the count of heap memory allocations that have been failed
+ * through Failgrind. */
+#define FAILGRIND_ALLOC_GET_FAIL_COUNT                          \
+  (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
+          VG_USERREQ__FG_ALLOC_GET_FAIL_COUNT, 0, 0, 0, 0, 0)
+
+/* Return the count of new heap memory allocation callstacks that have been
+ * found on this run. This count will be the same as
+ * FAILGRIND_ALLOC_GET_FAIL_COUNT in normal operation, but gives a better count
+ * for the situation where --alloc-max-fails or --alloc-fail-chance are being used. */
+#define FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT            \
+  (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
+          VG_USERREQ__FG_ALLOC_GET_NEW_CALLSTACK_COUNT, 0, 0, 0, 0, 0)
+
+/* Return the count of heap memory allocations that have succeeded
+ * through Failgrind. */
+#define FAILGRIND_ALLOC_GET_SUCCESS_COUNT                       \
+  (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
+          VG_USERREQ__FG_ALLOC_GET_SUCCESS_COUNT, 0, 0, 0, 0, 0)
+
+/* Clear the in-memory list of stored call stacks (i.e. after calling
+ * this, if a call stack that had been seen before is seen again, it
+ * will fail again) */
+#define FAILGRIND_CALLSTACK_CLEAR                                   \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_CALLSTACK_CLEAR,   \
+                                  0, 0, 0, 0, 0)
+
+/* Load a file of stored call stacks into memory. */
+#define FAILGRIND_CALLSTACK_READ(fname)                             \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_CALLSTACK_READ,\
+                                  fname, 0, 0, 0, 0)
+
+/* Writes the in-memory list of stored call stacks to a new file. */
+#define FAILGRIND_CALLSTACK_WRITE(fname)                            \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_CALLSTACK_WRITE,\
+                                  fname, 0, 0, 0, 0)
+
+/* Appends the in-memory list of stored call stacks to an existing file. */
+#define FAILGRIND_CALLSTACK_APPEND(fname)                                \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_CALLSTACK_APPEND,      \
+                                  fname, 0, 0, 0, 0)
+
+/* Enable syscall failures. */
+#define FAILGRIND_SYSCALL_FAIL_ON                                 \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_SYSCALL_FAIL_ON, \
+                                  0, 0, 0, 0, 0)
+
+/* Disable syscall failures. */
+#define FAILGRIND_SYSCALL_FAIL_OFF                                \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_SYSCALL_FAIL_OFF,\
+                                  0, 0, 0, 0, 0)
+
+/* Toggle syscall failures enable/disable state. */
+#define FAILGRIND_SYSCALL_FAIL_TOGGLE                             \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__FG_SYSCALL_FAIL_TOGGLE,\
+                                  0, 0, 0, 0, 0)
+
+/* Return the count of syscalls that have been failed through Failgrind. */
+#define FAILGRIND_SYSCALL_GET_FAIL_COUNT                          \
+  (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
+          VG_USERREQ__FG_SYSCALL_GET_FAIL_COUNT, 0, 0, 0, 0, 0)
+
+/* Return the count of new syscall callstacks that have been found on this run.
+ * This count will be the same as FAILGRIND_SYSCALL_GET_FAIL_COUNT in normal
+ * operation, but gives a better count for the situation where
+ * --syscall-max-fails or --syscall-fail-chance are being used. */
+#define FAILGRIND_SYSCALL_GET_NEW_CALLSTACK_COUNT            \
+  (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
+          VG_USERREQ__FG_SYSCALL_GET_NEW_CALLSTACK_COUNT, 0, 0, 0, 0, 0)
+
+/* Return the count of syscall that have succeeded through Failgrind. */
+#define FAILGRIND_SYSCALL_GET_SUCCESS_COUNT                       \
+  (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
+          VG_USERREQ__FG_SYSCALL_GET_SUCCESS_COUNT, 0, 0, 0, 0, 0)
+
+/* Zero the fail/success heap memory allocation and syscall counts. */
+#define FAILGRIND_ZERO_COUNTS                             \
+  VALGRIND_DO_CLIENT_REQUEST_STMT(                              \
+         VG_USERREQ__FG_ZERO_COUNTS, 0, 0, 0, 0, 0)
+
+#endif /* __FAILGRIND_H */
diff --git a/exp-failgrind/fg_alloc.c b/exp-failgrind/fg_alloc.c
new file mode 100644
index 000000000..2bbd7ca92
--- /dev/null
+++ b/exp-failgrind/fg_alloc.c
@@ -0,0 +1,259 @@
+//--------------------------------------------------------------------*/
+//--- Failgrind: a memory allocation failure testing tool          ---*/
+//--------------------------------------------------------------------*/
+
+/*
+   This file is part of Failgrind, a Valgrind tool for testing program
+   behaviour when heap allocations or syscalls fail.
+
+   Copyright (C) 2018-2021 Roger Light.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+/* Contributed by Roger Light <roger@atchoo.org> */
+
+
+#include "pub_tool_basics.h"
+#include "pub_tool_clientstate.h"
+#include "pub_tool_gdbserver.h"
+#include "pub_tool_hashtable.h"
+#include "pub_tool_libcbase.h"
+#include "pub_tool_libcassert.h"
+#include "pub_tool_libcfile.h"
+#include "pub_tool_libcprint.h"
+#include "pub_tool_libcproc.h"
+#include "pub_tool_machine.h"
+#include "pub_tool_mallocfree.h"
+#include "pub_tool_options.h"
+#include "pub_tool_poolalloc.h"
+#include "pub_tool_replacemalloc.h"
+#include "pub_tool_stacktrace.h"
+#include "pub_tool_threadstate.h"
+#include "pub_tool_tooliface.h"
+#include "pub_tool_vki.h"
+
+#include "valgrind.h"
+#include "failgrind.h"
+#include "fg_global.h"
+
+static Bool should_alloc_fail(ThreadId tid, UWord *ips, UInt *n_ips, SizeT size);
+
+/* Creates a callstack and ECU for the current context, then checks whether it
+ * already exists in our hash table. If it exists, the allocation should not
+ * fail. */
+static Bool should_alloc_fail(ThreadId tid, UWord *ips, UInt *n_ips, SizeT size)
+{
+   ExeContext *exe;
+   UInt ecu;
+   const HChar* fnname;
+
+   /* Check for global disable */
+   if (!FG_(alloc_fail)) {
+      return False;
+   }
+
+   /* Check for size outside of thresholds */
+   if (FG_(clo_alloc_thresh_invert)) {
+      if (FG_(clo_alloc_thresh_high) != 0 && FG_(clo_alloc_thresh_low) != 0) {
+         if (size > FG_(clo_alloc_thresh_low) && size < FG_(clo_alloc_thresh_high)) {
+            return False;
+         }
+      } else {
+         if ((FG_(clo_alloc_thresh_high) != 0 && size < FG_(clo_alloc_thresh_high))
+               || (FG_(clo_alloc_thresh_low) != 0 && size > FG_(clo_alloc_thresh_low))) {
+
+            return False;
+         }
+      }
+   } else {
+      if ((FG_(clo_alloc_thresh_high) != 0 && size > FG_(clo_alloc_thresh_high))
+            || (FG_(clo_alloc_thresh_low) != 0 && size < FG_(clo_alloc_thresh_low))) {
+
+         return False;
+      }
+   }
+
+   exe = FG_(get_call_execontext)(tid, ips, n_ips);
+   ecu = VG_(get_ECU_from_ExeContext)(exe);
+
+   VG_(get_fnname)(VG_(current_DiEpoch)(), ips[0], &fnname);
+   if (FG_(alloc_allow_funcs) != NULL
+         && VG_(strIsMemberXA)(FG_(alloc_allow_funcs), fnname)) {
+
+      /* White list */
+      return False;
+   }
+
+   if (FG_(callstack_exists)(ecu)) {
+      return False;
+   } else {
+      FG_(alloc_new_callstack_count)++;
+
+      /* This test must come after the callstack_exists() check, otherwise
+       * FG_(alloc_new_callstack_count) will be wrong. */
+      if (FG_(clo_alloc_max_fails) > 0 && FG_(alloc_fail_count) >= FG_(clo_alloc_max_fails)) {
+         return False;
+      }
+
+      if (FG_(random_100)() < FG_(clo_alloc_fail_chance)) {
+         FG_(add_callstack_to_hashtable)(exe, ecu);
+         FG_(write_callstack)(ips, *n_ips);
+         return True;
+      } else {
+         return False;
+      }
+   }
+}
+
+
+//------------------------------------------------------------//
+//--- Actual memory allocation routine                     ---//
+//------------------------------------------------------------//
+
+static void* new_block(ThreadId tid, SizeT size, SizeT align, Bool is_zeroed)
+{
+   UWord ips[VG_(clo_backtrace_size)];
+   UInt n_ips;
+   void* p;
+
+   if (should_alloc_fail(tid, ips, &n_ips, size)) {
+      if (FG_(clo_print_failed_traces)) {
+         VG_(umsg)("Heap memory failure\n");
+         VG_(pp_StackTrace)(VG_(current_DiEpoch)(), ips, n_ips);
+         VG_(umsg)("\n");
+      }
+      FG_(alloc_fail_count)++;
+      return NULL;
+   }
+
+   p = VG_(cli_malloc)(align, size);
+   if (p == NULL) {
+      return NULL;
+   }
+
+   if (is_zeroed) {
+      VG_(memset)(p, 0, size);
+   }
+
+   if (FG_(alloc_fail)) {
+      FG_(alloc_success_count)++;
+   }
+   return p;
+}
+
+
+//------------------------------------------------------------//
+//--- malloc() et al replacement wrappers                  ---//
+//------------------------------------------------------------//
+
+void* FG_(malloc)(ThreadId tid, SizeT szB)
+{
+   return new_block( tid, szB, VG_(clo_alignment), /*is_zeroed*/False);
+}
+
+void* FG_(__builtin_new)(ThreadId tid, SizeT szB)
+{
+   return new_block( tid, szB, VG_(clo_alignment), /*is_zeroed*/False);
+}
+
+void* FG_(__builtin_new_aligned)(ThreadId tid, SizeT szB, SizeT alignB)
+{
+   return new_block( tid, szB, alignB, /*is_zeroed*/False);
+}
+
+void* FG_(__builtin_vec_new)(ThreadId tid, SizeT szB)
+{
+   return new_block( tid, szB, VG_(clo_alignment), /*is_zeroed*/False);
+}
+
+void* FG_(__builtin_vec_new_aligned)(ThreadId tid, SizeT szB, SizeT alignB)
+{
+   return new_block( tid, szB, alignB, /*is_zeroed*/False);
+}
+
+void* FG_(calloc)(ThreadId tid, SizeT m, SizeT szB)
+{
+   return new_block( tid, m*szB, VG_(clo_alignment), /*is_zeroed*/True);
+}
+
+void *FG_(memalign)(ThreadId tid, SizeT alignB, SizeT szB)
+{
+   return new_block( tid, szB, alignB, False);
+}
+
+void FG_(free)(ThreadId tid __attribute__((unused)), void* p)
+{
+   VG_(cli_free)(p);
+}
+
+void FG_(__builtin_delete)(ThreadId tid, void* p)
+{
+   VG_(cli_free)(p);
+}
+
+void FG_(__builtin_delete_aligned)(ThreadId tid, void* p, SizeT align)
+{
+   VG_(cli_free)(p);
+}
+
+void FG_(__builtin_vec_delete)(ThreadId tid, void* p)
+{
+   VG_(cli_free)(p);
+}
+
+void FG_(__builtin_vec_delete_aligned)(ThreadId tid, void* p, SizeT align)
+{
+   VG_(cli_free)(p);
+}
+
+void* FG_(realloc)(ThreadId tid, void* p_old, SizeT new_szB)
+{
+   SizeT actual_szB;
+   void* p_new;
+
+   if (p_old == NULL) {
+      return FG_(malloc)(tid, new_szB);
+   }
+   if (new_szB == 0) {
+      FG_(free)(tid, p_old);
+      return NULL;
+   }
+
+   actual_szB = VG_(cli_malloc_usable_size)(p_old);
+
+   if (actual_szB >= new_szB) {
+      return p_old;
+   } else {
+      p_new = new_block(tid, new_szB, VG_(clo_alignment), /*is_zeroed*/False);
+      if (p_new != NULL) {
+           VG_(memcpy)(p_new, p_old, actual_szB);
+      }
+      return p_new;
+   }
+}
+
+SizeT FG_(malloc_usable_size)(ThreadId tid, void* p)
+{
+   return VG_(cli_malloc_usable_size)(p);
+}
+
+
+//--------------------------------------------------------------------//
+//--- end                                               fg_alloc.c ---//
+//--------------------------------------------------------------------//
diff --git a/exp-failgrind/fg_callstack.c b/exp-failgrind/fg_callstack.c
new file mode 100644
index 000000000..b49f889b6
--- /dev/null
+++ b/exp-failgrind/fg_callstack.c
@@ -0,0 +1,340 @@
+//--------------------------------------------------------------------*/
+//--- Failgrind: a memory allocation failure testing tool          ---*/
+//--------------------------------------------------------------------*/
+
+/*
+   This file is part of Failgrind, a Valgrind tool for testing program
+   behaviour when heap allocations or syscalls fail.
+
+   Copyright (C) 2018-2021 Roger Light.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+/* Contributed by Roger Light <roger@atchoo.org> */
+
+
+#include "pub_tool_basics.h"
+#include "pub_tool_clientstate.h"
+#include "pub_tool_gdbserver.h"
+#include "pub_tool_hashtable.h"
+#include "pub_tool_libcbase.h"
+#include "pub_tool_libcassert.h"
+#include "pub_tool_libcfile.h"
+#include "pub_tool_libcprint.h"
+#include "pub_tool_libcproc.h"
+#include "pub_tool_machine.h"
+#include "pub_tool_mallocfree.h"
+#include "pub_tool_options.h"
+#include "pub_tool_poolalloc.h"
+#include "pub_tool_replacemalloc.h"
+#include "pub_tool_stacktrace.h"
+#include "pub_tool_threadstate.h"
+#include "pub_tool_tooliface.h"
+#include "pub_tool_vki.h"
+
+#include "valgrind.h"
+#include "failgrind.h"
+#include "fg_global.h"
+
+typedef struct _VgHashNode_callstack {
+   struct _VgHashNode_callstack *next;
+   UInt ecu;
+   ExeContext *exe;
+} VgHashNode_callstack;
+
+//------------------------------------------------------------//
+//--- Function declarations                                ---//
+//------------------------------------------------------------//
+static void add_callstack_from_file(Addr *ips, UInt n_ips);
+
+
+/* Creates a callstack and ECU for the current context */
+ExeContext *FG_(get_call_execontext)(ThreadId tid, UWord *ips, UInt *n_ips)
+{
+   Int i;
+
+   for (i = 0; i < VG_(clo_backtrace_size); i++) {
+      ips[i] = 0;
+   }
+
+   *n_ips = VG_(get_StackTrace)( tid, ips, VG_(clo_backtrace_size),
+         NULL, NULL, 0);
+
+   /* From coregrind/m_stacktrace.c */
+   if ( ! VG_(clo_show_below_main) ) {
+      DiEpoch ep = VG_(current_DiEpoch());
+      // Search (from the outer frame onwards) the appearance of "main"
+      // or the last appearance of a below main function.
+      // Then decrease n_ips so as not to consider frames below main
+      for (i = *n_ips - 1; i >= 0; i--) {
+         Vg_FnNameKind kind = VG_(get_fnname_kind_from_IP)(ep, ips[i]);
+         if (Vg_FnNameMain == kind || Vg_FnNameBelowMain == kind)
+            *n_ips = i + 1;
+         if (Vg_FnNameMain == kind)
+            break;
+      }
+   }
+
+   return VG_(make_ExeContext_from_StackTrace)(ips, *n_ips);
+}
+
+
+//------------------------------------------------------------//
+//--- Hash table add/search/cleanup                        ---//
+//------------------------------------------------------------//
+
+static void add_callstack_from_file(Addr *ips, UInt n_ips)
+{
+   ExeContext *exe;
+   UInt ecu;
+
+   FG_(callstacks_loaded)++;
+   exe = VG_(make_ExeContext_from_StackTrace)(ips, n_ips);
+   ecu = VG_(get_ECU_from_ExeContext)(exe);
+
+   if (!FG_(callstack_exists)(ecu)) {
+      FG_(add_callstack_to_hashtable)(exe, ecu);
+   }
+}
+
+
+/* Add the callstack ECU to the in memory hash table. */
+void FG_(add_callstack_to_hashtable)(ExeContext *exe, UInt ecu)
+{
+   VgHashNode_callstack *node = VG_(calloc)("fg.add_callstack_to_hashtable", 1, sizeof(VgHashNode_callstack));
+   node->ecu = (UWord)ecu;
+   node->exe = exe;
+   VG_(HT_add_node)(FG_(callstack_ht), node);
+}
+
+
+/* Check whether a ecu exists in the hash table. */
+Bool FG_(callstack_exists)(UInt ecu)
+{
+   if (VG_(HT_lookup)(FG_(callstack_ht), (UWord)ecu)) {
+      return True;
+   } else {
+      return False;
+   }
+}
+
+
+/* Free all memory from hash table. */
+void FG_(cleanup_callstacks)(void)
+{
+   VG_(HT_destruct)(FG_(callstack_ht), VG_(free));
+   FG_(callstack_ht) = NULL;
+}
+
+
+//------------------------------------------------------------//
+//--- Callstack file reading/writing                       ---//
+//------------------------------------------------------------//
+
+Bool FG_(read_callstack_file)(const HChar *filename, Bool no_open_is_error)
+{
+   UWord ips[VG_(clo_backtrace_size)];
+   UInt n_ips = 0;
+   Int fd;
+   Int lineno;
+   SizeT nBuf;
+   const HChar *addr_str;
+   const HChar *err_str;
+   HChar *bufp;
+
+   /* Starting point for size of bufp. This will be increased by VG_(get_line)
+    * if required. */
+   nBuf = 100;
+   bufp = VG_(malloc)("fg.read_callstacks_file", nBuf);
+
+   fd = VG_(fd_open)(filename, VKI_O_RDONLY, 0);
+   if (fd < 0) {
+      VG_(free)(bufp);
+
+      return !no_open_is_error;
+   }
+
+   while (!VG_(get_line)(fd, &bufp, &nBuf, &lineno)) {
+      if (n_ips == VG_(clo_backtrace_size)) {
+         err_str = "   too many callers in stack trace, try increasing --num-callers";
+         goto error;
+      }
+
+      if (!VG_(strncmp)(bufp, "at 0x", 5)) {
+         /* Start of a new stack trace. If we're already part way through
+          * reading a stack trace then this indicates the end of that trace
+          * and the start of another. */
+         if (n_ips > 0) {
+            add_callstack_from_file(ips, n_ips);
+            n_ips = 0;
+         }
+         addr_str = &bufp[3];
+         VG_(parse_Addr)(&addr_str, &ips[n_ips]);
+         n_ips++;
+      } else if (!VG_(strncmp)(bufp, "by 0x", 5)) {
+         if (n_ips == 0) {
+            /* We haven't seen an "at 0x" yet, so this is a corrupt trace. */
+            err_str = "   incomplete stack trace";
+            goto error;
+         }
+         addr_str = &bufp[3];
+         VG_(parse_Addr)(&addr_str, &ips[n_ips]);
+         n_ips++;
+      } else {
+         err_str = "   corrupt line";
+         goto error;
+      }
+   }
+   /* Catch the final stack trace */
+   if (n_ips > 0) {
+      add_callstack_from_file(ips, n_ips);
+   }
+
+   VG_(close)(fd);
+   VG_(free)(bufp);
+   return True;
+
+error:
+   VG_(free)(bufp);
+   VG_(close)(fd);
+
+   VG_(umsg)("ERROR: in callstack file \"%s\" near line %d:\n",
+         filename, lineno);
+   VG_(umsg)("   %s\n", err_str);
+   return False;
+}
+
+
+/* Initialise callstacks and attempt to load all callstacks from the callstack
+ * file defined on the command line. */
+void FG_(load_callstacks)(void)
+{
+   /* Must construct this even if we aren't loading the callstacks. */
+   FG_(callstack_ht) = VG_(HT_construct)("fg.load_callstacks.1");
+
+   if (FG_(clo_callstack_input) == NULL) {
+      return;
+   }
+
+   if (!FG_(read_callstack_file)(FG_(clo_callstack_input), False)) {
+      VG_(umsg)("exiting now.\n");
+      VG_(exit)(1);
+   }
+}
+
+
+static void write_callstack_line(UInt n, DiEpoch ep, Addr ip, void* uu_opaque)
+{
+   Int *fd;
+   UInt flen = 0;
+   HChar *fbuf = NULL;
+   InlIPCursor *iipc = VG_(new_IIPC)(ep, ip);
+
+   fd = (Int *)uu_opaque;
+
+   do {
+      const HChar *buf = VG_(describe_IP)(ep, ip, iipc);
+      UInt len = VG_(strlen)(buf) + VG_(strlen)("at \n");
+
+      if (len > flen) {
+         fbuf = VG_(realloc)("fg.write_callstack_line", fbuf, len+1);
+         flen = len;
+      }
+
+      VG_(snprintf)(fbuf, flen+1, "%s %s\n",
+                   ( n == 0 ? "at" : "by" ), buf);
+
+      VG_(write)(*fd, fbuf, flen);
+      n++;
+      // Increase n to show "at" for only one level.
+   } while (VG_(next_IIPC)(iipc));
+   VG_(free)(fbuf);
+   VG_(delete_IIPC)(iipc);
+}
+
+
+Bool FG_(write_callstack_file)(const HChar *filename, Bool append)
+{
+   VgHashNode_callstack *node;
+   Int fd;
+   Int flags = VKI_O_CREAT | VKI_O_WRONLY;
+
+   if (filename == NULL) return False;
+
+   if (append) {
+      flags |= VKI_O_APPEND;
+   }
+
+   fd = VG_(fd_open)(filename, VKI_O_CREAT | VKI_O_WRONLY, 0660);
+   if (fd < 0) {
+      VG_(gdb_printf)("Unable to open %s\n", filename);
+      return False;
+   }
+
+   VG_(HT_ResetIter)(FG_(callstack_ht));
+   while ((node = VG_(HT_Next)(FG_(callstack_ht)))) {
+      VG_(write)(fd, FG_(execomment), FG_(execomment_len));
+      VG_(apply_ExeContext)(write_callstack_line, &fd, node->exe);
+      VG_(write)(fd, "\n", 1);
+   }
+
+   VG_(close)(fd);
+
+   return True;
+}
+
+
+/* Write a single callstack to the callstack file, creating if necessary. */
+void FG_(write_callstack)(UWord *ips, UInt n_ips)
+{
+   Int fd;
+
+   if (FG_(clo_callstack_output) == NULL || FG_(clo_write_callstacks_at_end)) {
+      return;
+   }
+
+   /* It is worth thinking about whether it is better to keep the callstack
+    * file open for writing for the duration of the program, or to open and
+    * close it every time a new callstack is written. The justification I am
+    * using for opening and closing it every time is that from what I have seen
+    * there are only typically a few failures (and corresponding file writes)
+    * required before a program will exit, and that I like the simplicity of
+    * having the entire writing code in one function.
+    *
+    * It would be trivial to change to opening the file in fg_post_clo_init()
+    * and closing it in fg_fini().
+    */
+   fd = VG_(fd_open)(FG_(clo_callstack_output), VKI_O_CREAT | VKI_O_APPEND | VKI_O_WRONLY, 0660);
+   if (fd < 0) {
+      VG_(umsg)("Unable to open %s\n", FG_(clo_callstack_output));
+      return;
+   }
+
+   VG_(write)(fd, FG_(execomment), FG_(execomment_len));
+   VG_(apply_StackTrace)(write_callstack_line, &fd, VG_(current_DiEpoch)(), ips, n_ips);
+   VG_(write)(fd, "\n", 1);
+
+   VG_(close)(fd);
+}
+
+
+
+//--------------------------------------------------------------------//
+//--- end                                           fg_callstack.c ---//
+//--------------------------------------------------------------------//
diff --git a/exp-failgrind/fg_global.h b/exp-failgrind/fg_global.h
new file mode 100644
index 000000000..91f1acf74
--- /dev/null
+++ b/exp-failgrind/fg_global.h
@@ -0,0 +1,131 @@
+/*--------------------------------------------------------------------*/
+/*--- Failgrind data structures, functions.            fg_global.h ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Failgrind, a Valgrind tool for testing program
+   behaviour when heap allocations or syscalls fail.
+
+   Copyright (C) 2018-2021 Roger Light.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+/* Contributed by Roger Light <roger@atchoo.org> */
+
+#ifndef FG_GLOBAL
+#define FG_GLOBAL
+
+#include "pub_tool_basics.h"
+#include "pub_tool_execontext.h"
+#include "pub_tool_options.h"
+#include "pub_tool_hashtable.h"
+#include "pub_tool_tooliface.h"
+
+#define FG_(str) VGAPPEND(vgFailgrind_,str)
+
+//------------------------------------------------------------//
+//--- Functions                                            ---//
+//------------------------------------------------------------//
+
+/* from fg_alloc.c */
+void* FG_(malloc)(ThreadId tid, SizeT szB);
+void* FG_(__builtin_new)(ThreadId tid, SizeT szB);
+void* FG_(__builtin_new_aligned)(ThreadId tid, SizeT szB, SizeT alignB);
+void* FG_(__builtin_vec_new)(ThreadId tid, SizeT szB);
+void* FG_(__builtin_vec_new_aligned)(ThreadId tid, SizeT szB, SizeT alignB);
+void* FG_(calloc)(ThreadId tid, SizeT m, SizeT szB);
+void *FG_(memalign)(ThreadId tid, SizeT alignB, SizeT szB);
+void FG_(free)(ThreadId tid __attribute__((unused)), void* p);
+void FG_(__builtin_delete)(ThreadId tid, void* p);
+void FG_(__builtin_delete_aligned)(ThreadId tid, void* p, SizeT align);
+void FG_(__builtin_vec_delete)(ThreadId tid, void* p);
+void FG_(__builtin_vec_delete_aligned)(ThreadId tid, void* p, SizeT align);
+void* FG_(realloc)(ThreadId tid, void* p_old, SizeT new_szB);
+SizeT FG_(malloc_usable_size)(ThreadId tid, void* p);
+
+/* from fg_callstack.c */
+void FG_(add_callstack_to_hashtable)(ExeContext *exe, UInt ecu);
+Bool FG_(callstack_exists)(UInt ecu);
+void FG_(cleanup_callstacks)(void);
+ExeContext *FG_(get_call_execontext)(ThreadId tid, UWord *ips, UInt *n_ips);
+void FG_(load_callstacks)(void);
+Bool FG_(read_callstack_file)(const HChar *filename, Bool no_read_is_error);
+void FG_(write_callstack)(UWord *ips, UInt n_ips);
+Bool FG_(write_callstack_file)(const HChar *filename, Bool append);
+
+/* from fg_main.c */
+UInt FG_(random_100)(void);
+
+/* from fg_syscall.c */
+void FG_(parse_syscall_errno)(const HChar* arg, const HChar* value);
+void FG_(pre_syscall)(ThreadId tid, SyscallStatus* status, UInt syscallno,
+                           UWord* args, UInt nArgs);
+
+void FG_(post_syscall)(ThreadId tid, UInt syscallno,
+                            UWord* args, UInt nArgs, SysRes res);
+
+//------------------------------------------------------------//
+//--- Exported global variables                            ---//
+//------------------------------------------------------------//
+
+extern XArray* FG_(alloc_allow_funcs);
+extern Bool FG_(alloc_fail);
+extern ULong FG_(alloc_fail_count);
+extern ULong FG_(alloc_new_callstack_count);
+extern ULong FG_(alloc_success_count);
+extern XArray* FG_(alloc_toggle_funcs);
+
+extern VgHashTable *FG_(callstack_ht);
+extern ULong FG_(callstacks_loaded);
+
+extern HChar *FG_(execomment);
+extern UInt FG_(execomment_len);
+
+extern Bool FG_(in_main);
+
+extern XArray* FG_(syscall_allow_funcs);
+extern Bool FG_(syscall_fail);
+extern ULong FG_(syscall_fail_count);
+extern ULong FG_(syscall_new_callstack_count);
+extern ULong FG_(syscall_success_count);
+extern XArray* FG_(syscall_toggle_funcs);
+
+//------------------------------------------------------------//
+//--- Exported CLO variables                               ---//
+//------------------------------------------------------------//
+extern Bool FG_(clo_alloc_fail_atstart);
+extern UInt FG_(clo_alloc_fail_chance);
+extern UInt FG_(clo_alloc_max_fails);
+extern Long FG_(clo_alloc_thresh_high);
+extern Long FG_(clo_alloc_thresh_low);
+extern Bool FG_(clo_alloc_thresh_invert);
+
+extern const HChar *FG_(clo_callstack_input);
+extern const HChar *FG_(clo_callstack_output);
+
+extern Bool FG_(clo_print_failed_traces);
+
+extern Bool FG_(clo_syscall_fail_atstart);
+extern UInt FG_(clo_syscall_fail_chance);
+extern UInt FG_(clo_syscall_max_fails);
+extern Bool FG_(clo_syscall_specified_only);
+
+extern Bool FG_(clo_write_callstacks_at_end);
+
+#endif /* FG_GLOBAL */
diff --git a/exp-failgrind/fg_main.c b/exp-failgrind/fg_main.c
new file mode 100644
index 000000000..bf630b622
--- /dev/null
+++ b/exp-failgrind/fg_main.c
@@ -0,0 +1,676 @@
+//--------------------------------------------------------------------*/
+//--- Failgrind: a memory allocation failure testing tool          ---*/
+//--------------------------------------------------------------------*/
+
+/*
+   This file is part of Failgrind, a Valgrind tool for testing program
+   behaviour when heap allocations or syscalls fail.
+
+   Copyright (C) 2018-2021 Roger Light.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+/* Contributed by Roger Light <roger@atchoo.org> */
+
+
+#include "pub_tool_basics.h"
+#include "pub_tool_clientstate.h"
+#include "pub_tool_gdbserver.h"
+#include "pub_tool_hashtable.h"
+#include "pub_tool_libcbase.h"
+#include "pub_tool_libcassert.h"
+#include "pub_tool_libcfile.h"
+#include "pub_tool_libcprint.h"
+#include "pub_tool_libcproc.h"
+#include "pub_tool_machine.h"
+#include "pub_tool_mallocfree.h"
+#include "pub_tool_options.h"
+#include "pub_tool_poolalloc.h"
+#include "pub_tool_replacemalloc.h"
+#include "pub_tool_stacktrace.h"
+#include "pub_tool_threadstate.h"
+#include "pub_tool_tooliface.h"
+#include "pub_tool_vki.h"
+
+#include "valgrind.h"
+#include "failgrind.h"
+#include "fg_global.h"
+#include "clg_global.h"
+
+#define FG_CALLSTACK_FILE "failgrind.callstacks"
+
+//------------------------------------------------------------//
+//--- Globals                                              ---//
+//------------------------------------------------------------//
+
+// Alloc
+ULong FG_(alloc_success_count) = 0;
+ULong FG_(alloc_fail_count) = 0;
+ULong FG_(alloc_new_callstack_count) = 0;
+Bool FG_(alloc_fail) = True;
+XArray* FG_(alloc_toggle_funcs) = NULL;
+XArray* FG_(alloc_allow_funcs) = NULL;
+
+// Syscall
+ULong FG_(syscall_success_count) = 0;
+ULong FG_(syscall_fail_count) = 0;
+ULong FG_(syscall_new_callstack_count) = 0;
+Bool FG_(syscall_fail) = False;
+XArray* FG_(syscall_toggle_funcs) = NULL;
+XArray* FG_(syscall_allow_funcs) = NULL;
+
+
+// Other
+static UInt g_seed;
+HChar *FG_(execomment) = NULL;
+UInt FG_(execomment_len) = 0;
+
+VgHashTable *FG_(callstack_ht) = NULL;
+
+ULong FG_(callstacks_loaded) = 0;
+
+Bool FG_(in_main) = False;
+
+//------------------------------------------------------------//
+//--- Command line options                                 ---//
+//------------------------------------------------------------//
+
+// Alloc
+static Bool clo_alloc_fail_atstart = True;
+UInt FG_(clo_alloc_fail_chance) = 100;
+UInt FG_(clo_alloc_max_fails) = 0;
+Long FG_(clo_alloc_thresh_high) = 0;
+Long FG_(clo_alloc_thresh_low) = 0;
+Bool FG_(clo_alloc_thresh_invert) = False;
+
+// Syscall
+static Bool clo_syscall_fail_atstart = False;
+UInt FG_(clo_syscall_fail_chance) = 100;
+UInt FG_(clo_syscall_max_fails) = 0;
+Bool FG_(clo_syscall_specified_only) = False;
+
+// Other
+const HChar *FG_(clo_callstack_input) = FG_CALLSTACK_FILE;
+const HChar *FG_(clo_callstack_output) = FG_CALLSTACK_FILE;
+Bool FG_(clo_write_callstacks_at_end) = False;
+Bool FG_(clo_print_failed_traces) = False;
+
+static Bool clo_print_stats = True;
+static UInt clo_seed = 0;
+
+
+//------------------------------------------------------------//
+//--- Random number 0-99                                  ---//
+//------------------------------------------------------------//
+
+UInt FG_(random_100)(void)
+{
+   UInt r;
+
+   do {
+      r = VG_(random)(&g_seed);
+   } while (r > (4294967295U - (((4294967295U % 100) + 1) % 100)));
+
+   return r % 100;
+
+}
+
+
+//------------------------------------------------------------//
+//--- Client events                                        ---//
+//------------------------------------------------------------//
+
+static void print_monitor_help ( void )
+{
+   VG_(gdb_printf) ("\n");
+   VG_(gdb_printf) ("failgrind monitor commands:\n");
+   VG_(gdb_printf) ("  alloc_fail [on|off]\n");
+   VG_(gdb_printf) ("        get/set (if on/off given) whether memory allocation failures are enabled.\n)");
+   VG_(gdb_printf) ("  callstack_append <file>\n");
+   VG_(gdb_printf) ("        appends the in-memory list of heap allocation callstacks to an existing file.\n");
+   VG_(gdb_printf) ("  callstack_clear\n");
+   VG_(gdb_printf) ("        clear the in-memory list of heap allocation callstacks.\n");
+   VG_(gdb_printf) ("  callstack_read <file>\n");
+   VG_(gdb_printf) ("        read a set of callstacks from a file into memory. Does not remove existing\n");
+   VG_(gdb_printf) ("        callstacks in memory.\n");
+   VG_(gdb_printf) ("  callstack_write <file>\n");
+   VG_(gdb_printf) ("        write the in-memory list of callstacks to a new file.\n");
+   VG_(gdb_printf) ("  print_stats\n");
+   VG_(gdb_printf) ("        print the success/fail counts, then zeros them.\n");
+   VG_(gdb_printf) ("  syscall_fail [on|off]\n");
+   VG_(gdb_printf) ("        get/set (if on/off given) whether global syscall failures are enabled.\n)");
+   VG_(gdb_printf) ("  zero_stats\n");
+   VG_(gdb_printf) ("        zero the success/fail counts.\n");
+   VG_(gdb_printf) ("\n");
+}
+
+
+/* return True if request recognised, False otherwise */
+static Bool handle_gdb_monitor_command (ThreadId tid, const HChar *req)
+{
+   HChar* wcmd;
+   HChar s[VG_(strlen)(req) + 1]; /* copy for strtok_r */
+   HChar *ssaveptr;
+
+   VG_(strcpy) (s, req);
+
+   wcmd = VG_(strtok_r) (s, " ", &ssaveptr);
+   switch (VG_(keyword_id) ("help "
+                            "alloc_fail "
+                            "callstack_append callstack_clear callstack_read callstack_write "
+                            "print_stats zero_stats "
+                            "syscall_fail",
+                            wcmd, kwd_report_duplicated_matches)) {
+
+   case -2: /* multiple matches */
+      return True;
+   case -1: /* not found */
+      return False;
+   case  0: /* help */
+      print_monitor_help();
+      return True;
+   case  1: { /* alloc_fail */
+      HChar* arg = VG_(strtok_r) (0, " ", &ssaveptr);
+      if (arg == NULL) {
+         VG_(gdb_printf)("alloc_fail: %s\n",
+         FG_(alloc_fail) ? "on":"off");
+      } else {
+         FG_(alloc_fail) = VG_(strcmp)(arg, "off")!=0;
+      }
+      return True;
+   }
+   case  2: { /* callstack_append */
+      HChar* arg = VG_(strtok_r) (0, " ", &ssaveptr);
+      if (arg == NULL) {
+         return False;
+      } else {
+         return FG_(write_callstack_file)(arg, True);
+      }
+   }
+   case  3: { /* callstack_clear */
+      FG_(cleanup_callstacks)();
+      FG_(callstack_ht) = VG_(HT_construct)("fg.handle_gdb_monitor_command");
+      return True;
+   }
+   case  4: { /* callstack_read */
+      HChar* arg = VG_(strtok_r) (0, " ", &ssaveptr);
+      if (arg == NULL) {
+         return False;
+      } else {
+         return FG_(read_callstack_file)(arg, True);
+      }
+   }
+   case  5: { /* callstack_write */
+      HChar* arg = VG_(strtok_r) (0, " ", &ssaveptr);
+      if (arg == NULL) {
+         return False;
+      } else {
+         return FG_(write_callstack_file)(arg, False);
+      }
+   }
+   case  6: { /* print_stats */
+      VG_(gdb_printf)("%llu allocations succeeded\n", FG_(alloc_success_count));
+      VG_(gdb_printf)("%llu allocations failed\n", FG_(alloc_fail_count));
+      VG_(gdb_printf)("%llu new allocation callstacks found\n", FG_(alloc_new_callstack_count));
+      VG_(gdb_printf)("%llu syscalls succeeded\n", FG_(syscall_success_count));
+      VG_(gdb_printf)("%llu syscalls failed\n", FG_(syscall_fail_count));
+      VG_(gdb_printf)("%llu new syscall callstacks found\n", FG_(syscall_new_callstack_count));
+      /* Fall through to zero_stats */
+   }
+   case  7: { /* zero_stats */
+      FG_(alloc_success_count) = 0;
+      FG_(alloc_fail_count) = 0;
+      FG_(alloc_new_callstack_count) = 0;
+      FG_(syscall_success_count) = 0;
+      FG_(syscall_fail_count) = 0;
+      FG_(syscall_new_callstack_count) = 0;
+      return True;
+   }
+   case  8: { /* syscall_fail */
+      HChar* arg = VG_(strtok_r) (0, " ", &ssaveptr);
+      if (arg == NULL) {
+         VG_(gdb_printf)("syscall_fail: %s\n",
+         FG_(syscall_fail) ? "on":"off");
+      } else {
+         FG_(syscall_fail) = VG_(strcmp)(arg, "off")!=0;
+      }
+      return True;
+   }
+
+   default:
+      tl_assert(0);
+      return False;
+   }
+}
+
+static Bool handle_client_request(ThreadId tid, UWord *args, UWord *ret)
+{
+   if (!VG_IS_TOOL_USERREQ('F', 'G', args[0])
+       && VG_USERREQ__GDB_MONITOR_COMMAND != args[0])
+      return False;
+
+   switch(args[0]) {
+   case VG_USERREQ__FG_ALLOC_FAIL_ON:
+      FG_(alloc_fail) = True;
+      return True;
+   case VG_USERREQ__FG_ALLOC_FAIL_OFF:
+      FG_(alloc_fail) = False;
+      return True;
+   case VG_USERREQ__FG_ALLOC_FAIL_TOGGLE:
+      FG_(alloc_fail) = !FG_(alloc_fail);
+      return True;
+   case VG_USERREQ__FG_ALLOC_GET_FAIL_COUNT: {
+      *ret = FG_(alloc_fail_count);
+      return True;
+   }
+   case VG_USERREQ__FG_ALLOC_GET_NEW_CALLSTACK_COUNT: {
+      *ret = FG_(alloc_new_callstack_count);
+      return True;
+   }
+   case VG_USERREQ__FG_ALLOC_GET_SUCCESS_COUNT: {
+      *ret = FG_(alloc_success_count);
+      return True;
+   }
+   case VG_USERREQ__FG_CALLSTACK_CLEAR: {
+      FG_(cleanup_callstacks)();
+      FG_(callstack_ht) = VG_(HT_construct)("fg.handle_client_request");
+      return True;
+   }
+   case VG_USERREQ__FG_CALLSTACK_READ: {
+      return FG_(read_callstack_file)((HChar *)args[1], True);
+   }
+   case VG_USERREQ__FG_CALLSTACK_WRITE: {
+      return FG_(write_callstack_file)((HChar *)args[1], False);
+   }
+   case VG_USERREQ__FG_CALLSTACK_APPEND: {
+      return FG_(write_callstack_file)((HChar *)args[1], True);
+   }
+   case VG_USERREQ__FG_SYSCALL_FAIL_ON:
+      FG_(syscall_fail) = True;
+      return True;
+   case VG_USERREQ__FG_SYSCALL_FAIL_OFF:
+      FG_(syscall_fail) = False;
+      return True;
+   case VG_USERREQ__FG_SYSCALL_FAIL_TOGGLE:
+      FG_(syscall_fail) = !FG_(syscall_fail);
+      return True;
+   case VG_USERREQ__FG_SYSCALL_GET_FAIL_COUNT: {
+      *ret = FG_(syscall_fail_count);
+      return True;
+   }
+   case VG_USERREQ__FG_SYSCALL_GET_NEW_CALLSTACK_COUNT: {
+      *ret = FG_(syscall_new_callstack_count);
+      return True;
+   }
+   case VG_USERREQ__FG_SYSCALL_GET_SUCCESS_COUNT: {
+      *ret = FG_(syscall_success_count);
+      return True;
+   }
+   case VG_USERREQ__FG_ZERO_COUNTS: {
+      FG_(alloc_success_count) = 0;
+      FG_(alloc_fail_count) = 0;
+      FG_(alloc_new_callstack_count) = 0;
+      FG_(syscall_success_count) = 0;
+      FG_(syscall_fail_count) = 0;
+      FG_(syscall_new_callstack_count) = 0;
+      return True;
+   }
+
+   case VG_USERREQ__GDB_MONITOR_COMMAND: {
+      Bool handled = handle_gdb_monitor_command (tid, (HChar*)args[1]);
+      if (handled)
+         *ret = 1;
+      else
+         *ret = 0;
+      return handled;
+   }
+   default:
+      return False;
+   }
+
+   return True;
+}
+
+
+//------------------------------------------------------------//
+//--- Command line args                                    ---//
+//------------------------------------------------------------//
+
+static Bool fg_process_cmd_line_option(const HChar* arg)
+{
+   const HChar* optval;
+
+   if VG_STR_CLO(arg, "--alloc-allow", optval) {
+      if (!FG_(alloc_allow_funcs)) {
+         FG_(alloc_allow_funcs) = VG_(newXA)(VG_(malloc), "fg.process_cmd_line_option.5",
+                                             VG_(free), sizeof(HChar*));
+      }
+      VG_(addToXA)(FG_(alloc_allow_funcs), &optval);
+   }
+   else if VG_BOOL_CLO(arg, "--alloc-fail-atstart", clo_alloc_fail_atstart) {}
+   else if VG_BINT_CLO(arg, "--alloc-fail-chance", FG_(clo_alloc_fail_chance), 1, 100) {}
+   else if VG_BINT_CLO(arg, "--alloc-max-fails", FG_(clo_alloc_max_fails), 0, 1000000) {}
+   else if VG_INT_CLO(arg, "--alloc-threshold-high", FG_(clo_alloc_thresh_high)) {
+      if (FG_(clo_alloc_thresh_high) < 0) {
+         VG_(fmsg_bad_option)(arg,
+            "--alloc-threshold-high must be greater than 0\n");
+      }
+   }
+   else if VG_INT_CLO(arg, "--alloc-threshold-low", FG_(clo_alloc_thresh_low)) {
+      if (FG_(clo_alloc_thresh_low) < 0) {
+         VG_(fmsg_bad_option)(arg,
+            "--alloc-threshold-low must be greater than 0\n");
+      }
+   }
+   else if VG_BOOL_CLO(arg, "--alloc-threshold-invert", FG_(clo_alloc_thresh_invert)) {}
+   else if VG_STR_CLO(arg, "--alloc-toggle", optval) {
+      if (!FG_(alloc_toggle_funcs)) {
+         FG_(alloc_toggle_funcs) = VG_(newXA)(VG_(malloc), "fg.process_cmd_line_option.1",
+                                           VG_(free), sizeof(HChar*));
+      }
+      VG_(addToXA)(FG_(alloc_toggle_funcs), &optval);
+      /* defaults to failing disabled initially */
+      clo_alloc_fail_atstart = False;
+   }
+   else if VG_BOOL_CLO(arg, "--failgrind-stats", clo_print_stats) {}
+   else if VG_STR_CLO(arg, "--callstack-input", FG_(clo_callstack_input)) {}
+   else if VG_STR_CLO(arg, "--callstack-output", FG_(clo_callstack_output)) {}
+   else if VG_INT_CLO(arg, "--seed", clo_seed) {}
+   else if VG_BOOL_CLO(arg, "--show-failed", FG_(clo_print_failed_traces)) {}
+   else if VG_STR_CLO(arg, "--syscall-allow", optval) {
+      if (!FG_(syscall_allow_funcs)) {
+         FG_(syscall_allow_funcs) = VG_(newXA)(VG_(malloc), "fg.process_cmd_line_option.4",
+                                             VG_(free), sizeof(HChar*));
+      }
+      VG_(addToXA)(FG_(syscall_allow_funcs), &optval);
+   }
+   else if VG_STR_CLO(arg, "--syscall-errno", optval){
+      FG_(parse_syscall_errno)(arg, optval);
+   }
+   else if VG_BOOL_CLO(arg, "--syscall-fail-atstart", clo_syscall_fail_atstart) {}
+   else if VG_BINT_CLO(arg, "--syscall-fail-chance", FG_(clo_syscall_fail_chance), 1, 100) {}
+   else if VG_BINT_CLO(arg, "--syscall-max-fails", FG_(clo_syscall_max_fails), 0, 1000000) {}
+   else if VG_BOOL_CLO(arg, "--syscall-specified-only", FG_(clo_syscall_specified_only)) {}
+   else if VG_STR_CLO(arg, "--syscall-toggle", optval) {
+      if (!FG_(syscall_toggle_funcs)) {
+         FG_(syscall_toggle_funcs) = VG_(newXA)(VG_(malloc), "fg.process_cmd_line_option.3",
+                                             VG_(free), sizeof(HChar*));
+      }
+      VG_(addToXA)(FG_(syscall_toggle_funcs), &optval);
+      /* defaults to failing disabled initially */
+      clo_syscall_fail_atstart = False;
+   }
+   else if VG_BOOL_CLO(arg, "--write-callstacks-at-end", FG_(clo_write_callstacks_at_end)) {}
+   else
+      return VG_(replacement_malloc_process_cmd_line_option)(arg);
+
+   return True;
+}
+
+
+static void fg_print_usage(void)
+{
+   VG_(printf)(
+"    --alloc-fail-atstart=no|yes  Begin memory allocation failures at failgrind\n"
+"                              start [yes]\n"
+"    --alloc-fail-chance=<number>  The default operation of failgrind is to reject\n"
+"                              all memory allocations when a call stack is seen\n"
+"                              for the first time. Set this option to 1-100 to\n"
+"                              act as the percentage chance that an allocation\n"
+"                              that is due to be rejected will actually be\n"
+"                              rejected. Using this option makes your testing\n"
+"                              non-deterministic [100]\n"
+"    --alloc-max-fails=<number>  Maximum number of allocation failures allowed\n"
+"                              per run [0: unlimited]\n"
+"    --alloc-threshold-high=<bytes>  If set, allocations larger than bytes will\n"
+"                              never be failed.\n"
+"    --alloc-threshold-low=<bytes>   If set, allocations smaller than bytes will\n"
+"                              never be failed.\n"
+"    --alloc-threshold-invert=yes|no  Invert the sense of --alloc-threshold-high\n"
+"                              and --alloc-threshold-low, i.e. only reject\n"
+"                              allocations smaller than \"high\" and larger than\n"
+"                              \"low\" [no].\n"
+"    --alloc-toggle=<function> Toggle the enable/disable state of heap memory\n"
+"                              allocation failures when this function is entered\n"
+"                              and returned from. When this option is in use the\n"
+"                              --alloc-fail-atstart option defaults to no,\n"
+"                              meaning that allocation failures will be enabled\n"
+"                              when <function> is entered.\n"
+"    --callstack-input=no|<filename>  Load callstacks that should always succeed\n"
+"                              from this file. Defaults to %s.\n"
+"                              Set to 'no' to disable the loading of callstacks.\n"
+"    --callstack-output=no|<filename>  Relevant call stacks that failgrind fails\n"
+"                              for the first time will be written to this file.\n"
+"                              Defaults to %s.\n"
+"                              Set to 'no' to disable the writing of callstacks.\n"
+"    --failgrind-stats=yes|no  Show simple allocation success/failure counts\n"
+"                              after the program ends [yes]\n"
+"    --seed=<number>           Random seed to use when --alloc-fail-chance or\n"
+"                              --syscall-fail-chance is in use\n"
+"    --show-failed=yes|no      Print a stack trace whenever an allocation or syscall\n"
+"                              is made to fail [no]\n"
+"    --syscall-allow=<function>   Always allow the named syscall to succeed,\n"
+"                              regardless of other settings.\n"
+"    --syscall-errno=<error>   Set syscall failures to produce <error> instead of \n"
+"                              EINVAL. See the user manual for a list of supported\n"
+"                              errors.\n"
+"    --syscall-errno=<function>,<error>  Set the error to use for a specific syscall\n"
+"                              only, e.g. \"open,EPERM\". Can be used multiple times,\n"
+"                              but only once per syscall.\n"
+"    --syscall-fail-atstart=no|yes  Begin global syscall failures at failgrind\n"
+"                              start [no]\n"
+"    --syscall-fail-chance=<number>  The default operation of failgrind is to\n"
+"                              reject all syscalls when a call stack is seen\n"
+"                              for the first time. Set this option to 1-100 to\n"
+"                              act as the percentage chance that a syscall\n"
+"                              that is due to be rejected will actually be\n"
+"                              rejected. Using this option makes your testing\n"
+"                              non-deterministic [100]\n"
+"    --syscall-max-fails=<number>  Maximum number of syscall failures allowed\n"
+"                              per run [0: unlimited]\n"
+"    --syscall-specified-only=yes|no  When specific functions have been defined with\n"
+"                              --syscall-errno, set this option to yes to restrict\n"
+"                              failures to the specified syscalls only. Default: no,\n"
+"    --syscall-toggle=<function> Toggle the enable/disable state of syscall\n"
+"                              failures when this function is entered and\n"
+"                              returned from. When this option is in use the\n"
+"                              --syscall-fail-atstart option defaults to no,\n"
+"                              meaning that syscall failures will be enabled\n"
+"                              when <function> is entered.\n"
+"    --write-callstacks-at-end=yes|no  Set to yes to write the callstack output\n"
+"                              file when Failgrind exits. This creates a new file.\n"
+"                              Set to no to have each new callstack appended to\n"
+"                              the output file immediately [no].\n"
+   , FG_CALLSTACK_FILE, FG_CALLSTACK_FILE);
+}
+
+static void fg_print_debug_usage(void)
+{
+   VG_(printf)(
+"    (none)\n"
+   );
+}
+
+
+static void fg_fini(Int exit_status)
+{
+   if (FG_(clo_write_callstacks_at_end)) {
+      FG_(write_callstack_file)(FG_(clo_callstack_output), False);
+   }
+
+   FG_(cleanup_callstacks)();
+   VG_(free)(FG_(execomment));
+
+   if (clo_print_stats && VG_(clo_verbosity) > 0) {
+      VG_(umsg)(" Failgrind: %llu call stacks loaded from file\n", FG_(callstacks_loaded));
+      VG_(umsg)("            %llu allocations succeeded\n", FG_(alloc_success_count));
+      VG_(umsg)("            %llu allocations failed\n", FG_(alloc_fail_count));
+      VG_(umsg)("            %llu new allocation callstacks found\n", FG_(alloc_new_callstack_count));
+      VG_(umsg)("            %llu syscalls succeeded\n", FG_(syscall_success_count));
+      VG_(umsg)("            %llu syscalls failed\n", FG_(syscall_fail_count));
+      VG_(umsg)("            %llu new syscall callstacks found\n", FG_(syscall_new_callstack_count));
+      VG_(umsg)("\n");
+   }
+}
+
+
+//------------------------------------------------------------//
+//--- Initialisation                                       ---//
+//------------------------------------------------------------//
+
+static void fg_post_clo_init(void)
+{
+   const HChar *exename;
+
+   /* Input/output files */
+   if (FG_(clo_callstack_input) != NULL) {
+      if (!VG_(strcmp)(FG_(clo_callstack_input), "no")) {
+         FG_(clo_callstack_input) = NULL;
+      /*
+      } else {
+         FG_(clo_callstack_input) is custom file.
+      */
+      }
+   } else {
+      FG_(clo_callstack_input) = FG_CALLSTACK_FILE;
+   }
+
+   if (FG_(clo_callstack_output) != NULL) {
+      if (!VG_(strcmp)(FG_(clo_callstack_output), "no")) {
+         FG_(clo_callstack_output) = NULL;
+      /*
+      } else {
+         FG_(clo_callstack_output) is custom file.
+      */
+      }
+   } else {
+      FG_(clo_callstack_output) = FG_CALLSTACK_FILE;
+   }
+
+   FG_(load_callstacks)();
+
+   /* Prepare exename comment line for writing. '# ./test\n' */
+   exename = VG_(args_the_exename);
+   FG_(execomment_len) = VG_(strlen)(exename) + 3;
+   FG_(execomment) = VG_(malloc)("fg.post_clo_init.1", FG_(execomment_len) + 1);
+   VG_(sprintf)(FG_(execomment), "# %s\n", exename);
+
+   /* Random seed generation and reporting */
+   if (FG_(clo_alloc_fail_chance) < 100 || FG_(clo_syscall_fail_chance) < 100) {
+      if (clo_seed == 0) {
+         g_seed = (VG_(getpid)() << 9) ^ VG_(getppid)();
+      } else {
+         g_seed = clo_seed;
+      }
+
+      if (VG_(clo_verbosity) > 0) {
+         VG_(umsg)("Using random seed: %u\n", g_seed);
+      }
+   }
+
+   FG_(alloc_fail) = clo_alloc_fail_atstart;
+   FG_(syscall_fail) = clo_syscall_fail_atstart;
+
+   CLG_(post_clo_init)();
+}
+
+static void fg_pre_clo_init(void)
+{
+   VG_(details_name)            ("Failgrind");
+   VG_(details_version)         (NULL);
+   VG_(details_description)     ("a memory allocation and syscall failure testing tool");
+   VG_(details_copyright_author)(
+      "Copyright (C) 2018-2021, and GNU GPL'd, by Roger Light.");
+   VG_(details_bug_reports_to)  (VG_BUGS_TO);
+
+   // Basic functions.
+   VG_(basic_tool_funcs)          (fg_post_clo_init,
+                                   CLG_(instrument),
+                                   fg_fini);
+   // Needs.
+   VG_(needs_libc_freeres)();
+   VG_(needs_cxx_freeres)();
+   VG_(needs_command_line_options)(fg_process_cmd_line_option,
+                                   fg_print_usage,
+                                   fg_print_debug_usage);
+   VG_(needs_malloc_replacement)  (FG_(malloc),
+                                   FG_(__builtin_new),
+                                   FG_(__builtin_new_aligned),
+                                   FG_(__builtin_vec_new),
+                                   FG_(__builtin_vec_new_aligned),
+                                   FG_(memalign),
+                                   FG_(calloc),
+                                   FG_(free),
+                                   FG_(__builtin_delete),
+                                   FG_(__builtin_delete_aligned),
+                                   FG_(__builtin_vec_delete),
+                                   FG_(__builtin_vec_delete_aligned),
+                                   FG_(realloc),
+                                   FG_(malloc_usable_size),
+                                   0 );
+
+   VG_(needs_client_requests)(handle_client_request);
+
+   VG_(needs_syscall_wrapper)(FG_(pre_syscall), FG_(post_syscall));
+
+   /* Arbitrary increase of --num-callers from default of 12. */
+   VG_(clo_backtrace_size) = 30;
+
+   FG_(syscall_allow_funcs) = VG_(newXA)(VG_(malloc), "fg.pre_clo_init.1",
+                                         VG_(free), sizeof(HChar*));
+
+   /* These syscalls should always succeed. */
+   HChar* s;
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "alarm");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "exit");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "exit_group");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "getegid");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "geteuid");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "getgid");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "getpgrp");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "getpid");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "getppid");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "gettid");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "getuid");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "sched_yield");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "set_tid_address");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "sync");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+   s = VG_(strdup)("fg.pre_clo_init.addToXA", "umask");
+   VG_(addToXA)(FG_(syscall_allow_funcs), &s);
+}
+
+VG_DETERMINE_INTERFACE_VERSION(fg_pre_clo_init)
+
+//--------------------------------------------------------------------//
+//--- end                                                fg_main.c ---//
+//--------------------------------------------------------------------//
diff --git a/exp-failgrind/fg_syscall.c b/exp-failgrind/fg_syscall.c
new file mode 100644
index 000000000..f4f49212d
--- /dev/null
+++ b/exp-failgrind/fg_syscall.c
@@ -0,0 +1,461 @@
+//--------------------------------------------------------------------*/
+//--- Failgrind: a memory allocation failure testing tool          ---*/
+//--------------------------------------------------------------------*/
+
+/*
+   This file is part of Failgrind, a Valgrind tool for testing program
+   behaviour when heap allocations or syscalls fail.
+
+   Copyright (C) 2018-2021 Roger Light.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+/* Contributed by Roger Light <roger@atchoo.org> */
+
+#include "pub_tool_basics.h"
+#include "pub_tool_hashtable.h"
+#include "pub_tool_libcbase.h"
+#include "pub_tool_libcprint.h"
+#include "pub_tool_mallocfree.h"
+#include "pub_tool_stacktrace.h"
+#include "pub_tool_vki.h"
+
+#include "fg_global.h"
+
+typedef struct _VgHashNode_errno {
+   struct _VgHashNode_errno *next;
+   UWord key;
+   HChar* fnname;
+   Int errno;
+} VgHashNode_errno;
+
+//------------------------------------------------------------//
+//--- Globals                                              ---//
+//------------------------------------------------------------//
+
+static VgHashTable *g_syscall_errno_values = NULL;
+static Int g_syscall_errno = VKI_EINVAL;
+
+
+//------------------------------------------------------------//
+//--- Function declarations                                ---//
+//------------------------------------------------------------//
+
+Int fg_str2errno(const HChar* str);
+
+
+//------------------------------------------------------------//
+//--- Functions                                            ---//
+//------------------------------------------------------------//
+
+static Word fg_cmp_errno(const void* node1, const void* node2)
+{
+   const VgHashNode_errno *n1 = node1;
+   const VgHashNode_errno *n2 = node2;
+
+   return VG_(strcmp)(n1->fnname, n2->fnname);
+}
+
+
+static Int get_fn_errno(const HChar* fnname)
+{
+   if (g_syscall_errno_values != NULL) {
+      VgHashNode_errno* found_node;
+      VgHashNode_errno node;
+
+      node.next = NULL;
+      node.key = fnname[0];
+      node.fnname = fnname;
+      node.errno = VKI_EINVAL;
+      found_node = VG_(HT_gen_lookup)(g_syscall_errno_values, &node, fg_cmp_errno);
+
+      if (found_node) {
+         return found_node->errno;
+      } else {
+         if (FG_(clo_syscall_specified_only) == True) {
+            /* The user has specified errno for particular functions,
+             * and has --syscall-specified-only=yes, so we should not
+             * fail the syscall because this one wasn't specified.
+             */
+            return -1;
+         } else {
+            /* --syscall-specified-only=no, so use the global errno
+             * return value. */
+            return g_syscall_errno;
+         }
+      }
+   } else {
+      /* No specific syscalls configured, so use global errno return value. */
+      return g_syscall_errno;
+   }
+}
+
+static Bool should_syscall_fail(ThreadId tid, UWord *ips, UInt *n_ips, Int *force_errno)
+{
+   ExeContext* exe;
+   UInt ecu;
+   const HChar* fnname;
+
+   /* Check for global disable */
+   if (!FG_(syscall_fail)) {
+      return False;
+   }
+
+   *force_errno = -1;
+
+   exe = FG_(get_call_execontext)(tid, ips, n_ips);
+   ecu = VG_(get_ECU_from_ExeContext)(exe);
+
+   VG_(get_fnname)(VG_(current_DiEpoch)(), ips[0], &fnname);
+   if (FG_(syscall_allow_funcs) != NULL
+         && VG_(strIsMemberXA)(FG_(syscall_allow_funcs), fnname)) {
+
+      /* White list */
+      return False;
+   }
+
+   if (FG_(callstack_exists)(ecu)) {
+      return False;
+   } else {
+      FG_(syscall_new_callstack_count)++;
+
+      /* This test must come after the callstack_exists() check, otherwise
+       * FG_(syscall_new_callstack_count) will be wrong. */
+      if (FG_(clo_syscall_max_fails) > 0 && FG_(syscall_fail_count) >= FG_(clo_syscall_max_fails)) {
+         return False;
+      }
+
+      if (FG_(random_100)() < FG_(clo_syscall_fail_chance)) {
+         /* We are now going to fail the syscall - so find out what errno to use */
+         *force_errno = get_fn_errno(fnname);
+         if (*force_errno == -1) {
+            /* --syscall-specified-only=yes and fn not specified, so don't fail */
+            return False;
+         }
+
+         FG_(add_callstack_to_hashtable)(exe, ecu);
+         FG_(write_callstack)(ips, *n_ips);
+         return True;
+      } else {
+         return False;
+      }
+   }
+}
+
+
+//------------------------------------------------------------//
+//--- Syscalls                                             ---//
+//------------------------------------------------------------//
+
+void FG_(pre_syscall)(ThreadId tid, SyscallStatus* status, UInt syscallno,
+                           UWord* args, UInt nArgs)
+{
+   UWord ips[VG_(clo_backtrace_size)];
+   UInt n_ips;
+   Int force_errno;
+
+   if (FG_(in_main)) {
+      if (should_syscall_fail(tid, ips, &n_ips, &force_errno)) {
+         if (FG_(clo_print_failed_traces)) {
+            VG_(pp_StackTrace)(VG_(current_DiEpoch)(), ips, n_ips);
+            VG_(umsg)("\n");
+         }
+
+         VG_(force_syscall_error)(status, force_errno);
+         FG_(syscall_fail_count)++;
+      } else {
+         FG_(syscall_success_count)++;
+      }
+   }
+}
+
+void FG_(post_syscall)(ThreadId tid, UInt syscallno,
+                            UWord* args, UInt nArgs, SysRes res)
+{
+}
+
+
+//------------------------------------------------------------//
+//--- CLO parsing                                          ---//
+//------------------------------------------------------------//
+
+void FG_(parse_syscall_errno)(const HChar* arg, const HChar* value)
+{
+   Int tmp_errno;
+
+   tmp_errno = fg_str2errno(value);
+   if (tmp_errno != -1) {
+      /* String matches against just an error, so set the global return value */
+      g_syscall_errno = tmp_errno;
+   } else {
+      /* Doesn't match a simple error, try to see if it matches <syscall>,<error> instead */
+      if (VG_(strchr)(value, ',') == NULL) {
+         VG_(fmsg_bad_option)(arg,
+            "Invalid --syscall-errno argument. Use either \"<syscall>,<error>\" or \"<error>\"\n");
+      }
+
+      if (value[0] == ',') {
+         VG_(fmsg_bad_option)(arg,
+            "Invalid --syscall-errno argument. Empty function name.\n");
+      }
+
+      HChar* tmp_str = VG_(strdup)("fg.syscall-errno", value);
+      HChar* func;
+      HChar *err_str;
+
+      func = VG_(strtok)(tmp_str, ",");
+      err_str = VG_(strtok)(NULL, ",");
+
+      if (err_str && VG_(strlen)(err_str)) {
+         tmp_errno = fg_str2errno(err_str);
+      }
+      if (tmp_errno == -1) {
+         VG_(free)(tmp_str);
+         VG_(fmsg_bad_option)(arg,
+            "Invalid --syscall-errno argument. Unrecognised error value.\n");
+
+      } else {
+         if (g_syscall_errno_values == NULL) {
+            g_syscall_errno_values = VG_(HT_construct)("fg.syscall.errno.values.ht");
+         }
+
+         VgHashNode_errno *node = VG_(malloc)("fg.syscall-errno-values.node", sizeof(VgHashNode_errno));
+         VgHashNode_errno *found_node;
+         node->next = NULL;
+         node->key = func[0];
+         node->fnname = VG_(strdup)("fg.syscall-errno-values.func", func);
+         node->errno = tmp_errno;
+
+         found_node = VG_(HT_gen_lookup)(g_syscall_errno_values, node, fg_cmp_errno);
+         if (found_node != NULL) {
+            VG_(fmsg_bad_option)(arg, "Duplicate syscall specified in --syscall-errno\n");
+         }
+
+         VG_(HT_add_node)(g_syscall_errno_values, node);
+      }
+      VG_(free)(tmp_str);
+   }
+}
+
+
+//------------------------------------------------------------//
+//--- Platform specific string to errno conversion         ---//
+//------------------------------------------------------------//
+
+#if defined(VGO_linux)
+Int fg_str2errno(const HChar* str)
+{
+   if(!VG_(strcasecmp)(str, "EPERM"))            return VKI_EPERM;
+   else if(!VG_(strcasecmp)(str, "ENOENT"))      return VKI_ENOENT;
+   else if(!VG_(strcasecmp)(str, "ESRCH"))       return VKI_ESRCH;
+   else if(!VG_(strcasecmp)(str, "EINTR"))       return VKI_EINTR;
+   else if(!VG_(strcasecmp)(str, "EIO"))         return VKI_EIO;
+   else if(!VG_(strcasecmp)(str, "ENXIO"))       return VKI_ENXIO;
+   else if(!VG_(strcasecmp)(str, "E2BIG"))       return VKI_E2BIG;
+   else if(!VG_(strcasecmp)(str, "ENOEXEC"))     return VKI_ENOEXEC;
+   else if(!VG_(strcasecmp)(str, "EBADF"))       return VKI_EBADF;
+   else if(!VG_(strcasecmp)(str, "ECHILD"))      return VKI_ECHILD;
+   else if(!VG_(strcasecmp)(str, "EAGAIN"))      return VKI_EAGAIN;
+   else if(!VG_(strcasecmp)(str, "ENOMEM"))      return VKI_ENOMEM;
+   else if(!VG_(strcasecmp)(str, "EACCES"))      return VKI_EACCES;
+   else if(!VG_(strcasecmp)(str, "EFAULT"))      return VKI_EFAULT;
+   else if(!VG_(strcasecmp)(str, "ENOTBLK"))     return VKI_ENOTBLK;
+   else if(!VG_(strcasecmp)(str, "EBUSY"))       return VKI_EBUSY;
+   else if(!VG_(strcasecmp)(str, "EEXIST"))      return VKI_EEXIST;
+   else if(!VG_(strcasecmp)(str, "EXDEV"))       return VKI_EXDEV;
+   else if(!VG_(strcasecmp)(str, "ENODEV"))      return VKI_ENODEV;
+   else if(!VG_(strcasecmp)(str, "ENOTDIR"))     return VKI_ENOTDIR;
+   else if(!VG_(strcasecmp)(str, "EISDIR"))      return VKI_EISDIR;
+   else if(!VG_(strcasecmp)(str, "EINVAL"))      return VKI_EINVAL;
+   else if(!VG_(strcasecmp)(str, "ENFILE"))      return VKI_ENFILE;
+   else if(!VG_(strcasecmp)(str, "EMFILE"))      return VKI_EMFILE;
+   else if(!VG_(strcasecmp)(str, "ENOTTY"))      return VKI_ENOTTY;
+   else if(!VG_(strcasecmp)(str, "ETXTBSY"))     return VKI_ETXTBSY;
+   else if(!VG_(strcasecmp)(str, "EFBIG"))       return VKI_EFBIG;
+   else if(!VG_(strcasecmp)(str, "ENOSPC"))      return VKI_ENOSPC;
+   else if(!VG_(strcasecmp)(str, "ESPIPE"))      return VKI_ESPIPE;
+   else if(!VG_(strcasecmp)(str, "EROFS"))       return VKI_EROFS;
+   else if(!VG_(strcasecmp)(str, "EMLINK"))      return VKI_EMLINK;
+   else if(!VG_(strcasecmp)(str, "EPIPE"))       return VKI_EPIPE;
+   else if(!VG_(strcasecmp)(str, "EDOM"))        return VKI_EDOM;
+   else if(!VG_(strcasecmp)(str, "ERANGE"))      return VKI_ERANGE;
+   else if(!VG_(strcasecmp)(str, "EWOULDBLOCK")) return VKI_EWOULDBLOCK;
+   else if(!VG_(strcasecmp)(str, "ENOSYS"))      return VKI_ENOSYS;
+   else if(!VG_(strcasecmp)(str, "EOVERFLOW"))   return VKI_EOVERFLOW;
+   else                                          return -1;
+}
+
+#elif defined(VGO_darwin)
+Int fg_str2errno(const HChar* str)
+{
+   if(!VG_(strcasecmp)(str, "EPERM"))               return VKI_EPERM;
+   else if(!VG_(strcasecmp)(str, "ENOENT"))         return VKI_ENOENT;
+   else if(!VG_(strcasecmp)(str, "ESRCH"))          return VKI_ESRCH;
+   else if(!VG_(strcasecmp)(str, "EINTR"))          return VKI_EINTR;
+   else if(!VG_(strcasecmp)(str, "EIO"))            return VKI_EIO;
+   else if(!VG_(strcasecmp)(str, "ENXIO"))          return VKI_ENXIO;
+   else if(!VG_(strcasecmp)(str, "E2BIG"))          return VKI_E2BIG;
+   else if(!VG_(strcasecmp)(str, "ENOEXEC"))        return VKI_ENOEXEC;
+   else if(!VG_(strcasecmp)(str, "EBADF"))          return VKI_EBADF;
+   else if(!VG_(strcasecmp)(str, "ECHILD"))         return VKI_ECHILD;
+   else if(!VG_(strcasecmp)(str, "EDEADLK"))        return VKI_EDEADLK;
+   else if(!VG_(strcasecmp)(str, "ENOMEM"))         return VKI_ENOMEM;
+   else if(!VG_(strcasecmp)(str, "EACCES"))         return VKI_EACCES;
+   else if(!VG_(strcasecmp)(str, "EFAULT"))         return VKI_EFAULT;
+   else if(!VG_(strcasecmp)(str, "ENOTBLK"))        return VKI_ENOTBLK;
+   else if(!VG_(strcasecmp)(str, "EBUSY"))          return VKI_EBUSY;
+   else if(!VG_(strcasecmp)(str, "EEXIST"))         return VKI_EEXIST;
+   else if(!VG_(strcasecmp)(str, "EXDEV"))          return VKI_EXDEV;
+   else if(!VG_(strcasecmp)(str, "ENODEV"))         return VKI_ENODEV;
+   else if(!VG_(strcasecmp)(str, "ENOTDIR"))        return VKI_ENOTDIR;
+   else if(!VG_(strcasecmp)(str, "EISDIR"))         return VKI_EISDIR;
+   else if(!VG_(strcasecmp)(str, "EINVAL"))         return VKI_EINVAL;
+   else if(!VG_(strcasecmp)(str, "ENFILE"))         return VKI_ENFILE;
+   else if(!VG_(strcasecmp)(str, "EMFILE"))         return VKI_EMFILE;
+   else if(!VG_(strcasecmp)(str, "ENOTTY"))         return VKI_ENOTTY;
+   else if(!VG_(strcasecmp)(str, "ETXTBSY"))        return VKI_ETXTBSY;
+   else if(!VG_(strcasecmp)(str, "EFBIG"))          return VKI_EFBIG;
+   else if(!VG_(strcasecmp)(str, "ENOSPC"))         return VKI_ENOSPC;
+   else if(!VG_(strcasecmp)(str, "ESPIPE"))         return VKI_ESPIPE;
+   else if(!VG_(strcasecmp)(str, "EROFS"))          return VKI_EROFS;
+   else if(!VG_(strcasecmp)(str, "EMLINK"))         return VKI_EMLINK;
+   else if(!VG_(strcasecmp)(str, "EPIPE"))          return VKI_EPIPE;
+   else if(!VG_(strcasecmp)(str, "EDOM"))           return VKI_EDOM;
+   else if(!VG_(strcasecmp)(str, "ERANGE"))         return VKI_ERANGE;
+   else if(!VG_(strcasecmp)(str, "EAGAIN"))         return VKI_EAGAIN;
+   else if(!VG_(strcasecmp)(str, "EINPROGRESS"))    return VKI_EINPROGRESS;
+   else if(!VG_(strcasecmp)(str, "EALREADY"))       return VKI_EALREADY;
+   else if(!VG_(strcasecmp)(str, "ENOTSOCK"))       return VKI_ENOTSOCK;
+   else if(!VG_(strcasecmp)(str, "EDESTADDRREQ"))   return VKI_EDESTADDRREQ;
+   else if(!VG_(strcasecmp)(str, "EMSGSIZE"))       return VKI_EMSGSIZE;
+   else if(!VG_(strcasecmp)(str, "EPROTOTYPE"))     return VKI_EPROTOTYPE;
+   else if(!VG_(strcasecmp)(str, "ENOPROTOOPT"))    return VKI_ENOPROTOOPT;
+   else if(!VG_(strcasecmp)(str, "EPROTONOSUPPORT"))return VKI_EPROTONOSUPPORT;
+   else if(!VG_(strcasecmp)(str, "ESOCKTNOSUPPORT"))return VKI_ESOCKTNOSUPPORT;
+   else if(!VG_(strcasecmp)(str, "ENOTSUP"))        return VKI_ENOTSUP;
+   else if(!VG_(strcasecmp)(str, "EPFNOSUPPORT"))   return VKI_EPFNOSUPPORT;
+   else if(!VG_(strcasecmp)(str, "EAFNOSUPPORT"))   return VKI_EAFNOSUPPORT;
+   else if(!VG_(strcasecmp)(str, "EADDRINUSE"))     return VKI_EADDRINUSE;
+   else if(!VG_(strcasecmp)(str, "EADDRNOTAVAIL"))  return VKI_EADDRNOTAVAIL;
+   else if(!VG_(strcasecmp)(str, "ENETDOWN"))       return VKI_ENETDOWN;
+   else if(!VG_(strcasecmp)(str, "ENETUNREACH"))    return VKI_ENETUNREACH;
+   else if(!VG_(strcasecmp)(str, "ENETRESET"))      return VKI_ENETRESET;
+   else if(!VG_(strcasecmp)(str, "ECONNABORTED"))   return VKI_ECONNABORTED;
+   else if(!VG_(strcasecmp)(str, "ECONNRESET"))     return VKI_ECONNRESET;
+   else if(!VG_(strcasecmp)(str, "ENOBUFS"))        return VKI_ENOBUFS;
+   else if(!VG_(strcasecmp)(str, "EISCONN"))        return VKI_EISCONN;
+   else if(!VG_(strcasecmp)(str, "ENOTCONN"))       return VKI_ENOTCONN;
+   else if(!VG_(strcasecmp)(str, "ESHUTDOWN"))      return VKI_ESHUTDOWN;
+   else if(!VG_(strcasecmp)(str, "ETOOMANYREFS"))   return VKI_ETOOMANYREFS;
+   else if(!VG_(strcasecmp)(str, "ETIMEDOUT"))      return VKI_ETIMEDOUT;
+   else if(!VG_(strcasecmp)(str, "ECONNREFUSED"))   return VKI_ECONNREFUSED;
+   else if(!VG_(strcasecmp)(str, "ELOOP"))          return VKI_ELOOP;
+   else if(!VG_(strcasecmp)(str, "ENAMETOOLONG"))   return VKI_ENAMETOOLONG;
+   else if(!VG_(strcasecmp)(str, "EHOSTDOWN"))      return VKI_EHOSTDOWN;
+   else if(!VG_(strcasecmp)(str, "EHOSTUNREACH"))   return VKI_EHOSTUNREACH;
+   else if(!VG_(strcasecmp)(str, "ENOTEMPTY"))      return VKI_ENOTEMPTY;
+   else if(!VG_(strcasecmp)(str, "EPROCLIM"))       return VKI_EPROCLIM;
+   else if(!VG_(strcasecmp)(str, "EUSERS"))         return VKI_EUSERS;
+   else if(!VG_(strcasecmp)(str, "EDQUOT"))         return VKI_EDQUOT;
+   else if(!VG_(strcasecmp)(str, "ESTALE"))         return VKI_ESTALE;
+   else if(!VG_(strcasecmp)(str, "EREMOTE"))        return VKI_EREMOTE;
+   else if(!VG_(strcasecmp)(str, "EBADRPC"))        return VKI_EBADRPC;
+   else if(!VG_(strcasecmp)(str, "ERPCMISMATCH"))   return VKI_ERPCMISMATCH;
+   else if(!VG_(strcasecmp)(str, "EPROGUNAVAIL"))   return VKI_EPROGUNAVAIL;
+   else if(!VG_(strcasecmp)(str, "EPROGMISMATCH"))  return VKI_EPROGMISMATCH;
+   else if(!VG_(strcasecmp)(str, "EPROCUNAVAIL"))   return VKI_EPROCUNAVAIL;
+   else if(!VG_(strcasecmp)(str, "ENOLCK"))         return VKI_ENOLCK;
+   else if(!VG_(strcasecmp)(str, "ENOSYS"))         return VKI_ENOSYS;
+   else if(!VG_(strcasecmp)(str, "EFTYPE"))         return VKI_EFTYPE;
+   else if(!VG_(strcasecmp)(str, "EAUTH"))          return VKI_EAUTH;
+   else if(!VG_(strcasecmp)(str, "ENEEDAUTH"))      return VKI_ENEEDAUTH;
+   else if(!VG_(strcasecmp)(str, "EPWROFF"))        return VKI_EPWROFF;
+   else if(!VG_(strcasecmp)(str, "EDEVERR"))        return VKI_EDEVERR;
+   else if(!VG_(strcasecmp)(str, "EOVERFLOW"))      return VKI_EOVERFLOW;
+   else if(!VG_(strcasecmp)(str, "EBADEXEC"))       return VKI_EBADEXEC;
+   else if(!VG_(strcasecmp)(str, "EBADARCH"))       return VKI_EBADARCH;
+   else if(!VG_(strcasecmp)(str, "ESHLIBVERS"))     return VKI_ESHLIBVERS;
+   else if(!VG_(strcasecmp)(str, "EBADMACHO"))      return VKI_EBADMACHO;
+   else if(!VG_(strcasecmp)(str, "ECANCELED"))      return VKI_ECANCELED;
+   else if(!VG_(strcasecmp)(str, "EIDRM"))          return VKI_EIDRM;
+   else if(!VG_(strcasecmp)(str, "ENOMSG"))         return VKI_ENOMSG;
+   else if(!VG_(strcasecmp)(str, "EILSEQ"))         return VKI_EILSEQ;
+   else if(!VG_(strcasecmp)(str, "ENOATTR"))        return VKI_ENOATTR;
+   else if(!VG_(strcasecmp)(str, "EBADMSG"))        return VKI_EBADMSG;
+   else if(!VG_(strcasecmp)(str, "EMULTIHOP"))      return VKI_EMULTIHOP;
+   else if(!VG_(strcasecmp)(str, "ENODATA"))        return VKI_ENODATA;
+   else if(!VG_(strcasecmp)(str, "ENOLINK"))        return VKI_ENOLINK;
+   else if(!VG_(strcasecmp)(str, "ENOSR"))          return VKI_ENOSR;
+   else if(!VG_(strcasecmp)(str, "ENOSTR"))         return VKI_ENOSTR;
+   else if(!VG_(strcasecmp)(str, "EPROTO"))         return VKI_EPROTO;
+   else if(!VG_(strcasecmp)(str, "ETIME"))          return VKI_ETIME;
+   else if(!VG_(strcasecmp)(str, "EOPNOTSUPP"))     return VKI_EOPNOTSUPP;
+   else if(!VG_(strcasecmp)(str, "ELAST"))          return VKI_ELAST;
+   else                                             return -1;
+}
+
+#elif defined(VGO_solaris)
+Int fg_str2errno(const HChar* str)
+{
+   if(!VG_(strcasecmp)(str, "EPERM"))           return VKI_EPERM;
+   else if(!VG_(strcasecmp)(str, "ENOENT"))     return VKI_ENOENT;
+   else if(!VG_(strcasecmp)(str, "ESRCH"))      return VKI_ESRCH;
+   else if(!VG_(strcasecmp)(str, "EINTR"))      return VKI_EINTR;
+   else if(!VG_(strcasecmp)(str, "EIO"))        return VKI_EIO;
+   else if(!VG_(strcasecmp)(str, "ENXIO"))      return VKI_ENXIO;
+   else if(!VG_(strcasecmp)(str, "E2BIG"))      return VKI_E2BIG;
+   else if(!VG_(strcasecmp)(str, "EBADF"))      return VKI_EBADF;
+   else if(!VG_(strcasecmp)(str, "ECHILD"))     return VKI_ECHILD;
+   else if(!VG_(strcasecmp)(str, "ENOEXEC"))    return VKI_ENOEXEC;
+   else if(!VG_(strcasecmp)(str, "EAGAIN"))     return VKI_EAGAIN;
+   else if(!VG_(strcasecmp)(str, "ENOMEM"))     return VKI_ENOMEM;
+   else if(!VG_(strcasecmp)(str, "EACCES"))     return VKI_EACCES;
+   else if(!VG_(strcasecmp)(str, "EFAULT"))     return VKI_EFAULT;
+   else if(!VG_(strcasecmp)(str, "ENOTBLK"))    return VKI_ENOTBLK;
+   else if(!VG_(strcasecmp)(str, "EBUSY"))      return VKI_EBUSY;
+   else if(!VG_(strcasecmp)(str, "EEXIST"))     return VKI_EEXIST;
+   else if(!VG_(strcasecmp)(str, "EXDEV"))      return VKI_EXDEV;
+   else if(!VG_(strcasecmp)(str, "ENODEV"))     return VKI_ENODEV;
+   else if(!VG_(strcasecmp)(str, "ENOTDIR"))    return VKI_ENOTDIR;
+   else if(!VG_(strcasecmp)(str, "EISDIR"))     return VKI_EISDIR;
+   else if(!VG_(strcasecmp)(str, "EINVAL"))     return VKI_EINVAL;
+   else if(!VG_(strcasecmp)(str, "ENFILE"))     return VKI_ENFILE;
+   else if(!VG_(strcasecmp)(str, "EMFILE"))     return VKI_EMFILE;
+   else if(!VG_(strcasecmp)(str, "ENOTTY"))     return VKI_ENOTTY;
+   else if(!VG_(strcasecmp)(str, "ETXTBSY"))    return VKI_ETXTBSY;
+   else if(!VG_(strcasecmp)(str, "EFBIG"))      return VKI_EFBIG;
+   else if(!VG_(strcasecmp)(str, "ENOSPC"))     return VKI_ENOSPC;
+   else if(!VG_(strcasecmp)(str, "ESPIPE"))     return VKI_ESPIPE;
+   else if(!VG_(strcasecmp)(str, "EROFS"))      return VKI_EROFS;
+   else if(!VG_(strcasecmp)(str, "EMLINK"))     return VKI_EMLINK;
+   else if(!VG_(strcasecmp)(str, "EPIPE"))      return VKI_EPIPE;
+   else if(!VG_(strcasecmp)(str, "EDOM"))       return VKI_EDOM;
+   else if(!VG_(strcasecmp)(str, "ERANGE"))     return VKI_ERANGE;
+   else if(!VG_(strcasecmp)(str, "ENOTSUP"))    return VKI_ENOTSUP;
+   else if(!VG_(strcasecmp)(str, "ENODATA"))    return VKI_ENODATA;
+   else if(!VG_(strcasecmp)(str, "EOVERFLOW"))  return VKI_EOVERFLOW;
+   else if(!VG_(strcasecmp)(str, "ENOSYS"))     return VKI_ENOSYS;
+   else if(!VG_(strcasecmp)(str, "ERESTART"))   return VKI_ERESTART;
+   else if(!VG_(strcasecmp)(str, "EADDRINUSE")) return VKI_EADDRINUSE;
+   else                                         return -1;
+}
+
+#else
+#  error Unknown Plat/OS
+#endif
diff --git a/exp-failgrind/tests/Makefile.am b/exp-failgrind/tests/Makefile.am
new file mode 100644
index 000000000..fde7e0ba6
--- /dev/null
+++ b/exp-failgrind/tests/Makefile.am
@@ -0,0 +1,45 @@
+
+include $(top_srcdir)/Makefile.tool-tests.am
+
+SUBDIRS = .
+DIST_SUBDIRS = .
+
+dist_noinst_SCRIPTS = filter_stderr
+
+EXTRA_DIST = \
+	alloc_atstart.vgtest alloc_atstart.stderr.exp \
+	alloc_clreq1.vgtest alloc_clreq1.stderr.exp alloc_clreq1.stdout.exp \
+	alloc_clreq2.vgtest alloc_clreq2.stderr.exp alloc_clreq2.stdout.exp \
+	alloc_fail_chance.vgtest alloc_fail_chance.stderr.exp \
+	alloc_input1.vgtest alloc_input1.stderr.exp \
+	alloc_input2.vgtest alloc_input2.stderr.exp \
+	alloc_max_fails.vgtest alloc_max_fails.stderr.exp \
+	alloc_thresh_low.vgtest alloc_thresh_low.stderr.exp \
+	alloc_thresh_high.vgtest alloc_thresh_high.stderr.exp \
+	alloc_thresh_high_low.vgtest alloc_thresh_high_low.stderr.exp \
+	alloc_thresh_low_invert.vgtest alloc_thresh_low_invert.stderr.exp \
+	alloc_thresh_high_invert.vgtest alloc_thresh_high_invert.stderr.exp \
+	alloc_thresh_high_low_invert1.vgtest alloc_thresh_high_low_invert1.stderr.exp \
+	alloc_thresh_high_low_invert2.vgtest alloc_thresh_high_low_invert2.stderr.exp \
+	alloc_toggle_1.vgtest alloc_toggle_1.stderr.exp \
+	no_stats.vgtest no_stats.stderr.exp \
+	syscall_atstart.vgtest \
+	syscall_errno.vgtest syscall_errno_specific1.vgtest syscall_errno_specific2.vgtest \
+	syscall_toggle_1.vgtest
+
+check_PROGRAMS = alloc_atstart \
+				 alloc_clreq1 alloc_clreq2 \
+				 alloc_fail_chance \
+				 alloc_input \
+				 alloc_max_fails \
+				 alloc_thresh_low alloc_thresh_low_invert \
+				 alloc_thresh_high alloc_thresh_high_invert \
+				 alloc_thresh_high_low alloc_thresh_high_low_invert1 alloc_thresh_high_low_invert2 \
+				 alloc_toggle_1 \
+				 no_stats \
+				 syscall_atstart \
+				 syscall_errno syscall_errno_specific1 syscall_errno_specific2 \
+				 syscall_toggle_1
+
+AM_CFLAGS   += $(AM_FLAG_M3264_PRI)
+AM_CXXFLAGS += $(AM_FLAG_M3264_PRI)
diff --git a/exp-failgrind/tests/alloc_atstart.c b/exp-failgrind/tests/alloc_atstart.c
new file mode 100644
index 000000000..c7044104c
--- /dev/null
+++ b/exp-failgrind/tests/alloc_atstart.c
@@ -0,0 +1,25 @@
+#include <stdlib.h>
+
+/* These should all succeed, atstart=no and we don't enable fails at any point. */
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_atstart.stderr.exp b/exp-failgrind/tests/alloc_atstart.stderr.exp
new file mode 100644
index 000000000..a1dbe0edc
--- /dev/null
+++ b/exp-failgrind/tests/alloc_atstart.stderr.exp
@@ -0,0 +1,7 @@
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_atstart.vgtest b/exp-failgrind/tests/alloc_atstart.vgtest
new file mode 100644
index 000000000..b02d3a16b
--- /dev/null
+++ b/exp-failgrind/tests/alloc_atstart.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_atstart
+vgopts: --callstack-output=no --show-failed=yes --alloc-fail-atstart=no
diff --git a/exp-failgrind/tests/alloc_clreq1.c b/exp-failgrind/tests/alloc_clreq1.c
new file mode 100644
index 000000000..66f471134
--- /dev/null
+++ b/exp-failgrind/tests/alloc_clreq1.c
@@ -0,0 +1,101 @@
+#include "stdio.h"
+#include "stdlib.h"
+#include "../failgrind.h"
+
+int f_a(void)
+{
+   int* p;
+
+   p = malloc(34);
+   if (p) {
+      p[4] = 34;
+      free(p);
+      return 1;
+   }
+   return 0;
+}
+
+int f_b(void)
+{
+   int* p;
+
+   p = malloc(34);
+   if (p) {
+      p[4] = 34;
+      free(p);
+      return 1;
+   }
+   return 0;
+}
+
+int f_c(void)
+{
+   int* p;
+
+   p = malloc(34);
+   if (p) {
+      p[4] = 34;
+      free(p);
+      return 1;
+   }
+   return 0;
+}
+
+int f_d(void)
+{
+   int* p;
+
+   p = malloc(34);
+   if (p) {
+      p[4] = 34;
+      free(p);
+      return 1;
+   }
+   return 0;
+}
+
+
+void run_test1(void)
+{
+   f_a();
+   f_b();
+   f_c();
+   f_d();
+}
+
+void run_test2(void)
+{
+   if (!f_a()) return;
+   if (!f_b()) return;
+   if (!f_c()) return;
+   if (!f_d()) return;
+}
+
+
+int main(int argc, char* argv[])
+{
+   do {
+      FAILGRIND_ZERO_COUNTS;
+      FAILGRIND_ALLOC_FAIL_ON;
+      run_test1();
+      FAILGRIND_ALLOC_FAIL_OFF;
+      printf("Test 1 success count: %d, fail count: %d\n",
+            FAILGRIND_ALLOC_GET_SUCCESS_COUNT,
+            FAILGRIND_ALLOC_GET_FAIL_COUNT);
+     } while(FAILGRIND_ALLOC_GET_FAIL_COUNT > 0);
+
+   FAILGRIND_CALLSTACK_CLEAR;
+
+   do {
+      FAILGRIND_ZERO_COUNTS;
+      FAILGRIND_ALLOC_FAIL_ON;
+      run_test2();
+      FAILGRIND_ALLOC_FAIL_OFF;
+      printf("Test 2 success count: %d, fail count: %d\n",
+            FAILGRIND_ALLOC_GET_SUCCESS_COUNT,
+            FAILGRIND_ALLOC_GET_FAIL_COUNT);
+   } while(FAILGRIND_ALLOC_GET_FAIL_COUNT > 0);
+   FAILGRIND_CALLSTACK_CLEAR;
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_clreq1.stderr.exp b/exp-failgrind/tests/alloc_clreq1.stderr.exp
new file mode 100644
index 000000000..001faa354
--- /dev/null
+++ b/exp-failgrind/tests/alloc_clreq1.stderr.exp
@@ -0,0 +1,47 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_clreq1.c:9)
+   by 0x........: run_test1 (alloc_clreq1.c:60)
+   by 0x........: main (alloc_clreq1.c:80)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_b (alloc_clreq1.c:22)
+   by 0x........: run_test1 (alloc_clreq1.c:61)
+   by 0x........: main (alloc_clreq1.c:80)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_c (alloc_clreq1.c:35)
+   by 0x........: run_test1 (alloc_clreq1.c:62)
+   by 0x........: main (alloc_clreq1.c:80)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_d (alloc_clreq1.c:48)
+   by 0x........: run_test1 (alloc_clreq1.c:63)
+   by 0x........: main (alloc_clreq1.c:80)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_clreq1.c:9)
+   by 0x........: run_test2 (alloc_clreq1.c:68)
+   by 0x........: main (alloc_clreq1.c:92)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_b (alloc_clreq1.c:22)
+   by 0x........: run_test2 (alloc_clreq1.c:69)
+   by 0x........: main (alloc_clreq1.c:92)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_c (alloc_clreq1.c:35)
+   by 0x........: run_test2 (alloc_clreq1.c:70)
+   by 0x........: main (alloc_clreq1.c:92)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_d (alloc_clreq1.c:48)
+   by 0x........: run_test2 (alloc_clreq1.c:71)
+   by 0x........: main (alloc_clreq1.c:92)
+ Failgrind: 0 call stacks loaded from file
+            4 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            2 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_clreq1.stdout.exp b/exp-failgrind/tests/alloc_clreq1.stdout.exp
new file mode 100644
index 000000000..f6807483e
--- /dev/null
+++ b/exp-failgrind/tests/alloc_clreq1.stdout.exp
@@ -0,0 +1,7 @@
+Test 1 success count: 0, fail count: 4
+Test 1 success count: 4, fail count: 0
+Test 2 success count: 0, fail count: 1
+Test 2 success count: 1, fail count: 1
+Test 2 success count: 2, fail count: 1
+Test 2 success count: 3, fail count: 1
+Test 2 success count: 4, fail count: 0
diff --git a/exp-failgrind/tests/alloc_clreq1.vgtest b/exp-failgrind/tests/alloc_clreq1.vgtest
new file mode 100644
index 000000000..06c5f1deb
--- /dev/null
+++ b/exp-failgrind/tests/alloc_clreq1.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_clreq1
+vgopts: --callstack-output=no --show-failed=yes
diff --git a/exp-failgrind/tests/alloc_clreq2.c b/exp-failgrind/tests/alloc_clreq2.c
new file mode 100644
index 000000000..76d308150
--- /dev/null
+++ b/exp-failgrind/tests/alloc_clreq2.c
@@ -0,0 +1,101 @@
+#include "stdio.h"
+#include "stdlib.h"
+#include "../failgrind.h"
+
+int f_a(void)
+{
+   int* p;
+
+   p = malloc(34);
+   if (p) {
+      p[4] = 34;
+      free(p);
+      return 1;
+   }
+   return 0;
+}
+
+int f_b(void)
+{
+   int* p;
+
+   p = malloc(34);
+   if (p) {
+      p[4] = 34;
+      free(p);
+      return 1;
+   }
+   return 0;
+}
+
+int f_c(void)
+{
+   int* p;
+
+   p = malloc(34);
+   if (p) {
+      p[4] = 34;
+      free(p);
+      return 1;
+   }
+   return 0;
+}
+
+int f_d(void)
+{
+   int* p;
+
+   p = malloc(34);
+   if (p) {
+      p[4] = 34;
+      free(p);
+      return 1;
+   }
+   return 0;
+}
+
+
+void run_test1(void)
+{
+   f_a();
+   f_b();
+   f_c();
+   f_d();
+}
+
+void run_test2(void)
+{
+   if (!f_a()) return;
+   if (!f_b()) return;
+   if (!f_c()) return;
+   if (!f_d()) return;
+}
+
+
+int main(int argc, char* argv[])
+{
+   do {
+      FAILGRIND_ZERO_COUNTS;
+      FAILGRIND_ALLOC_FAIL_ON;
+      run_test1();
+      FAILGRIND_ALLOC_FAIL_OFF;
+      printf("Test 1 success count: %d, new callstack count: %d\n",
+            FAILGRIND_ALLOC_GET_SUCCESS_COUNT,
+            FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT);
+     } while(FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT > 0);
+
+   FAILGRIND_CALLSTACK_CLEAR;
+
+   do {
+      FAILGRIND_ZERO_COUNTS;
+      FAILGRIND_ALLOC_FAIL_ON;
+      run_test2();
+      FAILGRIND_ALLOC_FAIL_OFF;
+      printf("Test 2 success count: %d, new callstack count: %d\n",
+            FAILGRIND_ALLOC_GET_SUCCESS_COUNT,
+            FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT);
+   } while(FAILGRIND_ALLOC_GET_NEW_CALLSTACK_COUNT > 0);
+   FAILGRIND_CALLSTACK_CLEAR;
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_clreq2.stderr.exp b/exp-failgrind/tests/alloc_clreq2.stderr.exp
new file mode 100644
index 000000000..d7dfec265
--- /dev/null
+++ b/exp-failgrind/tests/alloc_clreq2.stderr.exp
@@ -0,0 +1,47 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_clreq2.c:9)
+   by 0x........: run_test1 (alloc_clreq2.c:60)
+   by 0x........: main (alloc_clreq2.c:80)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_b (alloc_clreq2.c:22)
+   by 0x........: run_test1 (alloc_clreq2.c:61)
+   by 0x........: main (alloc_clreq2.c:80)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_c (alloc_clreq2.c:35)
+   by 0x........: run_test1 (alloc_clreq2.c:62)
+   by 0x........: main (alloc_clreq2.c:80)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_d (alloc_clreq2.c:48)
+   by 0x........: run_test1 (alloc_clreq2.c:63)
+   by 0x........: main (alloc_clreq2.c:80)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_clreq2.c:9)
+   by 0x........: run_test2 (alloc_clreq2.c:68)
+   by 0x........: main (alloc_clreq2.c:92)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_b (alloc_clreq2.c:22)
+   by 0x........: run_test2 (alloc_clreq2.c:69)
+   by 0x........: main (alloc_clreq2.c:92)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_c (alloc_clreq2.c:35)
+   by 0x........: run_test2 (alloc_clreq2.c:70)
+   by 0x........: main (alloc_clreq2.c:92)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_d (alloc_clreq2.c:48)
+   by 0x........: run_test2 (alloc_clreq2.c:71)
+   by 0x........: main (alloc_clreq2.c:92)
+ Failgrind: 0 call stacks loaded from file
+            4 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            2 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_clreq2.stdout.exp b/exp-failgrind/tests/alloc_clreq2.stdout.exp
new file mode 100644
index 000000000..55a4ec8cc
--- /dev/null
+++ b/exp-failgrind/tests/alloc_clreq2.stdout.exp
@@ -0,0 +1,10 @@
+Test 1 success count: 3, new callstack count: 4
+Test 1 success count: 3, new callstack count: 3
+Test 1 success count: 3, new callstack count: 2
+Test 1 success count: 3, new callstack count: 1
+Test 1 success count: 4, new callstack count: 0
+Test 2 success count: 0, new callstack count: 1
+Test 2 success count: 1, new callstack count: 1
+Test 2 success count: 2, new callstack count: 1
+Test 2 success count: 3, new callstack count: 1
+Test 2 success count: 4, new callstack count: 0
diff --git a/exp-failgrind/tests/alloc_clreq2.vgtest b/exp-failgrind/tests/alloc_clreq2.vgtest
new file mode 100644
index 000000000..2d1e66d06
--- /dev/null
+++ b/exp-failgrind/tests/alloc_clreq2.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_clreq2
+vgopts: --callstack-output=no --show-failed=yes --alloc-max-fails=1
diff --git a/exp-failgrind/tests/alloc_fail_chance.c b/exp-failgrind/tests/alloc_fail_chance.c
new file mode 100644
index 000000000..a91f1c6ac
--- /dev/null
+++ b/exp-failgrind/tests/alloc_fail_chance.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Fails due to "random" chance with fixed seed of 2. */
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should succeed. */
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Fails due to "random" chance with fixed seed of 2. */
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_fail_chance.stderr.exp b/exp-failgrind/tests/alloc_fail_chance.stderr.exp
new file mode 100644
index 000000000..fdd8d4984
--- /dev/null
+++ b/exp-failgrind/tests/alloc_fail_chance.stderr.exp
@@ -0,0 +1,14 @@
+Using random seed: 2
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_fail_chance.c:8)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_fail_chance.c:20)
+ Failgrind: 0 call stacks loaded from file
+            1 allocations succeeded
+            2 allocations failed
+            3 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_fail_chance.vgtest b/exp-failgrind/tests/alloc_fail_chance.vgtest
new file mode 100644
index 000000000..64d78e2ef
--- /dev/null
+++ b/exp-failgrind/tests/alloc_fail_chance.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_fail_chance
+vgopts: --callstack-output=no --show-failed=yes --seed=2 --alloc-fail-chance=50
diff --git a/exp-failgrind/tests/alloc_input.c b/exp-failgrind/tests/alloc_input.c
new file mode 100644
index 000000000..1243d9db9
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input.c
@@ -0,0 +1,34 @@
+#include <stdlib.h>
+
+/* This is a two part test.
+ *
+ * Part 1 runs without a callstack input file and generates an output
+ * callstack file.
+ *
+ * Part 2 uses the callstack file generated by part 1 to test
+ * allocation successes.
+ *
+ * The point of having the two tests is that the output callstack file may have
+ * different addresses on different architectures/builds, so it must be
+ * generated on the fly.
+ */
+
+void f_a(int level)
+{
+   int* p;
+
+   p = malloc(10);
+   if (level > 0) {
+      f_a(level-1);
+   }
+
+   if (p) free(p);
+}
+
+
+int main(int argc, char* argv[])
+{
+   f_a(10);
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_input.callstacks b/exp-failgrind/tests/alloc_input.callstacks
new file mode 100644
index 000000000..6ab94a1ee
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input.callstacks
@@ -0,0 +1,109 @@
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
+
+# ./input
+at 0x4C2E08B: malloc (vg_replace_malloc.c:299)
+by 0x10869E: f_a (input.c:7)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086B5: f_a (input.c:9)
+by 0x1086E4: main (input.c:18)
diff --git a/exp-failgrind/tests/alloc_input.stderr.exp b/exp-failgrind/tests/alloc_input.stderr.exp
new file mode 100644
index 000000000..4efef5a93
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input.stderr.exp
@@ -0,0 +1,9 @@
+
+
+ Failgrind: 11 call stacks loaded from file
+            11 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_input.vgtest b/exp-failgrind/tests/alloc_input.vgtest
new file mode 100644
index 000000000..3ba18f3a5
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_input
+vgopts: --callstack-input=alloc_input.callstacks --callstack-output=no --show-failed=yes
diff --git a/exp-failgrind/tests/alloc_input1.stderr.exp b/exp-failgrind/tests/alloc_input1.stderr.exp
new file mode 100644
index 000000000..9b9874f45
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input1.stderr.exp
@@ -0,0 +1,106 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: f_a (alloc_input.c:20)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: f_a (alloc_input.c:22)
+   by 0x........: main (alloc_input.c:31)
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            11 allocations failed
+            11 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_input1.vgtest b/exp-failgrind/tests/alloc_input1.vgtest
new file mode 100644
index 000000000..029da7076
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input1.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_input
+vgopts: --write-callstacks-at-end=yes --callstack-input=no --callstack-output=alloc_input2.callstacks --show-failed=yes
diff --git a/exp-failgrind/tests/alloc_input2.callstacks b/exp-failgrind/tests/alloc_input2.callstacks
new file mode 100644
index 000000000..4465a30fb
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input2.callstacks
@@ -0,0 +1,110 @@
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
+# ./alloc_input
+at 0x4840813: malloc (vg_replace_malloc.c:380)
+by 0x109181: f_a (alloc_input.c:20)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x109198: f_a (alloc_input.c:22)
+by 0x1091CB: main (alloc_input.c:31)
+
diff --git a/exp-failgrind/tests/alloc_input2.stderr.exp b/exp-failgrind/tests/alloc_input2.stderr.exp
new file mode 100644
index 000000000..79d678ef1
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input2.stderr.exp
@@ -0,0 +1,7 @@
+ Failgrind: 11 call stacks loaded from file
+            11 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_input2.vgtest b/exp-failgrind/tests/alloc_input2.vgtest
new file mode 100644
index 000000000..6a656b546
--- /dev/null
+++ b/exp-failgrind/tests/alloc_input2.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_input
+vgopts: --callstack-input=alloc_input2.callstacks --callstack-output=no --show-failed=yes
diff --git a/exp-failgrind/tests/alloc_max_fails.c b/exp-failgrind/tests/alloc_max_fails.c
new file mode 100644
index 000000000..7625133a2
--- /dev/null
+++ b/exp-failgrind/tests/alloc_max_fails.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Fails */
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should succeed, max fails has been met. */
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should succeed, max fails has been met. */
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_max_fails.stderr.exp b/exp-failgrind/tests/alloc_max_fails.stderr.exp
new file mode 100644
index 000000000..fdbb38a6c
--- /dev/null
+++ b/exp-failgrind/tests/alloc_max_fails.stderr.exp
@@ -0,0 +1,10 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_max_fails.c:8)
+ Failgrind: 0 call stacks loaded from file
+            2 allocations succeeded
+            1 allocations failed
+            3 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_max_fails.vgtest b/exp-failgrind/tests/alloc_max_fails.vgtest
new file mode 100644
index 000000000..f476e3d28
--- /dev/null
+++ b/exp-failgrind/tests/alloc_max_fails.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_max_fails
+vgopts: --callstack-output=no --show-failed=yes --alloc-max-fails=1
diff --git a/exp-failgrind/tests/alloc_thresh_high.c b/exp-failgrind/tests/alloc_thresh_high.c
new file mode 100644
index 000000000..fb93c3e4c
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Should fail the first time. !(99 > 100) */
+   p = malloc(99);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(100 > 100)*/
+   p = malloc(100);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should succeed always (101 > 100) */
+   p = malloc(101);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_thresh_high.stderr.exp b/exp-failgrind/tests/alloc_thresh_high.stderr.exp
new file mode 100644
index 000000000..cfdf47416
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high.stderr.exp
@@ -0,0 +1,13 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high.c:8)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high.c:14)
+ Failgrind: 0 call stacks loaded from file
+            1 allocations succeeded
+            2 allocations failed
+            2 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_thresh_high.vgtest b/exp-failgrind/tests/alloc_thresh_high.vgtest
new file mode 100644
index 000000000..529dbb4fa
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_thresh_high
+vgopts: --callstack-output=no --show-failed=yes --alloc-threshold-high=100
diff --git a/exp-failgrind/tests/alloc_thresh_high_invert.c b/exp-failgrind/tests/alloc_thresh_high_invert.c
new file mode 100644
index 000000000..7770ca7df
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_invert.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Should succeed always (99 < 100) */
+   p = malloc(99);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(100 < 100)*/
+   p = malloc(100);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(101 < 100)*/
+   p = malloc(101);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_thresh_high_invert.stderr.exp b/exp-failgrind/tests/alloc_thresh_high_invert.stderr.exp
new file mode 100644
index 000000000..bad803678
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_invert.stderr.exp
@@ -0,0 +1,13 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_invert.c:14)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_invert.c:20)
+ Failgrind: 0 call stacks loaded from file
+            1 allocations succeeded
+            2 allocations failed
+            2 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_thresh_high_invert.vgtest b/exp-failgrind/tests/alloc_thresh_high_invert.vgtest
new file mode 100644
index 000000000..ed27e8506
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_invert.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_thresh_high_invert
+vgopts: --callstack-output=no --show-failed=yes --alloc-threshold-high=100 --alloc-threshold-invert=yes
diff --git a/exp-failgrind/tests/alloc_thresh_high_low.c b/exp-failgrind/tests/alloc_thresh_high_low.c
new file mode 100644
index 000000000..9f725e9e8
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Should succeed always (99 < 100L)*/
+   p = malloc(99);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(100 < 100L) && !(100 > 100H) */
+   p = malloc(100);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should succeed always (101 > 100H) */
+   p = malloc(101);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_thresh_high_low.stderr.exp b/exp-failgrind/tests/alloc_thresh_high_low.stderr.exp
new file mode 100644
index 000000000..218c2cde0
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low.stderr.exp
@@ -0,0 +1,10 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_low.c:14)
+ Failgrind: 0 call stacks loaded from file
+            2 allocations succeeded
+            1 allocations failed
+            1 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_thresh_high_low.vgtest b/exp-failgrind/tests/alloc_thresh_high_low.vgtest
new file mode 100644
index 000000000..33a25ed93
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_thresh_high_low
+vgopts: --callstack-output=no --show-failed=yes --alloc-threshold-high=100 --alloc-threshold-low=100
diff --git a/exp-failgrind/tests/alloc_thresh_high_low_invert1.c b/exp-failgrind/tests/alloc_thresh_high_low_invert1.c
new file mode 100644
index 000000000..68c2ce22e
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low_invert1.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Should fail the first time. !(99 > 100L) */
+   p = malloc(99);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(100 < 100H) && !(100 > 100L) */
+   p = malloc(100);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(101 < 100H) */
+   p = malloc(101);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_thresh_high_low_invert1.stderr.exp b/exp-failgrind/tests/alloc_thresh_high_low_invert1.stderr.exp
new file mode 100644
index 000000000..f6be829f3
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low_invert1.stderr.exp
@@ -0,0 +1,16 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_low_invert1.c:8)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_low_invert1.c:14)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_low_invert1.c:20)
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            3 allocations failed
+            3 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_thresh_high_low_invert1.vgtest b/exp-failgrind/tests/alloc_thresh_high_low_invert1.vgtest
new file mode 100644
index 000000000..216360533
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low_invert1.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_thresh_high_low_invert1
+vgopts: --callstack-output=no --show-failed=yes --alloc-threshold-high=100 --alloc-threshold-low=100 --alloc-threshold-invert=yes
diff --git a/exp-failgrind/tests/alloc_thresh_high_low_invert2.c b/exp-failgrind/tests/alloc_thresh_high_low_invert2.c
new file mode 100644
index 000000000..4e4fd7a8a
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low_invert2.c
@@ -0,0 +1,39 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Should fail the first time. !(98 > 99L) */
+   p = malloc(98);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(99 > 99L) */
+   p = malloc(99);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should succeed always (100 > 99L && 100 < 101H */
+   p = malloc(100);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(101 < 101H) */
+   p = malloc(101);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(102 < 101H) */
+   p = malloc(102);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_thresh_high_low_invert2.stderr.exp b/exp-failgrind/tests/alloc_thresh_high_low_invert2.stderr.exp
new file mode 100644
index 000000000..bfca6de07
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low_invert2.stderr.exp
@@ -0,0 +1,19 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_low_invert2.c:8)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_low_invert2.c:14)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_low_invert2.c:26)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_high_low_invert2.c:32)
+ Failgrind: 0 call stacks loaded from file
+            1 allocations succeeded
+            4 allocations failed
+            4 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_thresh_high_low_invert2.vgtest b/exp-failgrind/tests/alloc_thresh_high_low_invert2.vgtest
new file mode 100644
index 000000000..bb7d8b137
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_high_low_invert2.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_thresh_high_low_invert2
+vgopts: --callstack-output=no --show-failed=yes --alloc-threshold-high=101 --alloc-threshold-low=99 --alloc-threshold-invert=yes
diff --git a/exp-failgrind/tests/alloc_thresh_low.c b/exp-failgrind/tests/alloc_thresh_low.c
new file mode 100644
index 000000000..6065ea94b
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_low.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Should succeed always - 99 < 100*/
+   p = malloc(99);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(100 < 100) */
+   p = malloc(100);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(101 < 100) */
+   p = malloc(101);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_thresh_low.stderr.exp b/exp-failgrind/tests/alloc_thresh_low.stderr.exp
new file mode 100644
index 000000000..ad4b06ca1
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_low.stderr.exp
@@ -0,0 +1,13 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_low.c:14)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_low.c:20)
+ Failgrind: 0 call stacks loaded from file
+            1 allocations succeeded
+            2 allocations failed
+            2 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_thresh_low.vgtest b/exp-failgrind/tests/alloc_thresh_low.vgtest
new file mode 100644
index 000000000..344009cb6
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_low.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_thresh_low
+vgopts: --callstack-output=no --show-failed=yes --alloc-threshold-low=100
diff --git a/exp-failgrind/tests/alloc_thresh_low_invert.c b/exp-failgrind/tests/alloc_thresh_low_invert.c
new file mode 100644
index 000000000..abe9e408b
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_low_invert.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   /* Should fail the first time. !(99 > 100) */
+   p = malloc(99);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should fail the first time. !(100 > 100) */
+   p = malloc(100);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   /* Should succeed always. (101 > 100) */
+   p = malloc(101);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_thresh_low_invert.stderr.exp b/exp-failgrind/tests/alloc_thresh_low_invert.stderr.exp
new file mode 100644
index 000000000..e92511413
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_low_invert.stderr.exp
@@ -0,0 +1,13 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_low_invert.c:8)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (alloc_thresh_low_invert.c:14)
+ Failgrind: 0 call stacks loaded from file
+            1 allocations succeeded
+            2 allocations failed
+            2 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_thresh_low_invert.vgtest b/exp-failgrind/tests/alloc_thresh_low_invert.vgtest
new file mode 100644
index 000000000..79fc10ab6
--- /dev/null
+++ b/exp-failgrind/tests/alloc_thresh_low_invert.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_thresh_low_invert
+vgopts: --callstack-output=no --show-failed=yes --alloc-threshold-low=100 --alloc-threshold-invert=yes
diff --git a/exp-failgrind/tests/alloc_toggle_1.c b/exp-failgrind/tests/alloc_toggle_1.c
new file mode 100644
index 000000000..cd714d0b1
--- /dev/null
+++ b/exp-failgrind/tests/alloc_toggle_1.c
@@ -0,0 +1,43 @@
+#include <stdlib.h>
+
+void alloc_func(void)
+{
+   char* p;
+
+   p = malloc(10);
+   if (p) {
+      p[5] = 42;
+      free(p);
+   }
+}
+
+void middle(void)
+{
+   alloc_func();
+}
+
+
+void testing(void)
+{
+   middle();
+}
+
+int main(int argc, char* argv[])
+{
+   /* Should succeed, alloc failing is disabled */
+   alloc_func();
+
+   /* Should also succeed. */
+   middle();
+
+   /* Should fail, the testing() function should enable failing */
+   testing();
+
+   /* Should succeed, alloc failing is disabled */
+   alloc_func();
+
+   /* Should also succeed. */
+   middle();
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/alloc_toggle_1.stderr.exp b/exp-failgrind/tests/alloc_toggle_1.stderr.exp
new file mode 100644
index 000000000..f4052bde8
--- /dev/null
+++ b/exp-failgrind/tests/alloc_toggle_1.stderr.exp
@@ -0,0 +1,13 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: alloc_func (alloc_toggle_1.c:7)
+   by 0x........: middle (alloc_toggle_1.c:16)
+   by 0x........: testing (alloc_toggle_1.c:22)
+   by 0x........: main (alloc_toggle_1.c:34)
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            1 allocations failed
+            1 new allocation callstacks found
+            1 syscalls succeeded
+            0 syscalls failed
+            0 new syscall callstacks found
diff --git a/exp-failgrind/tests/alloc_toggle_1.vgtest b/exp-failgrind/tests/alloc_toggle_1.vgtest
new file mode 100644
index 000000000..c2ac51c1f
--- /dev/null
+++ b/exp-failgrind/tests/alloc_toggle_1.vgtest
@@ -0,0 +1,2 @@
+prog: alloc_toggle_1
+vgopts: --callstack-output=no --show-failed=yes --alloc-toggle=testing
diff --git a/exp-failgrind/tests/filter_stderr b/exp-failgrind/tests/filter_stderr
new file mode 100755
index 000000000..1fc7cf7d4
--- /dev/null
+++ b/exp-failgrind/tests/filter_stderr
@@ -0,0 +1,24 @@
+#! /bin/sh
+
+dir=`dirname $0`
+
+$dir/../../tests/filter_stderr_basic                |
+
+# Anonymise addresses
+$dir/../../tests/filter_addresses                   |
+
+# Remove blank lines
+sed -e "/^$/d" |
+
+# Remove non-application line numbers
+sed \
+   -e "s/exit.c:[0-9]\+)/exit.c:...)/g" \
+   -e "s/open64.c:[0-9]\+)/open64.c:...)/g" \
+   -e "s/syscall-template.S:[0-9]\+)/syscall-template.S:...)/g" \
+   |
+
+# Remove "Failgrind, ..." line and the following experimental line and copyright line.
+sed \
+-e "/^Failgrind, a memory allocation and syscall failure testing tool$/d" \
+-e "/^NOTE: This is an Experimental-Class Valgrind Tool$/d"  \
+-e "/^Copyright (C) [0-9]*-*[0-9]*, and GNU GPL'd, by Roger Light and Cedalo AG.$/d"
diff --git a/exp-failgrind/tests/no_stats.c b/exp-failgrind/tests/no_stats.c
new file mode 100644
index 000000000..39cab9f27
--- /dev/null
+++ b/exp-failgrind/tests/no_stats.c
@@ -0,0 +1,24 @@
+#include <stdlib.h>
+
+int main(int argc, char* argv[])
+{
+   int* p;
+
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+   p = malloc(10);
+   if (p) {
+      p[0] = 42;
+      free(p);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/no_stats.stderr.exp b/exp-failgrind/tests/no_stats.stderr.exp
new file mode 100644
index 000000000..d9a598e14
--- /dev/null
+++ b/exp-failgrind/tests/no_stats.stderr.exp
@@ -0,0 +1,9 @@
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (no_stats.c:7)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (no_stats.c:12)
+Heap memory failure
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (no_stats.c:17)
diff --git a/exp-failgrind/tests/no_stats.vgtest b/exp-failgrind/tests/no_stats.vgtest
new file mode 100644
index 000000000..652e61aab
--- /dev/null
+++ b/exp-failgrind/tests/no_stats.vgtest
@@ -0,0 +1,2 @@
+prog: no_stats
+vgopts: --callstack-output=no --show-failed=yes --failgrind-stats=no
diff --git a/exp-failgrind/tests/syscall_atstart.c b/exp-failgrind/tests/syscall_atstart.c
new file mode 100644
index 000000000..dc80f2ddd
--- /dev/null
+++ b/exp-failgrind/tests/syscall_atstart.c
@@ -0,0 +1,25 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+
+int main(int argc, char* argv[])
+{
+   int fd;
+
+   fd = open("syscall_errno.vgtest", O_RDONLY);
+   if (fd < 0) {
+      printf("Failed to open file: ");
+      if (errno == EINVAL) {
+         printf("Invalid input.\n");
+      } else {
+         printf("Incorrect error.\n");
+      }
+   } else {
+      close(fd);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/syscall_atstart.stderr.exp b/exp-failgrind/tests/syscall_atstart.stderr.exp
new file mode 100644
index 000000000..a8c653c1b
--- /dev/null
+++ b/exp-failgrind/tests/syscall_atstart.stderr.exp
@@ -0,0 +1,13 @@
+   at 0x........: open (open64.c:...)
+   by 0x........: main (syscall_atstart.c:12)
+   at 0x........: _Exit (_exit.c:...)
+   by 0x........: __run_exit_handlers (exit.c:...)
+   by 0x........: exit (exit.c:...)
+   by 0x........: (below main)
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            2 syscalls succeeded
+            2 syscalls failed
+            2 new syscall callstacks found
diff --git a/exp-failgrind/tests/syscall_atstart.stdout.exp b/exp-failgrind/tests/syscall_atstart.stdout.exp
new file mode 100644
index 000000000..701a563f2
--- /dev/null
+++ b/exp-failgrind/tests/syscall_atstart.stdout.exp
@@ -0,0 +1 @@
+Failed to open file: Invalid input.
diff --git a/exp-failgrind/tests/syscall_atstart.vgtest b/exp-failgrind/tests/syscall_atstart.vgtest
new file mode 100644
index 000000000..dab824d9b
--- /dev/null
+++ b/exp-failgrind/tests/syscall_atstart.vgtest
@@ -0,0 +1,2 @@
+prog: syscall_atstart
+vgopts: --callstack-input=no --callstack-output=no --show-failed=yes --alloc-fail-atstart=no --syscall-fail-atstart=yes --syscall-allow=write --syscall-allow=_fxstat --syscall-allow=fstatat
diff --git a/exp-failgrind/tests/syscall_errno.c b/exp-failgrind/tests/syscall_errno.c
new file mode 100644
index 000000000..283ae93e4
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno.c
@@ -0,0 +1,25 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+
+int main(int argc, char* argv[])
+{
+   int fd;
+
+   fd = open("syscall_errno.vgtest", O_RDONLY);
+   if (fd < 0) {
+      printf("Failed to open file: ");
+      if (errno == EACCES) {
+         printf("Access denied.\n");
+      } else {
+         printf("Incorrect error.\n");
+      }
+   } else {
+      close(fd);
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/syscall_errno.stderr.exp b/exp-failgrind/tests/syscall_errno.stderr.exp
new file mode 100644
index 000000000..7f3c30836
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno.stderr.exp
@@ -0,0 +1,13 @@
+   at 0x........: open (open64.c:...)
+   by 0x........: main (syscall_errno.c:12)
+   at 0x........: _Exit (_exit.c:...)
+   by 0x........: __run_exit_handlers (exit.c:...)
+   by 0x........: exit (exit.c:...)
+   by 0x........: (below main)
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            2 syscalls succeeded
+            2 syscalls failed
+            2 new syscall callstacks found
diff --git a/exp-failgrind/tests/syscall_errno.stdout.exp b/exp-failgrind/tests/syscall_errno.stdout.exp
new file mode 100644
index 000000000..f684ffc42
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno.stdout.exp
@@ -0,0 +1 @@
+Failed to open file: Access denied.
diff --git a/exp-failgrind/tests/syscall_errno.vgtest b/exp-failgrind/tests/syscall_errno.vgtest
new file mode 100644
index 000000000..1d3ed3597
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno.vgtest
@@ -0,0 +1,2 @@
+prog: syscall_errno
+vgopts: --callstack-output=no --show-failed=yes --alloc-fail-atstart=no --syscall-fail-atstart=yes --syscall-errno=EACCES --syscall-allow=write --syscall-allow=_fxstat --syscall-allow=fstatat
diff --git a/exp-failgrind/tests/syscall_errno_specific1.c b/exp-failgrind/tests/syscall_errno_specific1.c
new file mode 100644
index 000000000..994d24b05
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific1.c
@@ -0,0 +1,42 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+
+
+int main(int argc, char* argv[])
+{
+   int fd;
+   int sock;
+
+   /* This should fail with EPIPE (specific failure for open() that wouldn't
+    * normally be possible) */
+   fd = open("syscall_errno_specific.vgtest", O_RDONLY);
+   if (fd < 0) {
+      printf("Failed to open file: ");
+      if (errno == EPIPE) {
+         printf("EPIPE - correct.\n");
+      } else {
+         printf("Incorrect error (%s (%d)).\n", strerror(errno), errno);
+      }
+   } else {
+      close(fd);
+   }
+
+   /* This should fail with EINVAL (general syscall failure) */
+   sock = socket(AF_UNIX, SOCK_STREAM, 0);
+   if (sock < 0) {
+      printf("Failed to create socket: ");
+      if (errno == EINVAL) {
+         printf("Invalid input.\n");
+      } else {
+         printf("Incorrect error (%s (%d)).\n", strerror(errno), errno);
+      }
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/syscall_errno_specific1.stderr.exp b/exp-failgrind/tests/syscall_errno_specific1.stderr.exp
new file mode 100644
index 000000000..32acf30c0
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific1.stderr.exp
@@ -0,0 +1,15 @@
+   at 0x........: open (open64.c:...)
+   by 0x........: main (syscall_errno_specific1.c:18)
+   at 0x........: socket (syscall-template.S:...)
+   by 0x........: main (syscall_errno_specific1.c:31)
+   at 0x........: _Exit (_exit.c:...)
+   by 0x........: __run_exit_handlers (exit.c:...)
+   by 0x........: exit (exit.c:...)
+   by 0x........: (below main)
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            2 syscalls succeeded
+            3 syscalls failed
+            3 new syscall callstacks found
diff --git a/exp-failgrind/tests/syscall_errno_specific1.stdout.exp b/exp-failgrind/tests/syscall_errno_specific1.stdout.exp
new file mode 100644
index 000000000..3700e1391
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific1.stdout.exp
@@ -0,0 +1,2 @@
+Failed to open file: EPIPE - correct.
+Failed to create socket: Invalid input.
diff --git a/exp-failgrind/tests/syscall_errno_specific1.vgtest b/exp-failgrind/tests/syscall_errno_specific1.vgtest
new file mode 100644
index 000000000..940ec67eb
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific1.vgtest
@@ -0,0 +1,2 @@
+prog: syscall_errno_specific1
+vgopts: --callstack-input=no --callstack-output=no --syscall-allow=write --syscall-allow=_fxstat --syscall-allow=fstatat --show-failed=yes --alloc-fail-atstart=no --syscall-fail-atstart=yes --syscall-errno=open,EPIPE
diff --git a/exp-failgrind/tests/syscall_errno_specific2.c b/exp-failgrind/tests/syscall_errno_specific2.c
new file mode 100644
index 000000000..b5ac30bd4
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific2.c
@@ -0,0 +1,38 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+
+int main(int argc, char* argv[])
+{
+   int fd;
+   int pid;
+
+   /* This should fail with EACCES (specific failure for open()) */
+   fd = open("syscall_errno_specific.vgtest", O_RDONLY);
+   if (fd < 0) {
+      printf("Failed to open file: ");
+      if (errno == EACCES) {
+         printf("Access denied.\n");
+      } else {
+         printf("Incorrect error.\n");
+      }
+   } else {
+      close(fd);
+   }
+
+   /* This should succeed - specific failures only */
+   pid = getpid();
+   if (pid < 0) {
+      printf("Failed to get pid: ");
+      if (errno == EINVAL) {
+         printf("Invalid input.\n");
+      } else {
+         printf("Incorrect error.\n");
+      }
+   }
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/syscall_errno_specific2.callstacks b/exp-failgrind/tests/syscall_errno_specific2.callstacks
new file mode 100644
index 000000000..76d0abd2c
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific2.callstacks
@@ -0,0 +1,4 @@
+# ./syscall_errno_specific2
+at 0x4F42C8E: open (open64.c:47)
+by 0x1087DE: main (syscall_errno_specific2.c:14)
+
diff --git a/exp-failgrind/tests/syscall_errno_specific2.stderr.exp b/exp-failgrind/tests/syscall_errno_specific2.stderr.exp
new file mode 100644
index 000000000..741ea6101
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific2.stderr.exp
@@ -0,0 +1,9 @@
+   at 0x........: open (open64.c:...)
+   by 0x........: main (syscall_errno_specific2.c:14)
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            4 syscalls succeeded
+            1 syscalls failed
+            4 new syscall callstacks found
diff --git a/exp-failgrind/tests/syscall_errno_specific2.stdout.exp b/exp-failgrind/tests/syscall_errno_specific2.stdout.exp
new file mode 100644
index 000000000..f684ffc42
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific2.stdout.exp
@@ -0,0 +1 @@
+Failed to open file: Access denied.
diff --git a/exp-failgrind/tests/syscall_errno_specific2.vgtest b/exp-failgrind/tests/syscall_errno_specific2.vgtest
new file mode 100644
index 000000000..0a45b888f
--- /dev/null
+++ b/exp-failgrind/tests/syscall_errno_specific2.vgtest
@@ -0,0 +1,2 @@
+prog: syscall_errno_specific2
+vgopts: --callstack-output=no --show-failed=yes --alloc-fail-atstart=no --syscall-fail-atstart=yes --syscall-errno=open,EACCES --syscall-specified-only=yes
diff --git a/exp-failgrind/tests/syscall_toggle_1.c b/exp-failgrind/tests/syscall_toggle_1.c
new file mode 100644
index 000000000..ad854c417
--- /dev/null
+++ b/exp-failgrind/tests/syscall_toggle_1.c
@@ -0,0 +1,49 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+
+void syscall_func(void)
+{
+   int fd;
+
+   fd = open("syscall_toggle_1.vgtest", O_RDONLY);
+   if (fd < 0) {
+      printf("Failed to open file.\n");
+   } else {
+      close(fd);
+   }
+}
+
+void middle(void)
+{
+    syscall_func();
+}
+
+
+void testing(void)
+{
+    middle();
+}
+
+int main(int argc, char* argv[])
+{
+   /* Should succeed, syscall failing is disabled */
+   syscall_func();
+
+   /* Should also succeed. */
+   middle();
+
+   /* Should fail, the testing() function should enable failing */
+   testing();
+
+   /* Should succeed, syscall failing is disabled */
+   syscall_func();
+
+   /* Should also succeed. */
+   middle();
+
+   return 0;
+}
diff --git a/exp-failgrind/tests/syscall_toggle_1.stderr.exp b/exp-failgrind/tests/syscall_toggle_1.stderr.exp
new file mode 100644
index 000000000..9ec1dc9e8
--- /dev/null
+++ b/exp-failgrind/tests/syscall_toggle_1.stderr.exp
@@ -0,0 +1,12 @@
+   at 0x........: open (open64.c:...)
+   by 0x........: syscall_func (syscall_toggle_1.c:12)
+   by 0x........: middle (syscall_toggle_1.c:22)
+   by 0x........: testing (syscall_toggle_1.c:28)
+   by 0x........: main (syscall_toggle_1.c:40)
+ Failgrind: 0 call stacks loaded from file
+            0 allocations succeeded
+            0 allocations failed
+            0 new allocation callstacks found
+            11 syscalls succeeded
+            1 syscalls failed
+            1 new syscall callstacks found
diff --git a/exp-failgrind/tests/syscall_toggle_1.stdout.exp b/exp-failgrind/tests/syscall_toggle_1.stdout.exp
new file mode 100644
index 000000000..09eb48fa7
--- /dev/null
+++ b/exp-failgrind/tests/syscall_toggle_1.stdout.exp
@@ -0,0 +1 @@
+Failed to open file.
diff --git a/exp-failgrind/tests/syscall_toggle_1.vgtest b/exp-failgrind/tests/syscall_toggle_1.vgtest
new file mode 100644
index 000000000..0e3b78600
--- /dev/null
+++ b/exp-failgrind/tests/syscall_toggle_1.vgtest
@@ -0,0 +1,2 @@
+prog: syscall_toggle_1
+vgopts: --callstack-output=no --show-failed=yes --alloc-fail-atstart=no --syscall-fail-atstart=yes --syscall-toggle=testing --syscall-allow=write --syscall-allow=_fxstat --syscall-allow=fstatat
diff --git a/include/pub_tool_tooliface.h b/include/pub_tool_tooliface.h
index 34e577fce..45002223a 100644
--- a/include/pub_tool_tooliface.h
+++ b/include/pub_tool_tooliface.h
@@ -423,6 +423,8 @@ extern void VG_(needs_client_requests) (
    Bool (*handle_client_request)(ThreadId tid, UWord* arg_block, UWord* ret)
 );
 
+typedef struct SyscallStatus SyscallStatus;
+
 /* Tool does stuff before and/or after system calls? */
 // Nb: If either of the pre_ functions malloc() something to return, the
 // corresponding post_ function had better free() it!
@@ -435,12 +437,15 @@ extern void VG_(needs_client_requests) (
 // to be defined and to contain all the args for this syscall,
 // possibly including some trailing zeroes.
 extern void VG_(needs_syscall_wrapper) (
-               void (* pre_syscall)(ThreadId tid, UInt syscallno,
+               void (* pre_syscall)(ThreadId tid, SyscallStatus *status, UInt syscallno,
                                     UWord* args, UInt nArgs),
                void (*post_syscall)(ThreadId tid, UInt syscallno,
                                     UWord* args, UInt nArgs, SysRes res)
 );
 
+/* Force a syscall to produce an error. Use within pre_syscall() */
+extern void VG_(force_syscall_error) (SyscallStatus *status, UWord err);
+
 /* Are tool-state sanity checks performed? */
 // Can be useful for ensuring a tool's correctness.  cheap_sanity_check()
 // is called very frequently;  expensive_sanity_check() is called less
diff --git a/tests/check_headers_and_includes b/tests/check_headers_and_includes
index 509f24488..ee2a3a199 100755
--- a/tests/check_headers_and_includes
+++ b/tests/check_headers_and_includes
@@ -53,6 +53,7 @@ my %tool_dirs = (
     "none" => 1,
     "exp-bbv" => 1,
     "shared" => 1,
+    "exp-failgrind" => 1,
     );
 
 my %dirs_to_ignore = (
